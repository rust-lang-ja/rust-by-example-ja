<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example 日本語版</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item "><a href="hello.html"><strong aria-hidden="true">1.</strong> Hello World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> コメント</a></li><li class="chapter-item "><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> フォーマットしてプリント</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> デバッグ</a></li><li class="chapter-item "><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> ディスプレイ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.2.1.</strong> テストケース: リスト</a></li></ol></li><li class="chapter-item "><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.3.</strong> フォーマット</a></li></ol></li></ol></li><li class="chapter-item "><a href="primitives.html"><strong aria-hidden="true">2.</strong> 基本データ型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> リテラルとオペレータ</a></li><li class="chapter-item "><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> タプル</a></li><li class="chapter-item "><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> 配列とスライス</a></li></ol></li><li class="chapter-item "><a href="custom_types.html"><strong aria-hidden="true">3.</strong> カスタム型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> 構造体</a></li><li class="chapter-item "><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> 列挙型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> use</a></li><li class="chapter-item "><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C言語ライクな列挙型</a></li><li class="chapter-item "><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> テストケース: 連結リスト</a></li></ol></li><li class="chapter-item "><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> 定数</a></li></ol></li><li class="chapter-item "><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> 変数束縛</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> ミュータビリティ</a></li><li class="chapter-item "><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> スコープとシャドーイング</a></li><li class="chapter-item "><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> 宣言</a></li><li class="chapter-item "><a href="variable_bindings/freeze.html"><strong aria-hidden="true">4.4.</strong> 値の凍結</a></li></ol></li><li class="chapter-item "><a href="types.html"><strong aria-hidden="true">5.</strong> 型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> 型キャスティング</a></li><li class="chapter-item "><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> リテラル</a></li><li class="chapter-item "><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> 型推論</a></li><li class="chapter-item "><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> エイリアス</a></li></ol></li><li class="chapter-item "><a href="conversion.html"><strong aria-hidden="true">6.</strong> 型変換</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> FromおよびInto</a></li><li class="chapter-item "><a href="conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFromおよびTryInto</a></li><li class="chapter-item "><a href="conversion/string.html"><strong aria-hidden="true">6.3.</strong> Stringとの型変換</a></li></ol></li><li class="chapter-item "><a href="expression.html"><strong aria-hidden="true">7.</strong> 式</a></li><li class="chapter-item "><a href="flow_control.html"><strong aria-hidden="true">8.</strong> 条件分岐</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item "><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> ネストとラベル</a></li><li class="chapter-item "><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> loopが返す値</a></li></ol></li><li class="chapter-item "><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li class="chapter-item "><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for と range</a></li><li class="chapter-item "><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> デストラクト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> タプル</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> 列挙型</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> ポインタとref</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> 構造体</a></li></ol></li><li class="chapter-item "><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> ガード</a></li><li class="chapter-item "><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> バインディング</a></li></ol></li><li class="chapter-item "><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item "><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li class="chapter-item "><a href="fn.html"><strong aria-hidden="true">9.</strong> 関数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> メソッド</a></li><li class="chapter-item "><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> クロージャ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> 要素の捕捉</a></li><li class="chapter-item "><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> 捕捉時の型推論</a></li><li class="chapter-item "><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> クロージャを受け取る関数</a></li><li class="chapter-item "><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> 関数を受け取る関数</a></li><li class="chapter-item "><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> クロージャを返す関数</a></li><li class="chapter-item "><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> stdにおける使用例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item "><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li class="chapter-item "><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> 高階関数</a></li><li class="chapter-item "><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> Diverging functions</a></li></ol></li><li class="chapter-item "><a href="mod.html"><strong aria-hidden="true">10.</strong> モジュール</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> プライベートとパブリック</a></li><li class="chapter-item "><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> 構造体の場合</a></li><li class="chapter-item "><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> use宣言</a></li><li class="chapter-item "><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> super と self</a></li><li class="chapter-item "><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> ファイルの階層構造</a></li></ol></li><li class="chapter-item "><a href="crates.html"><strong aria-hidden="true">11.</strong> クレート</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> ライブラリ</a></li><li class="chapter-item "><a href="crates/link.html"><strong aria-hidden="true">11.2.</strong> extern crate</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> Dependencies</a></li><li class="chapter-item "><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> Conventions</a></li><li class="chapter-item "><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> Tests</a></li><li class="chapter-item "><a href="cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> Build Scripts</a></li></ol></li><li class="chapter-item "><a href="attribute.html"><strong aria-hidden="true">13.</strong> アトリビュート</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> dead_code</a></li><li class="chapter-item "><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> クレート</a></li><li class="chapter-item "><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> 条件の追加</a></li></ol></li></ol></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">14.</strong> ジェネリクス</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> 関数</a></li><li class="chapter-item "><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> メソッド</a></li><li class="chapter-item "><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> ジェネリックトレイト</a></li><li class="chapter-item "><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> ジェネリック境界</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> テストケース: 空トレイト</a></li></ol></li><li class="chapter-item "><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> 複数のジェネリック境界</a></li><li class="chapter-item "><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> Where句</a></li><li class="chapter-item "><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> New Type Idiom</a></li><li class="chapter-item "><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> 関連型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> 関連型が必要になる状況</a></li><li class="chapter-item "><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> 関連型</a></li></ol></li><li class="chapter-item "><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> 幽霊型パラメータ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> テストケース: 単位を扱う</a></li></ol></li></ol></li><li class="chapter-item "><a href="scope.html"><strong aria-hidden="true">15.</strong> スコーピングの規則</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item "><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> 所有権とムーブ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> ミュータビリティ</a></li></ol></li><li class="chapter-item "><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> 借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> ミュータビリティ</a></li><li class="chapter-item "><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.2.</strong> エイリアス</a></li><li class="chapter-item "><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> refパターン</a></li></ol></li><li class="chapter-item "><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> ライフタイム</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> 明示的アノテーション</a></li><li class="chapter-item "><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> 関数</a></li><li class="chapter-item "><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> メソッド</a></li><li class="chapter-item "><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> 構造体</a></li><li class="chapter-item "><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> Traits</a></li><li class="chapter-item "><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> ライフタイム境界</a></li><li class="chapter-item "><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> 圧縮</a></li><li class="chapter-item "><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> スタティックライフタイム</a></li><li class="chapter-item "><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> 省略</a></li></ol></li></ol></li><li class="chapter-item "><a href="trait.html"><strong aria-hidden="true">16.</strong> トレイト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> 継承(Derive)</a></li><li class="chapter-item "><a href="trait/dyn.html"><strong aria-hidden="true">16.2.</strong> Returning Traits with dyn</a></li><li class="chapter-item "><a href="trait/ops.html"><strong aria-hidden="true">16.3.</strong> 演算子のオーバーロード</a></li><li class="chapter-item "><a href="trait/drop.html"><strong aria-hidden="true">16.4.</strong> メモリ解放</a></li><li class="chapter-item "><a href="trait/iter.html"><strong aria-hidden="true">16.5.</strong> イテレータ</a></li><li class="chapter-item "><a href="trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item "><a href="trait/clone.html"><strong aria-hidden="true">16.7.</strong> クローン</a></li><li class="chapter-item "><a href="trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> Supertraits</a></li><li class="chapter-item "><a href="trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> Disambiguating overlapping traits</a></li></ol></li><li class="chapter-item "><a href="macros.html"><strong aria-hidden="true">17.</strong> macro_rules!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> 構文</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> 識別子</a></li><li class="chapter-item "><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> オーバーロード</a></li><li class="chapter-item "><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> 繰り返し</a></li></ol></li><li class="chapter-item "><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (Don't Repeat Yourself)</a></li><li class="chapter-item "><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> Domain Specific Languages (ドメイン特化言語、DSLs)</a></li><li class="chapter-item "><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> 可変個引数</a></li></ol></li><li class="chapter-item "><a href="error.html"><strong aria-hidden="true">18.</strong> エラーハンドリング</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item "><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Option と unwrap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.2.1.</strong> ?によるOptionのアンパック</a></li><li class="chapter-item "><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.2.</strong> Combinators: map</a></li><li class="chapter-item "><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.3.</strong> Combinators: and_then</a></li></ol></li><li class="chapter-item "><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> Resultのmap</a></li><li class="chapter-item "><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> Resultに対するエイリアス</a></li><li class="chapter-item "><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> 早期リターン</a></li><li class="chapter-item "><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> ?の導入</a></li></ol></li><li class="chapter-item "><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> 複数のエラー型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> OptionからResultを取り出す</a></li><li class="chapter-item "><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> エラー型を定義する</a></li><li class="chapter-item "><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> エラーをBoxする</a></li><li class="chapter-item "><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> ?の他の活用法</a></li><li class="chapter-item "><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> エラーをラップする</a></li></ol></li><li class="chapter-item "><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> Resultをイテレートする</a></li></ol></li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">19.</strong> 標準ライブラリの型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> Box, スタックとヒープ</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> ベクタ型</a></li><li class="chapter-item "><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> 文字列</a></li><li class="chapter-item "><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li class="chapter-item "><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li class="chapter-item "><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item "><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> ハッシュマップ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> key型の変種</a></li><li class="chapter-item "><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> ハッシュ集合</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> Rc</a></li></ol></li><li class="chapter-item "><a href="std_misc.html"><strong aria-hidden="true">20.</strong> 標準ライブラリのその他</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> スレッド</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> Testcase: map-reduce</a></li></ol></li><li class="chapter-item "><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> チャネル</a></li><li class="chapter-item "><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> Path</a></li><li class="chapter-item "><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> ファイル I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> open</a></li><li class="chapter-item "><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> create</a></li><li class="chapter-item "><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> read lines</a></li></ol></li><li class="chapter-item "><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> 子プロセス</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> パイプ</a></li><li class="chapter-item "><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> dropの延期</a></li></ol></li><li class="chapter-item "><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> ファイルシステムとのやり取り</a></li><li class="chapter-item "><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> 引数処理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> 引数のパース</a></li></ol></li><li class="chapter-item "><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> 他言語関数インターフェイス</a></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">21.</strong> Testing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> Unit testing</a></li><li class="chapter-item "><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> Documentation testing</a></li><li class="chapter-item "><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> Integration testing</a></li><li class="chapter-item "><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> Dev-dependencies</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">22.</strong> 安全でない操作</a></li><li class="chapter-item "><a href="compatibility.html"><strong aria-hidden="true">23.</strong> Compatibility</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> Raw identifiers</a></li></ol></li><li class="chapter-item "><a href="meta.html"><strong aria-hidden="true">24.</strong> 周辺情報</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> ドキュメンテーション</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Example 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-ja/rust-by-example-ja" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Rust by Example
-->
<h1 id="rust-by-example-日本語版"><a class="header" href="#rust-by-example-日本語版">Rust by Example 日本語版</a></h1>
<!--
[Rust][rust] is a modern systems programming language focusing on safety, speed,
and concurrency. It accomplishes these goals by being memory safe without using 
garbage collection.
-->
<p><a href="https://www.rust-lang.org/">Rust</a> は安全性、速度、並列性にフォーカスした現代的なシステムプログラミング
用のプログラミング言語です。
ガベージコレクション無しでメモリ安全であることが、これを可能にしています。</p>
<!--
Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust
concepts and standard libraries. To get even more out of these examples, don't forget
to [install Rust locally][install] and check out the [official docs][std]. 
Additionally for the curious, you can also [check out the source code for this site][home].
-->
<p>Rust by Example(RBE)はRustの実行可能なサンプルスクリプト集で、ここではRustの様々な
コンセプトと標準ライブラリを紹介していきます。
この例をより活用するためには<a href="https://www.rust-lang.org/tools/install">Rustをローカルにインストール</a>し、<a href="https://doc.rust-lang.org/std/">公式ドキュメント</a>をチェックすることをおすすめします。
興味がある方は<a href="https://github.com/rust-lang/rust-by-example">このサイト自体のソース</a>のチェックもどうぞ。</p>
<blockquote>
<p>訳注:
日本語版のソースコードは<a href="https://github.com/rust-lang-ja/rust-by-example-ja">こちら</a>にあります。</p>
</blockquote>
<!--
Now let's begin!
-->
<p>それでははじめましょう!</p>
<!--
- [Hello World](hello.md) - Start with a traditional Hello World program.
-->
<ul>
<li><a href="hello.html">Hello World</a> - お決まりのHello Worldプログラムから始めましょう。</li>
</ul>
<!--
- [Primitives](primitives.md) - Learn about signed integers, unsigned integers and other primitives.
-->
<ul>
<li><a href="primitives.html">基本データ型</a> - 符号付き整数や符号無し整数、その他の基本データ型について学びましょう。</li>
</ul>
<!--
- [Custom Types](custom_types.md) - `struct` and `enum`.
-->
<ul>
<li><a href="custom_types.html">カスタム型</a> - <code>struct</code> と <code>enum</code>について。</li>
</ul>
<!--
- [Variable Bindings](variable_bindings.md) - mutable bindings, scope, shadowing.
-->
<ul>
<li><a href="variable_bindings.html">変数の束縛</a> - ミュータブルな束縛、スコープ、シャドーイングについて。</li>
</ul>
<!--
- [Types](types.md) - Learn about changing and defining types.
-->
<ul>
<li><a href="types.html">型</a> - 型を変更したり定義したりすることを学びましょう。</li>
</ul>
<!--
- [Conversion](conversion.md)
-->
<ul>
<li><a href="conversion.html">型変換</a></li>
</ul>
<!--
- [Expressions](expression.md)
-->
<ul>
<li><a href="expression.html">式</a></li>
</ul>
<!--
- [Flow of Control](flow_control.md) - `if`/`else`, `for`, and others.
-->
<ul>
<li><a href="flow_control.html">制御フロー</a> - <code>if</code>や<code>else</code>、<code>for</code>など。</li>
</ul>
<!--
- [Functions](fn.md) - Learn about Methods, Closures and High Order Functions.
-->
<ul>
<li><a href="fn.html">関数</a> - メソッド、クロージャ、高階関数について。</li>
</ul>
<!--
- [Modules](mod.md) - Organize code using modules
-->
<ul>
<li><a href="mod.html">モジュール</a> - プログラムをモジュールを使って整理しましょう。</li>
</ul>
<!--
- [Crates](crates.md) - A crate is a compilation unit in Rust. Learn to create a library.
-->
<ul>
<li><a href="crates.html">クレート</a> - クレートは、Rustにおいてコンパイルされる単位です。ライブラリの作り方について学びます。</li>
</ul>
<!--
- [Cargo](cargo.md) - Go through some basic features of the official Rust package management tool.
-->
<ul>
<li><a href="cargo.html">Cargo</a> - Rustの公式パッケージマネージャの基本的な機能を学びます。</li>
</ul>
<!--
- [Attributes](attribute.md) - An attribute is metadata applied to some module, crate or item.
-->
<ul>
<li><a href="attribute.html">アトリビュート</a> - アトリビュートは、モジュールやクレート、要素に適用されるメタデータです。</li>
</ul>
<!--
- [Generics](generics.md) - Learn about writing a function or data type which can work for multiple types of arguments.
-->
<ul>
<li><a href="generics.html">ジェネリクス</a> - 様々な型の引数を取れる関数やデータ型を書く方法を学びましょう。</li>
</ul>
<!--
- [Scoping rules](scope.md) - Scopes play an important part in ownership, borrowing, and lifetimes.
-->
<ul>
<li><a href="scope.html">スコープの規則</a> - スコープは所有権、借用、ライフタイムにおいて重要な役割を果たします。</li>
</ul>
<!--
- [Traits](trait.md) - A trait is a collection of methods defined for an unknown type: `Self`
-->
<ul>
<li><a href="trait.html">トレイト</a> - トレイトとは、未知の型<code>Self</code>に対して定義された一連のメソッドです。</li>
</ul>
<!--
- [Macros](macros.md)
-->
<ul>
<li><a href="macros.html">マクロ</a></li>
</ul>
<!--
- [Error handling](error.md) - Learn Rust way of handling failures.
-->
<ul>
<li><a href="error.html">エラーハンドリング</a> - 失敗に対処するRust流のやり方を学びましょう。</li>
</ul>
<!--
- [Std library types](std.md) - Learn about some custom types provided by `std` library.
-->
<ul>
<li><a href="std.html">標準ライブラリの型</a> - <code>std</code>ライブラリによって提供されるいくつかのカスタム型について学びます。</li>
</ul>
<!--
- [Std misc](std_misc.md) - More custom types for file handling, threads.
-->
<ul>
<li><a href="std_misc.html">標準ライブラリのその他</a> - ファイルハンドリングとスレッドのためのカスタム型について。</li>
</ul>
<!--
- [Testing](testing.md) - All sorts of testing in Rust.
-->
<ul>
<li><a href="testing.html">テスト</a> - Rustにおけるテストのすべて。</li>
</ul>
<!--
- [Unsafe Operations](unsafe.md)
-->
<ul>
<li><a href="unsafe.html">安全でない操作</a></li>
</ul>
<!--
- [Compatibility](compatibility.md)
-->
<ul>
<li><a href="compatibility.html">互換性</a></li>
</ul>
<!--
- [Meta](meta.md) - Documentation, Benchmarking.
-->
<ul>
<li><a href="meta.html">周辺情報</a> - ドキュメント、ベンチマークの方法。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<!--
This is the source code of the traditional Hello World program.
-->
<p>ここでは伝統的な&quot;Hello World!&quot;プログラムのソースを紹介します。　</p>
<pre><pre class="playground"><code class="language-rust editable">// This is a comment, and is ignored by the compiler
// You can test this code by clicking the &quot;Run&quot; button over there -&gt;
// or if you prefer to use your keyboard, you can use the &quot;Ctrl + Enter&quot; shortcut
// これはコメントです。コンパイラによって無視されます。
// 右にある「Run」ボタンからこのコードをテストできます。
// キーボードを使いたければ「Ctrl + Enter」もOKです。

// This code is editable, feel free to hack it!
// You can always return to the original code by clicking the &quot;Reset&quot; button -&gt;
// このコードは編集可能です。ぜひハックしてみましょう！
// 「Reset」ボタンでいつでも元のコードに戻すことができます -&gt;

// This is the main function
// main関数です
fn main() {
    // Statements here are executed when the compiled binary is called
    // コンパイルされたバイナリが実行されるとこの関数が呼び出されます

    // Print text to the console
    // コンソールに文字列を出力する
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<!--
`println!` is a [*macro*][macros] that prints text to the
console.
-->
<p><code>println!</code>は文字列をコンソールにプリントするための<a href="macros.html"> <em>マクロ</em> </a>です。</p>
<!--
A binary can be generated using the Rust compiler: `rustc`.
-->
<p>バイナリファイルは<code>rustc</code>と呼ばれるRustのコンパイラを用いて生成することができます。</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<!--
`rustc` will produce a `hello` binary that can be executed.
-->
<p>すると<code>hello</code>という名前の実行可能なバイナリファイルができます。</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<!--
### Activity
-->
<h3 id="演習"><a class="header" href="#演習">演習</a></h3>
<!--
Click 'Run' above to see the expected output. Next, add a new
line with a second `println!` macro so that the output
shows:
-->
<p>上に書いている'Run'をクリックしてアウトプットを見てみましょう。
次に、<code>println!</code>マクロをもう一行追加してアウトプットがどうなるか見てみましょう。</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Comments
-->
<h1 id="コメント"><a class="header" href="#コメント">コメント</a></h1>
<!--
Any program requires comments, and Rust supports
a few different varieties:
-->
<p>あらゆるプログラムにはコメントが必要です。Rustには何種類かのコメントがあります</p>
<!--
* *Regular comments* which are ignored by the compiler:
   * `// Line comments which go to the end of the line.`
   * `/* Block comments which go to the closing delimiter. */`
* *Doc comments* which are parsed into HTML library
  [documentation][docs]:
   * `/// Generate library docs for the following item.`
   * `//! Generate library docs for the enclosing item.`
-->
<ul>
<li><em>通常のコメント</em> これはコンパイラによって完全に無視されます。
<ul>
<li><code>// 行末までコメントアウト</code></li>
<li><code>/* ブロックによって囲まれた部分をコメントアウト */</code></li>
</ul>
</li>
<li><em>ドキュメンテーションコメント</em> ライブラリのドキュメンテーションとしてhtmlにパースされます。
<ul>
<li><code>/// このコメントの下の内容に関するドキュメントとなります</code></li>
<li><code>//! このコメントを含むソースのドキュメントになります</code></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // This is an example of a line comment
    // There are two slashes at the beginning of the line
    // And nothing written inside these will be read by the compiler
    // こちらはラインコメントです
    // 一番左にスラッシュが2つある行と、何も書かれていない行は
    // どちらもコンパイラによって無視されます。試しに実行してみてください

    // println!(&quot;Hello, world!&quot;);

    // Run it. See? Now try deleting the two slashes, and run it again.
    // でしょ？では次に、左のスラッシュを消去してから実行してください

    /* 
     * This is another type of comment, a block comment. In general,
     * line comments are the recommended comment style. But
     * block comments are extremely useful for temporarily disabling
     * chunks of code. /* Block comments can be /* nested, */ */
     * so it takes only a few keystrokes to comment out everything
     * in this main() function. /*/*/* Try it yourself! */*/*/
     */
    /*
     * こちらはもう一つのタイプのコメントでブロックコメントと呼ばれます。
     * 普通はラインコメントの方が優れているのですが、こちらはデバッグ時に
     * 役立つ場合があります。
     */

    /*
    Note: The previous column of `*` was entirely for style. There's
    no actual need for it.
    */
    /*
    このように、`*`は、実際にはコメントの前後に１つずつあれば十分です。
    */

    // You can manipulate expressions more easily with block comments
    // than with line comments. Try deleting the comment delimiters
    // to change the result:
    // ではブロックコメントがどのようにデバッグに役立つか見てみましょう。
    // 例えば下の例の場合、ブロックコメントがなくなれば結果が変わります。
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}

</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照"><a class="header" href="#参照">参照</a></h3>
<!--
[Library documentation][docs]
-->
<p><a href="hello/../meta/doc.html">ライブラリドキュメンテーション</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Formatted print
-->
<h1 id="フォーマットしてプリント"><a class="header" href="#フォーマットしてプリント">フォーマットしてプリント</a></h1>
<!--
Printing is handled by a series of [`macros`][macros] defined in [`std::fmt`][fmt]
some of which include:
-->
<p>プリント関係の機能は<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>で定義される幾つかの<a href="hello/../macros.html">マクロ</a>によって扱われます。このマクロには以下が含まれます。</p>
<!--
* `format!`: write formatted text to [`String`][string]
* `print!`: same as `format!` but the text is printed to the console (io::stdout).
* `println!`: same as `print!` but a newline is appended.
* `eprint!`: same as `format!` but the text is printed to the standard error (io::stderr).
* `eprintln!`: same as `eprint!`but a newline is appended.
-->
<ul>
<li><code>format!</code>: フォーマットされたテキストを文字列(String)型に書き込みます。</li>
<li><code>print!</code>: <code>format!</code> と同様ですが、コンソール (io::stdout) にそのテキストを出力します。</li>
<li><code>println!</code>: <code>print!</code>: と同じですが改行が付け加えられます。</li>
<li><code>eprint!</code>: <code>format!</code> と同様ですが、標準エラー出力 (io::stderr) にそのテキストを出力します。</li>
<li><code>eprintln!</code>: <code>eprint!</code>と同じですが改行が付け加えられます。</li>
</ul>
<!--
All parse text in the same fashion. As a plus, Rust checks formatting
correctness at compile time.
-->
<p>すべて同じやり方でテキストをパースし、正しくフォーマットできるかコンパイル時にチェックします。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // In general, the `{}` will be automatically replaced with any
    // arguments. These will be stringified.
    // 一般的に `{} `はどんな引数であろうと自動的に置き換えられます。
    // 例えば以下は文字列に変換されます
    println!(&quot;{} days&quot;, 31);

    // Without a suffix, 31 becomes an i32. You can change what type 31 is
    // by providing a suffix. The number 31i64 for example has the type i64.
    // サフィックスで型を指定しなければ31はi32として扱われます。
    // サフィックスの指定により、31の型を自由に変換することができます。

    // There are various optional patterns this works with. Positional
    // arguments can be used.
    // 引数の位置から埋め込まれる場所を指定することができます。
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // As can named arguments.
    // 名前での指定も可能です。
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;the lazy dog&quot;,
             subject=&quot;the quick brown fox&quot;,
             verb=&quot;jumps over&quot;);

    // Special formatting can be specified after a `:`.
    // `:` のあとにフォーマット型を指定することによる特殊なフォーマットも可能です.
    println!(&quot;{} of {:b} people know binary, the other half doesn't&quot;, 1, 2);

    // You can right-align text with a specified width. This will output
    // &quot;     1&quot;. 5 white spaces and a &quot;1&quot;.
    // 指定した幅の中に、右寄せで文字列を挿入することができます。
    // 以下の例では&quot;     1&quot;. というように、５つの半角空白のあとに&quot;1&quot;が入ります.
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // You can pad numbers with extra zeroes. This will output &quot;000001&quot;.
    // 空白の代わりに0を使うこともできます. このアウトプットは &quot;000001&quot; になります.
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // Rust even checks to make sure the correct number of arguments are
    // used.
    // 引数の数が正しいかのチェックも行ってくれます。
    println!(&quot;My name is {0}, {1} {0}&quot;, &quot;Bond&quot;);
    // FIXME ^ Add the missing argument: &quot;James&quot;

    // Create a structure named `Structure` which contains an `i32`.
    // `i32`保持する `Structure` という名の構造体を定義します.
    #[allow(dead_code)]
    struct Structure(i32);

    // However, custom types such as this structure require more complicated
    // handling. This will not work.
    // このようにカスタム型を用いる場合、少々扱いが複雑になります。
    // 以下は動作しません。
    println!(&quot;This struct `{}` won't print...&quot;, Structure(3));
    // FIXME ^ Comment out this line.
}
</code></pre></pre>
<!--
[`std::fmt`][fmt] contains many [`traits`][traits] which govern the display
of text. The base form of two important ones are listed below:
-->
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>はいくつもの<a href="hello/../trait.html">トレイト</a>を持ち、それによってどのようにディスプレイに表示されるかが決まります。
特に大事な形式は以下の２つです。</p>
<!--
* `fmt::Debug`: Uses the `{:?}` marker. Format text for debugging purposes.
* `fmt::Display`: Uses the `{}` marker. Format text in a more elegant, user
friendly fashion.
-->
<ul>
<li><code>fmt::Debug</code>: は、<code>{:?}</code>というマーカーを使用し、デバッギング目的に使われます。</li>
<li><code>fmt::Display</code>: は <code>{}</code>というマーカーを使用し、より美しく、ユーザフレンドリーに表示します。</li>
</ul>
<!--
Here, we used `fmt::Display `because the std library provides implementations
for these types. To print text for custom types, more steps are required.
-->
<p>この例で用いられている型は、標準ライブラリに含まれているため、ここでは<code>fmt::Display</code>を使用しています。カスタム型をテキストとして表示する場合は、さらに手順が必要です。</p>
<!--
Implementing the `fmt::Display` trait automatically implements the
[`ToString`] trait which allows us to [convert] the type to [`String`][string].
-->
<p><code>fmt::Display</code>トレイトを実装すると、自動的に<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>トレイトが実装されます。これにより<a href="hello/../std/str.html"><code>String</code></a>型への型変換ができるようになります。</p>
<!--
### Activities
-->
<h3 id="演習-1"><a class="header" href="#演習-1">演習</a></h3>
<!--
 * Fix the two issues in the above code (see FIXME) so that it runs without
   error.
 * Add a `println!` macro that prints: `Pi is roughly 3.142` by controlling
   the number of decimal places shown. For the purposes of this exercise,
   use `let pi = 3.141592` as an estimate for pi. (Hint: you may need to
   check the [`std::fmt`][fmt] documentation for setting the number of
   decimals to display)
-->
<ul>
<li>上の例を実行した際に生じるエラーを修復しましょう。</li>
<li><code>println!</code>マクロを追加し、表示される小数部の桁数を調整して<code>Pi is roughly 3.142</code>という文字列を出力しましょう。
ただし、円周率の値は<code>let pi = 3.141592</code>を使ってください。（ヒント: 小数部の桁数を調整する方法については、<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>をチェックする必要があるかもしれません。）</li>
</ul>
<!--
### See also:
-->
<h3 id="参照-1"><a class="header" href="#参照-1">参照</a></h3>
<!--
[`std::fmt`][fmt], [`macros`][macros], [`struct`][structs],
and [`traits`][traits]
-->
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/../macros.html">マクロ</a>, <a href="hello/../custom_types/structs.html">構造体</a>,
<a href="hello/../trait.html">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Debug
-->
<h1 id="デバッグ"><a class="header" href="#デバッグ">デバッグ</a></h1>
<!--
All types which want to use `std::fmt` formatting `traits` require an
implementation to be printable. Automatic implementations are only provided
for types such as in the `std` library. All others *must* be manually
implemented somehow.
-->
<p><code>std::fmt</code>のフォーマット用<code>トレイト</code>を使用したい型は、プリント可能である用に実装されている必要があります。<code>std</code>ライブラリの型のように自動でプリント可能なものもありますが、他はすべて <em>手動で実装する必要があります。</em></p>
<!--
The `fmt::Debug` `trait` makes this very straightforward. *All* types can
`derive` (automatically create) the `fmt::Debug` implementation. This is
not true for `fmt::Display` which must be manually implemented.
-->
<p><code>fmt::Debug</code>という<code>トレイト</code>はこれを簡略化します。 <em>すべての</em> 型は<code>fmt::Debug</code>の実装を<code>derive</code>、（すなわち自動で作成）することができるためです。
<code>fmt::Display</code>の場合はやはり手動で実装しなくてはなりません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This structure cannot be printed either with `fmt::Display` or
// with `fmt::Debug`.
// この構造体は`fmt::Display`、`fmt::Debug`のいずれによっても
// プリントすることができません。
struct UnPrintable(i32);

// The `derive` attribute automatically creates the implementation
// required to make this `struct` printable with `fmt::Debug`.
// `derive`アトリビュートは、
// この構造体を`fmt::Debug`でプリントするための実装を自動で提供します。
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}
</span></code></pre></pre>
<!--
All `std` library types automatically are printable with `{:?}` too:
-->
<p><code>std</code>ライブラリの型の場合は、自動的に<code>{:?}</code>によりプリント可能になっています。</p>
<pre><pre class="playground"><code class="language-rust editable">// Derive the `fmt::Debug` implementation for `Structure`. `Structure`
// is a structure which contains a single `i32`.
// `Structure`という構造体のための`fmt::Debug`をderiveしています。
// `Structure`は単一の`i32`をメンバに持っています。
#[derive(Debug)]
struct Structure(i32);

// Put a `Structure` inside of the structure `Deep`. Make it printable
// also.
// `Deep`という構造体の中に`Structure`を入れます。
// また、これをプリント可能にしています。
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // Printing with `{:?}` is similar to with `{}`.
    // `{:?}`によるプリントは `{}`に似ています。
    println!(&quot;{:?} months in a year.&quot;, 12);
    println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
             &quot;Slater&quot;,
             &quot;Christian&quot;,
             actor=&quot;actor's&quot;);

    // `Structure` is printable!
    // `Structure`はプリント可能です！
    println!(&quot;Now {:?} will print!&quot;, Structure(3));
    
    // The problem with `derive` is there is no control over how
    // the results look. What if I want this to just show a `7`?
    // `derive`を用いることの問題は、結果がどのように見えるか
    // コントロールする方法がないことです。
    // 出力を`7`だけにするためにはどうしたらよいでしょう？
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<!--
So `fmt::Debug` definitely makes this printable but sacrifices some
elegance. Rust also provides "pretty printing" with `{:#?}`.
-->
<p><code>fmt::Debug</code>は確実にプリント可能にしてくれるのですが、一方である種の美しさを犠牲にしています。
Rustは<code>{:#?}</code>による「見栄えの良いプリント」も提供します。</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Pretty print
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<!--
One can manually implement `fmt::Display` to control the display.
-->
<p>手動で<code>fmt::Display</code>を実装することでプリント結果を思い通りにできます。</p>
<!--
### See also:
-->
<h3 id="参照-2"><a class="header" href="#参照-2">参照</a></h3>
<!--
[attributes][attributes], [`derive`][derive], [`std::fmt`][fmt],
and [`struct`][structs]
-->
<p><a href="https://doc.rust-lang.org/reference/attributes.html">アトリビュート</a>, <a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>,
<a href="hello/print/../../custom_types/structs.html">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Display
-->
<h1 id="ディスプレイ"><a class="header" href="#ディスプレイ">ディスプレイ</a></h1>
<!--
`fmt::Debug` hardly looks compact and clean, so it is often advantageous to
customize the output appearance. This is done by manually implementing
[`fmt::Display`][fmt], which uses the `{}` print marker. Implementing it
looks like this:
-->
<p><code>fmt::Debug</code>はコンパクトでクリーンであるようには見えませんね。大抵の場合は、アウトプットの見た目をカスタマイズしたほうが好ましいでしょう。これは<code>{}</code>を使用する<a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a>を手動で実装することで可能です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Import (via `use`) the `fmt` module to make it available.
// （`use`を使用し、）`fmt`モジュールをインポートします。
use std::fmt;

// Define a structure for which `fmt::Display` will be implemented. This is
// a tuple struct named `Structure` that contains an `i32`.
// `fmt::Display`を実装するための構造体を定義します。
// これは`Structure`という名前に紐付けられた、`i32`を含むタプルです。
struct Structure(i32);

// To use the `{}` marker, the trait `fmt::Display` must be implemented
// manually for the type.
// `{}` というマーカーを使用するためには、
// この型専用の`fmt::Display`というトレイトが実装されていなくてはなりません。
impl fmt::Display for Structure {
    // This trait requires `fmt` with this exact signature.
    // このトレイトは`fmt`が想定通りのシグネチャであることを要求します。
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        // 必ず、第一の要素が出力されるようにしています。
        // `f`は`fmt::Result`を返します。これはオペレーションが成功したか否か
        // を表します。
        // `write!`は`println!`に非常によく似た文法を使用していることに注目。
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
`fmt::Display` may be cleaner than `fmt::Debug` but this presents
a problem for the `std` library. How should ambiguous types be displayed?
For example, if the `std` library implemented a single style for all
`Vec<T>`, what style should it be? Would it be either of these two?
-->
<p><code>fmt::Display</code>は<code>fmt::Debug</code>より綺麗かもしれませんが、<code>std</code>ライブラリの場合は問題が生じます。曖昧な(ambiguous)タイプはどのように表示すれば良いでしょう？
例えば、<code>std</code>ライブラリがあらゆる<code>Vec&lt;T&gt;</code>に対して単一のスタイルを提供していた場合、どのようなスタイルに整形すればよいでしょう？以下の２つのどちらかを選ぶべきでしょうか？</p>
<!--
* `Vec<path>`: `/:/etc:/home/username:/bin` (split on `:`)
* `Vec<number>`: `1,2,3` (split on `,`)
-->
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> （<code>:</code>で分割）</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> （<code>,</code>で分割）</li>
</ul>
<!--
No, because there is no ideal style for all types and the `std` library
doesn't presume to dictate one. `fmt::Display` is not implemented for `Vec<T>`
or for any other generic containers. `fmt::Debug` must then be used for these
generic cases.
-->
<p>答えはNOです。あらゆる型に対して理想的なスタイルなどというものはありませんし、<code>std</code>ライブラリによってそれが提供されているわけでもありません。<code>fmt::Display</code>は<code>Vec&lt;T&gt;</code>のようなジェネリックなコンテナ用に定義されているわけではありませんので、このような場合は<code>fmt::Debug</code>を使用するべきです。</p>
<!--
This is not a problem though because for any new *container* type which is
*not* generic,`fmt::Display` can be implemented.
-->
<p>ジェネリック <em>でない</em> コンテナ型の場合は、このような問題は生じませんので問題なく<code>fmt::Display</code>を実装することができます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt; // Import `fmt`

// A structure holding two numbers. `Debug` will be derived so the results can
// be contrasted with `Display`.
// 2つの数字を扱うための構造体です。出力を`Display`と比較するため`Debug`
// をDeriveしています
#[derive(Debug)]
struct MinMax(i64, i64);

// Implement `Display` for `MinMax`.
// `MinMax`用の`Display`を実装しています。
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Use `self.number` to refer to each positional data point.
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// Define a structure where the fields are nameable for comparison.
// 比較のため、フィールドに名前をつけれる様な構造体を定義しましょう
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// Similarly, implement `Display` for `Point2D`
// 先程と同様にして、Point2D用の`Display`を実装しています。
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Customize so only `x` and `y` are denoted.
        // `x`と`y`のみが明示的になるようにカスタマイズ
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Compare structures:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;The big range is {big} and the small is {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Compare points:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // Error. Both `Debug` and `Display` were implemented, but `{:b}`
    // requires `fmt::Binary` to be implemented. This will not work.
    // `Debug`と`Display`は実装されていますが、`fmt::Binary`はされていないため
    // `{:b}`使用している以下の例はエラーになります、
    // println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);
}
</code></pre></pre>
<!--
So, `fmt::Display` has been implemented but `fmt::Binary` has not, and
therefore cannot be used. `std::fmt` has many such [`traits`][traits] and
each requires its own implementation. This is detailed further in
[`std::fmt`][fmt].
-->
<p><code>fmt::Display</code>は実装されていますが、<code>fmt::Binary</code>はされていないので使用できません。
<code>std::fmt</code>はそのような<a href="hello/print/../../trait.html">トレイト</a>が数多くあり、それぞれに独自の実装が必要です。詳しくは<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>を参照してください。</p>
<!--
### Activity
-->
<h3 id="演習-2"><a class="header" href="#演習-2">演習</a></h3>
<!--
After checking the output of the above example, use the `Point2D` struct as a
guide to add a Complex struct to the example. When printed in the same
way, the output should be:
-->
<p>上記の例のアウトプットを確認し、<code>Point2D</code>構造体を参考として、複素数を格納するための構造体を定義しましょう。うまく行けば以下のように出力されるはずです。</p>
<pre><code class="language-txt">Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<!--
### See also:
-->
<h3 id="参照-3"><a class="header" href="#参照-3">参照</a></h3>
<!--
[`derive`][derive], [`std::fmt`][fmt], [macros], [`struct`][structs],
[`trait`][traits], and [use][use]
-->
<p><a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../macros.html">マクロ</a>, <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/../../trait.html"><code>trait</code></a>, <a href="hello/print/../../mod/use.html">use</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Testcase: List
-->
<h1 id="テストケース-リスト"><a class="header" href="#テストケース-リスト">テストケース: リスト</a></h1>
<!--
Implementing `fmt::Display` for a structure where the elements must each be
handled sequentially is tricky. The problem is that each `write!` generates a
`fmt::Result`. Proper handling of this requires dealing with *all* the
results. Rust provides the `?` operator for exactly this purpose.
-->
<p>構造体のそれぞれの要素を別々に扱う<code>fmt::Display</code>を実装するのはトリッキーです。というのも、それぞれの<code>write!</code>が別々の<code>fmt::Result</code>を生成するためです。適切に処理するためには <em>すべての</em> resultに対して処理を書かなくてはなりません。このような場合は<code>?</code>演算子を使用するのが適当です。</p>
<!--
Using `?` on `write!` looks like this:
-->
<p>以下のように<code>?</code>を<code>write!</code>に対して使用します。</p>
<pre><code class="language-rust ignore">// Try `write!` to see if it errors. If it errors, return
// the error. Otherwise continue.
// `write!`を実行し、エラーが生じた場合はerrorを返す。そうでなければ実行を継続する。
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>Alternatively, you can also use the <code>try!</code> macro, which works the same way. 
This is a bit more verbose and no longer recommended, but you may still see it in
older Rust code. Using <code>try!</code> looks like this:</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<!--
With `?` available, implementing `fmt::Display` for a `Vec` is
straightforward:
-->
<p><code>?</code>を使用できれば、<code>Vec</code>用の<code>fmt::Display</code>はより簡単に実装できます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt; // Import the `fmt` module.

// Define a structure named `List` containing a `Vec`.
// `Vec`を含む`List`という名の構造体を定義
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Extract the value using tuple indexing,
        // and create a reference to `vec`.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // Iterate over `v` in `vec` while enumerating the iteration
        // count in `count`.
        // `v`を介して`vec`をイテレーションし、同時にカウントを
        // `enumerate`で取得する
        for (count, v) in vec.iter().enumerate() {
            // For every element except the first, add a comma.
            // Use the ? operator, or try!, to return on errors.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // Close the opened bracket and return a fmt::Result value.
        // 開きっぱなしのブラケットを閉じて、`fmt::Result`の値を返す。
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<!--
### Activity
-->
<h3 id="演習-3"><a class="header" href="#演習-3">演習</a></h3>
<!--
Try changing the program so that the index of each element in the vector is also printed. The new output should look like this:
-->
<p>上記のプログラムを変更して、ベクタの各要素のインデックスも表示するようにしてみましょう。変更後の出力は次のようになります。</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<!--
### See also:
-->
<h3 id="参照-4"><a class="header" href="#参照-4">参照</a></h3>
<!--
[`for`][for], [`ref`][ref], [`Result`][result], [`struct`][struct],
[`?`][q_mark], and [`vec!`][vec]
-->
<p><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="hello/print/print_display/../../../custom_types/structs.html">構造体</a>,
<a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, <a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Formatting
-->
<h1 id="フォーマット"><a class="header" href="#フォーマット">フォーマット</a></h1>
<!--
We've seen that formatting is specified via a *format string*:
-->
<p>これまで、文字列がどのようにフォーマットされるかは <em>フォーマット文字列</em> によって決まるということを見てきました 。</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<!--
The same variable (`foo`) can be formatted differently depending on which
*argument type* is used: `X` vs `o` vs *unspecified*.
-->
<p>ここでは(<code>foo</code>)という単一の変数が<code>X</code>、<code>o</code>、 <em>指定なし</em> 、という様々な <em>引数タイプ</em> (argument type)に応じてフォーマットされています。</p>
<!--
This formatting functionality is implemented via traits, and there is one trait
for each argument type. The most common formatting trait is `Display`, which
handles cases where the argument type is left unspecified: `{}` for instance.
-->
<p>フォーマットの機能はそれぞれの引数タイプごとに個別のトレイトを用いて実装されています。
最も一般的なトレイトは<code>Display</code>で、これは引数タイプが未指定（たとえば<code>{}</code>）の時に呼び出されます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // Latitude
    // 緯度
    lat: f32,
    // Longitude
    // 経度
    lon: f32,
}

impl Display for City {
    // `f` is a buffer, and this method must write the formatted string into it
    // `f` はバッファです。このメソッドは
    // ここにフォーマットされた文字列を書き込みます。
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` is like `format!`, but it will write the formatted string
        // into a buffer (the first argument)
        // `write!`は`format!`に似ていますが、フォーマットされた文字列を
        // バッファ（第一引数）に書き込みます。
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // Switch this to use {} once you've added an implementation
        // for fmt::Display.
        // fmt::Displayに実装を追加したら、 {} を使用するように変更してください。
        println!(&quot;{:?}&quot;, *color);
    }
}
</code></pre></pre>
<!--
You can view a [full list of formatting traits][fmt_traits] and their argument
types in the [`std::fmt`][fmt] documentation.
-->
<p>フォーマット用トレイトの全リスト、及び引数の型は<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">こちら</a>から、引数の型については<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code>のドキュメンテーション</a>から参照できます。</p>
<!--
### Activity
Add an implementation of the `fmt::Display` trait for the `Color` struct above
so that the output displays as:
-->
<h3 id="演習-4"><a class="header" href="#演習-4">演習</a></h3>
<p>上にあるソースコード中の<code>Color</code>という構造体のための<code>fmt::Display</code>トレイトの実装を追加しましょう。アウトプットは以下のように表示されるはずです。</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<!--
Two hints if you get stuck:
 * You [may need to list each color more than once][named_parameters],
 * You can [pad with zeros to a width of 2][fmt_width] with `:02`.
-->
<p>詰まったら以下の2つがヒントになります。</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/#named-parameters">それぞれの色を2回以上記述する必要があるかもしれません。</a></li>
<li><code>:02</code>で、<a href="https://doc.rust-lang.org/std/fmt/#width">幅を2に指定し、空白を0で埋める事ができます。</a></li>
</ul>
<!--
### See also:
-->
<h3 id="参照-5"><a class="header" href="#参照-5">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Primitives
-->
<h1 id="基本データ型"><a class="header" href="#基本データ型">基本データ型</a></h1>
<!--
Rust provides access to a wide variety of `primitives`. A sample includes:
-->
<p>Rustは様々な基本データ型(<code>primitives</code>)の使用をサポートしています。以下がその例です。</p>
<!--
### Scalar Types
-->
<h3 id="スカラー型"><a class="header" href="#スカラー型">スカラー型</a></h3>
<!--
* signed integers: `i8`, `i16`, `i32`, `i64`, `i128` and `isize` (pointer size)
* unsigned integers: `u8`, `u16`, `u32`, `u64`, `u128` and `usize` (pointer
  size)
* floating point: `f32`, `f64`
* `char` Unicode scalar values like `'a'`, `'α'` and `'∞'` (4 bytes each)
* `bool` either `true` or `false`
* and the unit type `()`, whose only possible value is an empty tuple: `()`
-->
<ul>
<li>符号付き整数: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>（ポインタのサイズ）</li>
<li>符号無し整数: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>（ポインタのサイズ）</li>
<li>浮動小数点数: <code>f32</code>, <code>f64</code></li>
<li><code>char</code>: <code>'a'</code>, <code>'α'</code>, <code>'∞'</code>などのUnicodeのスカラー値</li>
<li><code>bool</code>: <code>true</code>または<code>false</code></li>
<li>ユニット型: <code>()</code>が唯一の値</li>
</ul>
<!--
Despite the value of a unit type being a tuple, it is not considered a
compound type because it does not contain multiple values. 
-->
<p>ユニット型はその値がタプルですが、複合型とはみなされません。内部に複数の値を含んでいるわけではないからです。</p>
<!--
### Compound Types
-->
<h3 id="複合型"><a class="header" href="#複合型">複合型</a></h3>
<!--
* arrays like `[1, 2, 3]`
* tuples like `(1, true)`
-->
<ul>
<li>配列: e.g. <code>[1, 2, 3]</code>など</li>
<li>タプル: e.g. (1, true)</li>
</ul>
<!--
Variables can always be *type annotated*. Numbers may additionally be
annotated via a *suffix* or *by default*. Integers default to `i32` and
floats to `f64`. Note that Rust can also infer types from context.
-->
<p>変数は常に <em>型指定(<code>type annotate</code>)可能</em> です。数値型の場合はさらにサフィックスでの指定が可能です。指定しない場合デフォルトになります。例えば整数は<code>i32</code>が、浮動小数点は<code>f64</code>がデフォルトです。また、Rustは文脈から型を推定することもできます。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Variables can be type annotated.
    // 変数に型を指定
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Regular annotation
                             // 通常の型指定
    let an_integer   = 5i32; // Suffix annotation
                             // サフィックスによる型指定

    // Or a default will be used.
    // サフィックスを指定しない場合、デフォルトを選択
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // A type can also be inferred from context 
    // 型を文脈から推定することも可能
    let mut inferred_type = 12; // Type i64 is inferred from another line
                                // 型 i64 は次行の内容に基づいて推定
    inferred_type = 4294967296i64;
    
    // A mutable variable's value can be changed.
    // ミュータブルな変数は値を変更できる
    let mut mutable = 12; // Mutable `i32`
                          // ミュータブルな `i32`.
    mutable = 21;
    
    // Error! The type of a variable can't be changed.
    // エラー！ ミュータブルな変数でも型は不変
    mutable = true;
    
    // Variables can be overwritten with shadowing.
    // 変数はシャドーイングによって上書きできる
    let mutable = true;
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-6"><a class="header" href="#参照-6">参照</a></h3>
<!--
[the `std` library][std], [`mut`][mut], [inference], and [shadowing]
-->
<p><a href="https://doc.rust-lang.org/std/"><code>std</code> ライブラリ</a>, <a href="variable_bindings/mut.html"><code>mut</code></a>, <a href="types/inference.html">inference</a>, <a href="variable_bindings/scope.html">shadowing</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Literals and operators
-->
<h1 id="リテラルとオペレータ"><a class="header" href="#リテラルとオペレータ">リテラルとオペレータ</a></h1>
<!--
Integers `1`, floats `1.2`, characters `'a'`, strings `"abc"`, booleans `true`
and the unit type `()` can be expressed using literals.
-->
<p>整数<code>1</code>、浮動小数点<code>1.2</code>、文字(<code>char</code>)<code>'a'</code>、文字列<code>&quot;abc&quot;</code>、ブーリアン<code>true</code>、ユニット<code>()</code>は、リテラルを使用することで明示することが可能です。</p>
<!--
Integers can, alternatively, be expressed using hexadecimal, octal or binary
notation using these prefixes respectively: `0x`, `0o` or `0b`.
-->
<p>また整数型の場合、リテラルの代わりにプレフィックスに<code>0x</code>、<code>0o</code>、<code>0b</code>を指定することでそれぞれ16進数、8進数、2進数を使うことができます。</p>
<!--
Underscores can be inserted in numeric literals to improve readability, e.g.
`1_000` is the same as `1000`, and `0.000_001` is the same as `0.000001`.
-->
<p>可読性のため、<code>_</code>（アンダースコア）を数値リテラルの間に挿入することができます。例えば<code>1_000</code>は<code>1000</code>と、<code>0.000_001</code>は<code>0.000001</code>とそれぞれ同一です。</p>
<!--
We need to tell the compiler the type of the literals we use. For now,
we'll use the `u32` suffix to indicate that the literal is an unsigned 32-bit
integer, and the `i32` suffix to indicate that it's a signed 32-bit integer.
-->
<p>コンパイラに、どのリテラルを使用するのかを教えてあげなくてはなりません。現在の仕様では、リテラルが32ビット符号無し整数であることを伝える場合、<code>u32</code>サフィックスを、符号付き32ビット整数であれば<code>i32</code>を使用します。</p>
<!--
The operators available and their precedence [in Rust][rust op-prec] are similar to other
[C-like languages][op-prec].
-->
<p>Rustで使用可能な演算子と、<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">その実行順序</a>は、<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">Cなどの言語のもの</a>とほぼ同じです。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Integer addition
    // 整数の足し算
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // Integer subtraction
    // 整数の引き算
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important
    // TODO ^ 型が重要であることを実感するため`1i32`を`1u32`に変更してみましょう。

    // Short-circuiting boolean logic
    // 単純な論理演算子
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // Bitwise operations
    // ビットワイズ演算
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // Use underscores to improve readability!
    // 可読性のための`_`（アンダースコア）の使用
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Tuples
-->
<h1 id="タプル"><a class="header" href="#タプル">タプル</a></h1>
<!--
A tuple is a collection of values of different types. Tuples are constructed
using parentheses `()`, and each tuple itself is a value with type signature
`(T1, T2, ...)`, where `T1`, `T2` are the types of its members. Functions can
use tuples to return multiple values, as tuples can hold any number of values.
-->
<p>タプルは異なる型の値の集合です。括弧<code>()</code>を用いて生成します。タプル自体がそのメンバに対する型シグネチャを保持していますので、明示すると<code>(T1, T2, ...)</code>のようになります。タプルは大きさに制限がありませんので、関数が複数の値を返したい時に使われます。</p>
<pre><pre class="playground"><code class="language-rust editable">// Tuples can be used as function arguments and as return values
// タプルを関数の引数及び返り値として使用している。
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` can be used to bind the members of a tuple to variables
    // `let`でタプルの中の値を別の変数に束縛することができる。
    let (integer, boolean) = pair;

    (boolean, integer)
}

// The following struct is for the activity.
// 以下の構造体は後ほど「演習」で用いる。
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // A tuple with a bunch of different types
    // 様々な型を値に持つタプル
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // Values can be extracted from the tuple using tuple indexing
    // インデックスを用いて、タプル内の要素を参照できる。
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

    // Tuples can be tuple members
    // タプルはタプルのメンバになれる
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Tuples are printable
    // タプルはプリント可能である。
    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);
    
    // But long Tuples cannot be printed
    // しかし長すぎるタプルはプリントできない
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
    // TODO ^ Uncomment the above 2 lines to see the compiler error
    // TODO ^ 上記2行のコメントを外して、コンパイルエラーになることを確認

    let pair = (1, true);
    println!(&quot;pair is {:?}&quot;, pair);

    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // To create one element tuples, the comma is required to tell them apart
    // from a literal surrounded by parentheses
    // 要素を1つしか持たないタプルを作成する場合、括弧で囲まれたただのリテラル
    // と区別するため、カンマが必要になる。
    println!(&quot;one element tuple: {:?}&quot;, (5u32,));
    println!(&quot;just an integer: {:?}&quot;, (5u32));

    //tuples can be destructured to create bindings
    //タプルを分解して別の変数にそれぞれの値を代入
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}
</code></pre></pre>
<!--
### Activity
-->
<h3 id="演習-5"><a class="header" href="#演習-5">演習</a></h3>
<!--
 1. *Recap*: Add the `fmt::Display` trait to the Matrix `struct` in the above example,
    so that if you switch from printing the debug format `{:?}` to the display
    format `{}`, you see the following output:
-->
<ol>
<li>
<p><em>復習</em> : 上にある<code>Matrix</code>という構造体に、<code>fmt::Display</code>トレイトを追加しましょう。デバッグフォーマット<code>{:?}</code>ではなくディスプレイフォーマット<code>{}</code>でプリントすることができるようになるはずです。</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<!--
You may want to refer back to the example for [print display][print_display].
-->
</li>
</ol>
<p>必要に応じて<a href="primitives/../hello/print/print_display.html">print displayのページ</a>に戻る必要があるかもしれません。</p>
<!--
 2. Add a `transpose` function using the `reverse` function as a template, which
    accepts a matrix as an argument, and returns a matrix in which two elements
    have been swapped. For example:
-->
<ol start="2">
<li>
<p><code>reverse</code>関数を雛形にした<code>transpose</code>関数を実装してください。この関数は<code>Matrix</code>を引数として受け取り、要素のうち2つを入れ替えたものを返します。つまり</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<!--
results in the output:
-->
<p>は以下の様な出力になります:</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
# Arrays and Slices
-->
<h1 id="配列とスライス"><a class="header" href="#配列とスライス">配列とスライス</a></h1>
<!--
An array is a collection of objects of the same type `T`, stored in contiguous
memory. Arrays are created using brackets `[]`, and their size, which is known
at compile time, is part of their type signature `[T; size]`.
-->
<p>配列は<code>T</code>という単一の型（訳注: <a href="https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/generics.html">ジェネリック型</a>でも可）のオブジェクトの集合です。それらのオブジェクトはメモリ上の連続した領域に保存されます。配列は<code>[]</code>を用いて生成されます。サイズはコンパイル時には決定されていて、<code>[T; size]</code>という形で指定できます。</p>
<!--
Slices are similar to arrays, but their size is not known at compile time.
Instead, a slice is a two-word object, the first word is a pointer to the data,
and the second word is the length of the slice. The word size is the same as 
usize, determined by the processor architecture eg 64 bits on an x86-64. 
Slices can be used to borrow a section of an array, and have the type signature 
`&[T]`.
-->
<p>スライスは配列に似ていますが、コンパイル時にサイズが決定されていません。スライスは2ワードからなるオブジェクトであり、最初のワードがデータへのポインタ、2番目のワードがスライスの長さです。ワード長は<code>usize</code>と同一で、プロセッサのアーキテクチャによって決まります。例えばx86-64では64ビットです。スライスは配列の一部を借用するのに使用され、<code>&amp;[T]</code>という型シグネチャを持ちます。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// This function borrows a slice
// この関数はスライスを借用する
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    // Fixed-size array (type signature is superfluous)
    // 固定長の配列（型シグネチャは冗長なので、なくても可）
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // All elements can be initialized to the same value
    // すべての要素を0にする場合
    let ys: [i32; 500] = [0; 500];

    // Indexing starts at 0
    // インデックスは０から
    println!(&quot;first element of the array: {}&quot;, xs[0]);
    println!(&quot;second element of the array: {}&quot;, xs[1]);

    // `len` returns the size of the array
    // `len`は配列のサイズを返す。
    println!(&quot;array size: {}&quot;, xs.len());

    // Arrays are stack allocated
    // 配列はスタック上に置かれる
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // Arrays can be automatically borrowed as slices
    // 配列は自動的にスライスとして借用される。
    println!(&quot;borrow the whole array as a slice&quot;);
    analyze_slice(&amp;xs);

    // Slices can point to a section of an array
    // They are of the form [starting_index..ending_index]
    // starting_index is the first position in the slice
    // ending_index is one more than the last position in the slice
    // スライスは配列の一部を指すことができる。
    // [starting_index..ending_index] の形をとり、
    // starting_index はスライスの先頭の位置を表し、
    // ending_index はスライスの末尾の1つ先の位置を表す。
    println!(&quot;borrow a section of the array as a slice&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // Out of bound indexing causes compile error
    // インデックスが範囲外のときはコンパイルエラー
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Custom Types
-->
<h1 id="カスタム型"><a class="header" href="#カスタム型">カスタム型</a></h1>
<!--
Rust custom data types are formed mainly through the two keywords:
-->
<p>Rustでのカスタムデータ型の作成は主に以下の2つのキーワードを介して行われます。</p>
<!--
* `struct`: define a structure
* `enum`: define an enumeration
-->
<ul>
<li><code>struct</code>: 構造体を定義する</li>
<li><code>enum</code>: 列挙型を定義する</li>
</ul>
<!--
Constants can also be created via the `const` and `static` keywords.
-->
<p><code>const</code>、あるいは<code>static</code>というキーワードによって定数を定義することもできます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Structures
-->
<h1 id="構造体"><a class="header" href="#構造体">構造体</a></h1>
<!--
There are three types of structures ("structs") that can be created using the
`struct` keyword:
-->
<p><code>struct</code>というキーワードを用いて作成できる構造体には3種類あります。</p>
<!--
* Tuple structs, which are, basically, named tuples.
* The classic [C structs][c_struct]
* Unit structs, which are field-less, are useful for generics.
-->
<ul>
<li>タプル。（すなわちタプルに名前が付いたようなもの）</li>
<li>クラシックな<a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C言語スタイルの構造体。</a></li>
<li>ユニット。これはフィールドを持たず、ジェネリック型を扱う際に有効です。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    // The 'a defines a lifetime
    name: &amp;'a str,
    age: u8,
}

// A unit struct
// ユニット
struct Nil;

// A tuple struct
// タプル
struct Pair(i32, f32);

// A struct with two fields
// 2つのフィールドを持つ（クラシックな）構造体
struct Point {
    x: f32,
    y: f32,
}

// Structs can be reused as fields of another struct
// 構造体は他の構造体のフィールドになることができる
#[allow(dead_code)]
struct Rectangle {
    // A rectangle can be specified by where the top left and bottom right
    // corners are in space.
    // 長方形は座標空間上における左上隅と右下隅の位置によって指定できる
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // Create struct with field init shorthand
    // 構造体をフィールド初期化の簡略記法で生成
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    // 構造体のデバッグ表示を行う
    println!(&quot;{:?}&quot;, peter);


    // Instantiate a `Point`
    // `Point` のインスタンス化
    let point: Point = Point { x: 10.3, y: 0.4 };

    // Access the fields of the point
    // pointのフィールドにアクセスする。
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our
    // other one
    // 構造体の更新記法を用いて、別の構造体のフィールドの値を基に
    // 新たなpointを生成
    let bottom_right = Point { x: 5.2, ..point };

    // `bottom_right.y` will be the same as `point.y` because we used that field
    // from `point`
    // `bottom_right.y` の値は `point.y` と同一になるが、
    // これは `point` のフィールドの値を用いて生成したためである
    println!(&quot;second point: ({}, {})&quot;, bottom_right.x, bottom_right.y);

    // Destructure the point using a `let` binding
    // `let`を使用してpointをデストラクトする。
    let Point { x: top_edge, y: left_edge } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        // 構造体の定義とインスタンスの作成を同時に行う
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // Instantiate a unit struct
    // ユニットをインスタンス化
    let _nil = Nil;

    // Instantiate a tuple struct
    // タプルをインスタンス化
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    // タプルのフィールドにアクセス
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // Destructure a tuple struct
    // タプルをデストラクト
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<!--
### Activity
-->
<h3 id="演習-6"><a class="header" href="#演習-6">演習</a></h3>
<!--
1. Add a function `rect_area` which calculates the area of a rectangle (try
   using nested destructuring).
2. Add a function `square` which takes a `Point` and a `f32` as arguments, and returns a `Rectangle` with its lower left corner on the point, and a width and height corresponding to the `f32`.
-->
<ol>
<li><code>Rectangle</code> の面積を計算する <code>rect_area</code> 関数を追加してください。ネストしたデストラクトを使ってみましょう。</li>
<li><code>Point</code> と <code>f32</code> を引数とした時に <code>Rectangle</code> を返す <code>square</code> 関数を追加してください。 <code>Rectangle</code> の左下の点が <code>Point</code> になり、<code>f32</code> が <code>Rectangle</code> の幅と高さになります。</li>
</ol>
<!--
### See also:
-->
<h3 id="参照-7"><a class="header" href="#参照-7">参照</a></h3>
<!--
[`attributes`][attributes], [lifetime][lifetime] and [destructuring][destructuring]
-->
<p><a href="custom_types/../attribute.html">アトリビュート(<code>attributes</code>)</a>, <a href="custom_types/../scope/lifetime.html">lifetime</a>, <a href="custom_types/../flow_control/match/destructuring.html">デストラクト</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Enums
-->
<h1 id="列挙型"><a class="header" href="#列挙型">列挙型</a></h1>
<!--
The `enum` keyword allows the creation of a type which may be one of a few
different variants. Any variant which is valid as a `struct` is also valid as
an `enum`.
-->
<p>列挙型(<code>enum</code>)はいくつかの異なる要素型の中から1つを選ぶような場合に使用します。構造体(<code>struct</code>)の定義を満たすものならば何でも<code>enum</code> の要素型として使用できます。</p>
<pre><pre class="playground"><code class="language-rust editable">// Create an `enum` to classify a web event. Note how both
// names and type information together specify the variant:
// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.
// Each is different and independent.
// `enum`を作成してwebイベントを分類する。
// 名前と型情報を併せたものが要素型になっていることに注意。
// `PageLoad != PageUnload` であり、
// `KeyPress(char) != Paste(String)` である。
// 要素型は互いに異なり、互いに非依存である。
enum WebEvent {
    // An `enum` may either be `unit-like`,
    // `enum`要素型はユニット風でもよい
    PageLoad,
    PageUnload,
    // like tuple structs,
    // タプル風でもよい
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    // C言語スタイルの構造体風でもよい
    Click { x: i64, y: i64 },
}

// A function which takes a `WebEvent` enum as an argument and
// returns nothing.
// 引数として`WebEvent`列挙型をとり、何も返さない関数
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // Destructure `c` from inside the `enum`.
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    // `to_owned()`は文字列スライスから所有権のある`String`を作成する
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}

</code></pre></pre>
<!--
## Type aliases
-->
<h2 id="型エイリアス"><a class="header" href="#型エイリアス">型エイリアス</a></h2>
<!--
If you use a type alias, you can refer to each enum variant via its alias.
This might be useful if the enum's name is too long or too generic, and you
want to rename it.
-->
<p>型エイリアスを用いると、列挙型の要素型を別名で参照できます。これは列挙型の名前があまりに長かったり、あまりに一般的だったりで改名したい場合に役立ちます。</p>
<pre><pre class="playground"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// Creates a type alias
// 型エイリアスを作成する
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // We can refer to each variant via its alias, not its long and inconvenient
    // name.
    // 長くて不便な列挙型の名前ではなく、別名を使って要素型を参照できる
    let x = Operations::Add;
}
</code></pre></pre>
<!--
The most common place you'll see this is in `impl` blocks using the `Self` alias.
-->
<p>このやり方がもっともよく見られるのは、<code>impl</code>ブロックで<code>Self</code>という別名を使用する場合です。</p>
<pre><pre class="playground"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}
</code></pre></pre>
<!--
To learn more about enums and type aliases, you can read the
[stabilization report][aliasreport] from when this feature was stabilized into
Rust.
-->
<p>列挙型や型エイリアスについて詳しく学びたい人は、この機能が安定してRustに取り込まれた後に<a href="https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847">stabilization report</a>を読んでください。</p>
<!--
### See also:
-->
<h3 id="参照-8"><a class="header" href="#参照-8">参照</a></h3>
<!--
[`match`][match], [`fn`][fn], and [`String`][str], ["Type alias enum variants" RFC][type_alias_rfc]
-->
<p><a href="custom_types/../flow_control/match.html">マッチ(<code>match</code>)</a>, <a href="custom_types/../fn.html">関数(<code>fn</code>)</a>, <a href="custom_types/../std/str.html">文字列(<code>String</code>)</a>, <a href="https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html">&quot;Type alias enum variants&quot; RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">use</a></h1>
<!--
The `use` declaration can be used so manual scoping isn't needed:
-->
<p><code>use</code>を使用すれば変数のスコープを絶対名で指定する必要がなくなる。</p>
<pre><pre class="playground"><code class="language-rust editable">// An attribute to hide warnings for unused code.
// 使用されていないコードよる警告を隠すアトリビュート
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // Explicitly `use` each name so they are available without
    // `use`することで絶対名でなくとも使用可能になる。
    // manual scoping.
    use crate::Status::{Poor, Rich};
    // Automatically `use` each name inside `Work`.
    // `Work`の中の名前をすべて`use`する
    use crate::Work::*;

    // Equivalent to `Status::Poor`.
    // `use`しているため、`Status::Poor`と書いていることに等しい
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    // `Work::Civilian`に等しい
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        // `use`しているのでスコープを明示していない
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),
        Poor =&gt; println!(&quot;The poor have no money...&quot;),
    }

    match work {
        // Note again the lack of scoping.
        // こちらも同じ
        Civilian =&gt; println!(&quot;Civilians work!&quot;),
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-9"><a class="header" href="#参照-9">参照</a></h3>
<!--
[`match`][match] and [`use`][use] 
-->
<p><a href="custom_types/enum/../../flow_control/match.html">マッチ(<code>match</code>)</a>, <a href="custom_types/enum/../../mod/use.html"><code>use</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# C-like
-->
<h1 id="c言語ライクな列挙型"><a class="header" href="#c言語ライクな列挙型">C言語ライクな列挙型</a></h1>
<!--
`enum` can also be used as C-like enums.
-->
<p>列挙型はC言語の列挙型のような使い方をする事もできます。</p>
<pre><pre class="playground"><code class="language-rust editable">// An attribute to hide warnings for unused code.
// 使用されていないコードによる警告を抑えるアトリビュート
#![allow(dead_code)]

// enum with implicit discriminator (starts at 0)
// 値を明示しない場合、0から整数が順に入る。
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
// 値を明示する場合
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    // 列挙型の中身を整数としてキャストする。
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-10"><a class="header" href="#参照-10">参照</a></h3>
<!--
[casting][cast]
-->
<p><a href="custom_types/enum/../../types/cast.html">キャスティング</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Testcase: linked-list
-->
<h1 id="テストケース-連結リスト"><a class="header" href="#テストケース-連結リスト">テストケース: 連結リスト</a></h1>
<!--
A common use for `enums` is to create a linked-list:
-->
<p><code>enum</code>を使用が適切なパターンのひとつに、連結リスト(<code>linked-list</code>)を作成する場合があります。</p>
<pre><pre class="playground"><code class="language-rust editable">use crate::List::*;

enum List {
    // Cons: Tuple struct that wraps an element and a pointer to the next node
    // Cons: これは、要素をラップし、次の要素へのポインタを保持するタプル。
    Cons(u32, Box&lt;List&gt;),
    // Nil: A node that signifies the end of the linked list
    // Nil: 連結リストの終端であることを示すノード
    Nil,
}

// Methods can be attached to an enum
// 列挙型にはメソッドを付与することができる。
impl List {
    // Create an empty list
    // 空リストの作成。
    fn new() -&gt; List {
        // `Nil` has type `List`
        // `Nil` は `List`型を持つ。
        Nil
    }

    // Consume a list, and return the same list with a new element at its front
    // リストを受け取り、その始端に新しい要素を付加したものを返す関数。
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` also has type List
        // この`Cons` 自体も、その第2要素もどちらもlist型である。
        Cons(elem, Box::new(self))
    }

    // Return the length of the list
    // list の長さを返すメソッド
    fn len(&amp;self) -&gt; u32 {
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&amp;T`
        // このメソッドは、`self`の状態によって振る舞いが
        // 変化するため、matchをする必要がある。
        // `self`の型は`&amp;List`であるので、`*self`は`List`になる。マッチングは
        // リファレンス(`&amp;T`)ではなく実体(`T`)に対して行うのが好ましい。
        match *self {
            // Can't take ownership of the tail, because `self` is borrowed;
            // instead take a reference to the tail
            // `self`をすでに借用しているので、tailの所有権を取ることができない。
            // 代わりに参照を使用する。
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Base Case: An empty list has zero length
            // 空リストならば長さは0
            Nil =&gt; 0
        }
    }

    // Return representation of the list as a (heap allocated) string
    // Listをheap上の文字列として表したものを返すメソッド。
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the console
                // `format!`は`print!`に似ているが、コンソール上に出力
                // する代わりに、heap上の文字列を返す。
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Create an empty linked list
    // 空の連結リストを作成
    let mut list = List::new();

    // Prepend some elements
    // 要素を追加
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    // 追加後の状態を表示
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-11"><a class="header" href="#参照-11">参照</a></h3>
<!--
[`Box`][box] and [methods][methods]
-->
<p><a href="custom_types/enum/../../std/box.html">ボックス(<code>Box</code>)</a>, <a href="custom_types/enum/../../fn/methods.html">メソッド</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# constants
-->
<h1 id="定数"><a class="header" href="#定数">定数</a></h1>
<!--
Rust has two different types of constants which can be declared in any scope
including global. Both require explicit type annotation:
-->
<p>Rustには2種類の定数があり、いずれもグローバルスコープを含む任意のスコープで宣言することができます。また、いずれも型を明示しなくてはなりません。</p>
<!--
* `const`: An unchangeable value (the common case).
* `static`: A possibly `mut`able variable with [`'static`][static] lifetime.
  The static lifetime is inferred and does not have to be specified.
  Accessing or modifying a mutable static variable is [`unsafe`][unsafe].
-->
<ul>
<li><code>const</code>: 不変の値（通常はこちらを使用する）</li>
<li><code>static</code>: <a href="custom_types/../scope/lifetime/static_lifetime.html">スタティックな</a>ライフタイムを持つミュータブル(<code>mut</code>)な値
The static lifetime is inferred and does not have to be specified.
Accessing or modifying a mutable static variable is <a href="custom_types/../unsafe.html"><code>unsafe</code></a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// Globals are declared outside all other scopes.
// グローバル変数はあらゆるスコープの外で宣言します
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // Access constant in some function
    // 関数内から定数を参照
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // Access constant in the main thread
    // main 関数の中から定数を参照
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // Error! Cannot modify a `const`.
    // エラー!`const`は変更できません。
    THRESHOLD = 5;
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-12"><a class="header" href="#参照-12">参照</a></h3>
<!--
[The `const`/`static` RFC](
https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md),
[`'static` lifetime][static]
-->
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md"><code>const</code> 及び <code>static</code> の RFC</a>,
<a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code> ライフタイム</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Variable Bindings
-->
<h1 id="変数束縛"><a class="header" href="#変数束縛">変数束縛</a></h1>
<!--
Rust provides type safety via static typing. Variable bindings can be type
annotated when declared. However, in most cases, the compiler will be able
to infer the type of the variable from the context, heavily reducing the
annotation burden.
-->
<p>Rustは静的(<code>static</code>)な型付けゆえに型安全です。変数束縛は宣言時に型を指定できます。とはいえたいていの場合は、コンパイラは変数の型をコンテキストから推測することができますので、型指定の負担を大幅に軽減できます。</p>
<!--
Values (like literals) can be bound to variables, using the `let` binding.
-->
<p>値（リテラルなど）は<code>let</code>を用いて変数に束縛することができます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // copy `an_integer` into `copied_integer`
    // `an_integer`を`copied_integer`へとコピー
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // The compiler warns about unused variable bindings; these warnings can
    // be silenced by prefixing the variable name with an underscore
    // 使用されていない変数があると、コンパイラは警告を出します。
    // 変数名の頭に`_`（アンダーバー）を付けると警告を消すことができます。
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // FIXME ^ Prefix with an underscore to suppress the warning
    // FIXME ^ 頭にアンダーバーを付けて、警告を抑えましょう。
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Mutability
-->
<h1 id="ミュータビリティ"><a class="header" href="#ミュータビリティ">ミュータビリティ</a></h1>
<!--
Variable bindings are immutable by default, but this can be overridden using
the `mut` modifier.
-->
<p>変数はデフォルトでイミュータブル（変更不可能）ですが<code>mut</code>構文を使用することでミュータブルになります。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding);

    // Ok
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding);

    // Error!
    _immutable_binding += 1;
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう
}
</code></pre></pre>
<!--
The compiler will throw a detailed diagnostic about mutability errors.
-->
<p>コンパイラはミュータビリティに関するエラーの詳細を出してくれます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Scope and Shadowing
-->
<h1 id="スコープとシャドーイング"><a class="header" href="#スコープとシャドーイング">スコープとシャドーイング</a></h1>
<!--
Variable bindings have a scope, and are constrained to live in a *block*. A
block is a collection of statements enclosed by braces `{}`. Also, [variable
shadowing][variable-shadow] is allowed.
-->
<p>変数はスコープを持つため、 <strong>ブロック</strong> の中に閉じ込められています。ブロックとは<code>{}</code>で囲まれた領域のことです。また、<a href="https://en.wikipedia.org/wiki/Variable_shadowing">変数のシャドーイング</a>も可能です。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // This binding lives in the main function
    // この変数はmain関数内が生息域です。
    let long_lived_binding = 1;

    // This is a block, and has a smaller scope than the main function
    // ここから下が`main`より小さいスコープを持つブロックとなります。
    {
        // This binding only exists in this block
        // この変数はこのブロック内のみに存在します。
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // This binding *shadows* the outer one
        // この変数はスコープ外の同名の変数を *シャドーイング* します。
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // End of the block
    // ブロックの終わり

    // Error! `short_lived_binding` doesn't exist in this scope
    // `short_lived_binding`はこのスコープ内には存在しませんのでエラーとなります。
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // FIXME ^ Comment out this line
    // FIXME ^ コメントアウトしましょう

    println!(&quot;outer long: {}&quot;, long_lived_binding);
    
    // This binding also *shadows* the previous binding
    // この変数バインディングも以前に定義した変数を *シャドーイング* します
    let long_lived_binding = 'a';
    
    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Declare first
-->
<h1 id="宣言"><a class="header" href="#宣言">宣言</a></h1>
<!--
It's possible to declare variable bindings first, and initialize them later.
However, this form is seldom used, as it may lead to the use of uninitialized
variables.
-->
<p>変数の宣言だけを行っておき、初期化（定義）をのちに行うことも可能です。
しかし、最後まで初期化されない変数が生じる可能性があるため、ふつうは同時に行われます。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Declare a variable binding
    // 変数を宣言
    let a_binding;

    {
        let x = 2;

        // Initialize the binding
        // 変数を初期化
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // Error! Use of uninitialized binding
    // エラー！ 初期化していない変数の使用
    println!(&quot;another binding: {}&quot;, another_binding);
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう。

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<!--
The compiler forbids use of uninitialized variables, as this would lead to
undefined behavior.
-->
<p>未初期化の変数があると予期せぬ動作をする場合があるため、コンパイラは変数を初期化してから使用するよう強制します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Freezing
-->
<h1 id="値の凍結"><a class="header" href="#値の凍結">値の凍結</a></h1>
<!--
When data is bound by the same name immutably, it also *freezes*. *Frozen* data can't be 
modified until the immutable binding goes out of scope:
-->
<p>データを同じ名前のイミュータブルな変数に束縛しなおすと、データは<em>凍結</em>されます。<em>凍結</em>したデータは、イミュータブルな束縛がスコープ外になるまで変更できません。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // Shadowing by immutable `_mutable_integer`
        // イミュータブルな`_mutable_integer`でシャドーイングする
        let _mutable_integer = _mutable_integer;

        // Error! `_mutable_integer` is frozen in this scope
        // エラー! `_mutable_integer`はこのスコープでは凍結している。
        _mutable_integer = 50;
        // FIXME ^ Comment out this line
        // FIXME ^ この行をコメントアウトしましょう。

        // `_mutable_integer` goes out of scope
        // `_mutable_integer`はスコープを抜ける
    }

    // Ok! `_mutable_integer` is not frozen in this scope
    // OK! `_mutable_integer`はこのスコープでは凍結していない。
    _mutable_integer = 3;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Types
-->
<h1 id="型"><a class="header" href="#型">型</a></h1>
<!--
Rust provides several mechanisms to change or define the type of primitive and
user defined types. The following sections cover:
-->
<p>Rustには、プリミティブ型やユーザ定義型を定義したり変換したりする様々な方法があります。
この章は以下の内容を扱います:</p>
<!--
* [Casting] between primitive types
* Specifying the desired type of [literals]
* Using [type inference]
* [Aliasing] types
	-->
<ul>
<li>プリミティブ型の間で<a href="types/cast.html">キャスティング</a>を行う</li>
<li><a href="types/literals.html">リテラル</a>の型をどれにしたいか指定する</li>
<li><a href="types/inference.html">型推論</a>を使う</li>
<li>型を<a href="types/alias.html">エイリアス</a>する</li>
</ul>
<!--
[Casting]: types/cast.md
[literals]: types/literals.md
[type inference]: types/inference.md
[Aliasing]: types/alias.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Casting
-->
<h1 id="型キャスティング"><a class="header" href="#型キャスティング">型キャスティング</a></h1>
<!--
Rust provides no implicit type conversion (coercion) between primitive types.
But, explicit type conversion (casting) can be performed using the `as` keyword.
-->
<p>Rustはプリミティブ型における強制的な型変換を暗黙に行うことはありません。しかし明示的に行うこと(<code>casting</code>)は可能です。その場合<code>as</code>キーワードを使用します。</p>
<!--
Rules for converting between integral types follow C conventions generally,
except in cases where C has undefined behavior. The behavior of all casts
between integral types is well defined in Rust.
-->
<p>整数型から整数型へ型変換する場合、C言語で可能なケースの場合はC言語と同じです。
C言語で未定義の場合の挙動も、Rustでは完全に定義されています。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// Suppress all warnings from casts which overflow.
// オーバーフローを起こすようなキャスティングによる警告を無視する。
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Error! No implicit conversion
    // エラー！ 暗黙的な型変換はできない。
    let integer: u8 = decimal;
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう。

    // Explicit conversion
    // 明示的な型変換
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // when casting any value to an unsigned type, T,
    // std::T::MAX + 1 is added or subtracted until the value
    // fits into the new type
    // 何らかの値を符号なしの型（仮にTとする）へキャスティングすると
    // 値がTに収まるまで、std::T::MAX + 1 が加算あるいは減算される。

    // 1000 already fits in a u16
    // 1000 はすでにu16に収まっているため変化しない。
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Under the hood, the first 8 least significant bits (LSB) are kept,
    // while the rest towards the most significant bit (MSB) get truncated.
    // 水面下では最下位ビットから8bitが使用され、残りの上位ビットが圧縮される形になる。
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // For positive numbers, this is the same as the modulus
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // When casting to a signed type, the (bitwise) result is the same as
    // first casting to the corresponding unsigned type. If the most significant
    // bit of that value is 1, then the value is negative.
    // 符号付きの型にキャストする場合、結果は以下の2つを行った場合に等しい
    // 1. 対応する符号なしの型にキャストする。
    // 2. 2の補数(two's complement)をとる

    // Unless it already fits, of course.
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128, whose two's complement in eight bits is:
    // 128をu8にキャストすると128となる。128の8ビットにおける補数は -128
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // repeating the example above
    // 上で示した例から
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // and the two's complement of 232 is -24
    // が成り立つ。232の8ビットにおける補数は -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Literals
-->
<h1 id="リテラル"><a class="header" href="#リテラル">リテラル</a></h1>
<!--
Numeric literals can be type annotated by adding the type as a suffix. As an example, 
to specify that the literal `42` should have the type `i32`, write `42i32`.
-->
<p>数値型リテラルはサフィックスにより型を指定することが可能です。例えば、<code>42</code>というリテラルに対して<code>i32</code>型を指定するには<code>42i32</code>とします。</p>
<!--
The type of unsuffixed numeric literals will depend on how they are used. If no
constraint exists, the compiler will use `i32` for integers, and `f64` for
floating-point numbers.
-->
<p>サフィックスを指定しない数値型リテラルの場合、その型はどのように使用されるかに依存して決められます。デフォルトでは整数型の場合<code>i32</code>が、浮動小数点型は<code>f64</code>を使用します。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Suffixed literals, their types are known at initialization
    // サフィックスを指定したリテラル。型は初期化とともに確定する。
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Unsuffixed literal, their types depend on how they are used
    // サフィックスを指定しないリテラル。型は使用方法に依存する。
    let i = 1;
    let f = 1.0;

    // `size_of_val` returns the size of a variable in bytes
    // `size_of_val` 関数は変数のサイズをバイトで返す。
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<!--
There are some concepts used in the previous code that haven't been explained
yet, here's a brief explanation for the impatient readers:
-->
<p>上のコードには現時点では解説していない考えがいくつか使用されています。気になる方のために簡単に説明をしておきましょう。</p>
<!--
* `fun(&foo)` is used to pass an argument to a function *by reference*, rather
  than by value (`fun(foo)`). For more details see [borrowing][borrow].
* `std::mem::size_of_val` is a function, but called with its *full path*. Code
  can be split in logical units called *modules*. In this case, the
  `size_of_val` function is defined in the `mem` module, and the `mem` module
  is defined in the `std` *crate*. For more details, see
  [modules][mod] and [crates][crate].
-->
<ul>
<li><code>fun(&amp;foo)</code>は値そのものではなく、その参照を関数に渡す時の書き方です。詳しくは<a href="types/../scope/borrow.html">借用(<code>borrowing</code>)</a>を見てください。</li>
<li><code>std::mem::size_of_val</code>は関数ですが、 <em>絶対パス(<code>full path</code>)</em> で呼び出されています。ソースコードは論理的に区切られた <em>モジュール</em> と呼ばれるものにわけられることができます。今回の場合は<code>size_of_val</code>関数は<code>mem</code>モジュール内で定義されており、<code>mem</code>モジュールは<code>std</code> <em>クレート</em> 内で定義されています。より詳しくは<a href="types/../crates.html">クレート(<code>crates</code>)</a>を参照してください。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# Inference
-->
<h1 id="型推論"><a class="header" href="#型推論">型推論</a></h1>
<!--
The type inference engine is pretty smart. It does more than looking at the
type of the value expression
during an initialization. It also looks at how the variable is used afterwards 
to infer its type. Here's an advanced example of type inference:
-->
<p>Rustの型推論エンジンはなかなか賢くできています。初期化の際に評価値の型をチェックするだけでなく、その後にどのような使われ方をしているかを見て推論します。以下がその例です。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Because of the annotation, the compiler knows that `elem` has type u8.
    // アノテーションのおかげで、コンパイラは`elem`がu8型であることがわかる。
    let elem = 5u8;

    // Create an empty vector (a growable array).
    // 空のベクトル（可変長の配列）を生成
    let mut vec = Vec::new();
    // At this point the compiler doesn't know the exact type of `vec`, it
    // just knows that it's a vector of something (`Vec&lt;_&gt;`).
    // この時点でコンパイラは`vec`の型を知らず、
    // 単に何らかの値のベクトル(`Vec&lt;_&gt;`)であるということだけを把握している。

    // Insert `elem` in the vector.
    // `elem`をベクトルに挿入
    vec.push(elem);
    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec&lt;u8&gt;`)
    // TODO ^ Try commenting out the `vec.push(elem)` line
    // よし！ これでコンパイラは`vec`が`u8`のベクトル(`Vec&lt;u8&gt;`)であることを把握する。
    // TODO ^ 上の `vec.push(elem)` をコメントアウトしてみましょう。

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<!--
No type annotation of variables was needed, the compiler is happy and so is the
programmer!
-->
<p>このように、変数の型アノテーションは必要ありません。これでコンパイラもプログラマもハッピーですね！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Aliasing
-->
<h1 id="エイリアス"><a class="header" href="#エイリアス">エイリアス</a></h1>
<!--
The `type` statement can be used to give a new name to an existing type. Types
must have `UpperCamelCase` names, or the compiler will raise a warning. The
exception to this rule are the primitive types: `usize`, `f32`, etc.
-->
<p><code>type</code>文を使用することで既存の型に新しい名前(<code>alias</code>)を付けることができます。その場合、名前は<code>UpperCamelCase</code>でなくてはなりません。さもなくばコンパイラがエラーを出します。唯一の例外は<code>usize</code>や<code>f32</code>のようなプリミティブ型です。</p>
<pre><pre class="playground"><code class="language-rust editable">// `NanoSecond` is a new name for `u64`.
// `NanoSecond` を `u64`の別名として使用する。
type NanoSecond = u64;
type Inch = u64;

// Use an attribute to silence warning.
// 警告を抑えるアトリビュートを使用。
#[allow(non_camel_case_types)]
type u64_t = u64;
// TODO ^ Try removing the attribute
// TODO ^ アトリビュートを使用しない場合、どうなるか見てみましょう。

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // Note that type aliases *don't* provide any extra type safety, because
    // aliases are *not* new types
    // 型のエイリアスは、元の型をより型安全にしてくれる **わけではない** ことに注意しましょう。
    // なぜならば、エイリアスは新たな型を定義している **わけではない** からです。
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<!--
The main use of aliases is to reduce boilerplate; for example the `IoResult<T>` type
is an alias for the `Result<T, IoError>` type.
-->
<p>このようにエイリアスを付ける一番の理由はボイラープレートを減らすことです。例えば<code>IoResult&lt;T&gt;</code>型は<code>Result&lt;T, IoError&gt;</code>の別名です。</p>
<!--
### See also:
-->
<h3 id="参照-13"><a class="header" href="#参照-13">参照</a></h3>
<!--
[Attributes](../attribute.md)
-->
<p><a href="types/../attribute.html">アトリビュート</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Conversion
-->
<h1 id="型変換"><a class="header" href="#型変換">型変換</a></h1>
<!--
Rust addresses conversion between types by the use of [traits]. The generic
conversions will use the [`From`] and [`Into`] traits. However there are more
specific ones for the more common cases, in particular when converting to and
from `String`s.
-->
<p>Rustは型の変換を<a href="trait.html">トレイト</a>を用いて行います。ジェネリックな型変換には<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>および<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトを使用します。しかし、よくあるケースにおいて、特に<code>String</code>との相互の型変換では、特殊なトレイトが使用されます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# `From` and `Into`
-->
<h1 id="fromおよびinto"><a class="header" href="#fromおよびinto"><code>From</code>および<code>Into</code></a></h1>
<!--
The [`From`] and [`Into`] traits are inherently linked, and this is actually part of
its implementation. If you are able to convert type A from type B, then it
should be easy to believe that we should be able to convert type B to type A.
-->
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトと<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトは本質的に結びついており、そのことが実際に実装に反映されています。もし型Aから型Bへの変換ができるのであれば、型Bから型Aへの変換もできると思うのが自然です。</p>
<h2 id="from"><a class="header" href="#from"><code>From</code></a></h2>
<!--
The [`From`] trait allows for a type to define how to create itself from another
type, hence providing a very simple mechanism for converting between several
types. There are numerous implementations of this trait within the standard
library for conversion of primitive and common types.
-->
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトは、ある型に対し、別の型からその型を作る方法を定義できるようにするものです。そのため、複数の型の間で型変換を行うための非常にシンプルな仕組みを提供しています。標準ライブラリでは、基本データ型やよく使われる型に対して、このトレイトが多数実装されています。</p>
<!--
For example we can easily convert a `str` into a `String`
-->
<p>例えば、<code>str</code>から<code>String</code>への型変換は簡単です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
<span class="boring">}
</span></code></pre></pre>
<!--
We can do similar for defining a conversion for our own type.
-->
<p>自作の型に対しても、型変換を定義すれば同じように行えます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2 id="into"><a class="header" href="#into"><code>Into</code></a></h2>
<!--
The [`Into`] trait is simply the reciprocal of the `From` trait. That is, if you
have implemented the `From` trait for your type, `Into` will call it when
necessary.
-->
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトは、単に<code>From</code>トレイトの逆の働きをします。もし自作の型に<code>From</code>トレイトが実装されていたら、<code>Into</code>は必要に応じてそれを呼び出します。</p>
<!--
Using the `Into` trait will typically require specification of the type to
convert into as the compiler is unable to determine this most of the time.
However this is a small trade-off considering we get the functionality for free.
-->
<p><code>Into</code>トレイトを使用すると、ほとんどの場合、コンパイラが型を決定することができないため、変換する型を指定する必要があります。しかし、この機能を無料で得られることを考えれば、これは小さなトレードオフです。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // Try removing the type declaration
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# `TryFrom` and `TryInto`
-->
<h1 id="tryfromおよびtryinto"><a class="header" href="#tryfromおよびtryinto"><code>TryFrom</code>および<code>TryInto</code></a></h1>
<!--
Similar to [`From` and `Into`][from-into], [`TryFrom`] and [`TryInto`] are
generic traits for converting between types. Unlike `From`/`Into`, the
`TryFrom`/`TryInto` traits are used for fallible conversions, and as such,
return [`Result`]s.
-->
<p><a href="conversion/from_into.html"><code>From</code>および<code>Into</code></a>と同様に、<a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>および<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>も型変換を行うジェネリックなトレイトです。<code>From</code>/<code>Into</code>と異なり、<code>TryFrom</code>/<code>TryInto</code>トレイトは失敗する可能性のある型変換に用いられるので、<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>を返します。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# To and from Strings
-->
<h1 id="stringとの型変換"><a class="header" href="#stringとの型変換">Stringとの型変換</a></h1>
<!--
## Converting to String
-->
<h2 id="stringへの型変換"><a class="header" href="#stringへの型変換">Stringへの型変換</a></h2>
<!--
To convert any type to a `String` is as simple as implementing the [`ToString`]
trait for the type. Rather than doing so directly, you should implement the
[`fmt::Display`][Display] trait which automagically provides [`ToString`] and
also allows printing the type as discussed in the section on [`print!`][print].
-->
<p>任意の型を<code>String</code>に変換するのは簡単で、その型に<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>トレイトを実装するだけです。これを直接実装するよりも、<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a>トレイトを実装するのがよいでしょう。そうすることで自動的に<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>が提供されるだけでなく、<a href="conversion/../hello/print.html"><code>print!</code></a>の章で説明したように、その型を表示できるようにもなります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Circle of radius {}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<!--
## Parsing a String
-->
<h2 id="stringの解析"><a class="header" href="#stringの解析">Stringの解析</a></h2>
<!--
One of the more common types to convert a string into is a number. The idiomatic
approach to this is to use the [`parse`] function and either to arrange for
type inference or to specify the type to parse using the 'turbofish' syntax.
Both alternatives are shown in the following example.
-->
<p>文字列からの型変換において、数値への型変換はよく行われるものの一つです。これを行うイディオムは<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a>関数を使用することですが、このときに型を推論できるようにするか、もしくは turbofish構文を使用して型を指定するかのいずれかを行います。以下の例では、どちらの方法も紹介しています。</p>
<!--
This will convert the string into the type specified so long as the [`FromStr`]
trait is implemented for that type. This is implemented for numerous types
within the standard library. To obtain this functionality on a user defined type
simply implement the [`FromStr`] trait for that type.
-->
<p><code>parse</code>関数は、指定された型に<code>FromStr</code>トレイトが実装されていれば、文字列をその型に変換します。このトレイトは標準ライブラリの多くの型に対して実装されています。ユーザー定義の型でこの機能を利用するには、その型に対して<code>FromStr</code>トレイトを実装するだけです。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!(&quot;Sum: {:?}&quot;, sum);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Expressions
-->
<h1 id="式"><a class="header" href="#式">式</a></h1>
<!--
A Rust program is (mostly) made up of a series of statements:
-->
<p>Rustのプログラムは（ほとんどの場合）文(<code>statement</code>)の連続でできています</p>
<pre><code>fn main() {
    // statement
    // statement
    // statement
}
</code></pre>
<!--
There are a few kinds of statements in Rust. The most common two are declaring
a variable binding, and using a `;` with an expression:
-->
<p>宣言文にはいくつかの種類があります。最も一般的なのは変数の束縛(<code>variable binding</code>)と<code>;</code>付きの式(<code>expression</code>)です</p>
<pre><code>fn main() {
    // variable binding
    // 変数束縛
    let x = 5;

    // expression;
    // 式;
    x;
    x + 1;
    15;
}
</code></pre>
<!--
Blocks are expressions too, so they can be used as values in
assignments. The last expression in the block will be assigned to the
place expression such as a local variable. However, if the last expression of the block ends with a
semicolon, the return value will be `()`.
-->
<p>コードブロックも式の一種です。よってブロックを丸ごと値として扱うことができます。その場合ブロック内の最後の式が場所を表す式（例えばローカル変数）に代入されます。ただし、ブロック内の最後の式が<code>;</code>で終わる場合は返り値は<code>()</code>になります。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        // この式は`y`に代入されます。
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        // セミコロンがあるので`z`には`()`が入ります。
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Flow of Control
-->
<h1 id="条件分岐"><a class="header" href="#条件分岐">条件分岐</a></h1>
<!--
An essential part of any programming languages are ways to modify control flow:
`if`/`else`, `for`, and others. Let's talk about them in Rust.
-->
<p>処理の流れをコントロールすることはあらゆるプログラミング言語において重要な要素です。</p>
<p><code>if</code>/<code>else</code>, <code>for</code>等です。Rustの文法を見ていきましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ifelse"><a class="header" href="#ifelse">if/else</a></h1>
<!--
Branching with `if`-`else` is similar to other languages. Unlike many of them,
the boolean condition doesn't need to be surrounded by parentheses, and each
condition is followed by a block. `if`-`else` conditionals are expressions,
and, all branches must return the same type.
-->
<p><code>if-else</code>を用いた条件分岐は他の言語に似ています。多くの言語では条件式の中を括弧でくくる必要がありますが、Rustではその必要はありません。条件式の直後にはブロックが続きます。<code>if-else</code>は式の一種で、いずれの分岐先でも返り値の型は同一でなくてはなりません。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);
    } else {
        print!(&quot;{} is zero&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            // This expression returns an `i32`.
            // この式は`i32`を返す。
            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);

            // This expression must return an `i32` as well.
            // ここでも返り値の型は`i32`でなくてはならない。
            n / 2
            // TODO ^ Try suppressing this expression with a semicolon.
            // TODO ^ セミコロン(`;`)をつけて、返り値を返さないようにしてみましょう
        };
    //   ^ Don't forget to put a semicolon here! All `let` bindings need it.
    //   ここにセミコロンを付けるのを忘れないように!
    //   `let`による変数束縛の際には必ず必要です!

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop"><a class="header" href="#loop">loop</a></h1>
<!--
Rust provides a `loop` keyword to indicate an infinite loop.
-->
<p>Rustには<code>loop</code>というキーワードが存在します。これは無限ループを作成するのに使用します。</p>
<blockquote>
<p>訳注: <code>while True</code>と同じですが、ループのたびに条件を確認しないため、若干高速になります。</p>
</blockquote>
<!--
The `break` statement can be used to exit a loop at anytime, whereas the
`continue` statement can be used to skip the rest of the iteration and start a
new one.
-->
<p>ループから抜けだす時は<code>break</code>, 即座に次のループに移るときは<code>continue</code>が使用できます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // Infinite loop
    // 無限ループ
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // Skip the rest of this iteration
            // 残りの処理をスキップ
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            // Exit this loop
            // ループを抜ける。
            break;
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Nesting and labels
-->
<h1 id="ネストとラベル"><a class="header" href="#ネストとラベル">ネストとラベル</a></h1>
<!--
It's possible to `break` or `continue` outer loops when dealing with nested
loops. In these cases, the loops must be annotated with some `'label`, and the
label must be passed to the `break`/`continue` statement.
-->
<p>ネストしたループを回している時に外側のループを<code>break</code>または<code>continue</code>したい場合があります。こういった場合には<code>label</code>を用いてループにラベルを貼り、<code>break</code>/<code>continue</code>にそのラベルを渡します。</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);

            // This would break only the inner loop
            // これは内側のループのみを中断します。
            //break;

            // This breaks the outer loop
            // こちらは外側を中断します
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);
    }

    println!(&quot;Exited the outer loop&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Returning from loops
-->
<h1 id="loopが返す値"><a class="header" href="#loopが返す値">loopが返す値</a></h1>
<!--
One of the uses of a `loop` is to retry an operation until it succeeds. If the
operation returns a value though, you might need to pass it to the rest of the
code: put it after the `break`, and it will be returned by the `loop`
expression.
-->
<p><code>loop</code>の用途のひとつに「成功するまである処理を再試行する」ことがあります。もしその処理が値を返すならば、それをコードの他の部分に渡す必要があるでしょう。<code>break</code>の後に値を置くと、それが<code>loop</code>式の値として返されます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while"><a class="header" href="#while">while</a></h1>
<!--
The `while` keyword can be used to run a loop while a condition is true.
-->
<p><code>while</code>キーワードは条件が真である限り実行され続けるループのために使用します。</p>
<!--
Let's write the infamous [FizzBuzz][fizzbuzz] using a `while` loop.
-->
<p>悪名高い<a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz問題</a>を<code>while</code>を用いて解いてみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // A counter variable
    // カウンタとなる変数
    let mut n = 1;

    // Loop while `n` is less than 101
    // `n`が101以下である場合のループ
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // Increment counter
        // カウンタに1を追加
        n += 1;
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# for loops
-->
<h1 id="forループ"><a class="header" href="#forループ">forループ</a></h1>
<!--
## for and range
-->
<h2 id="for-と-range"><a class="header" href="#for-と-range">for と range</a></h2>
<!--
The `for in` construct can be used to iterate through an `Iterator`.
One of the easiest ways to create an iterator is to use the range
notation `a..b`. This yields values from `a` (inclusive) to `b`
(exclusive) in steps of one.
-->
<p><code>for in</code>文を用いることで、イテレータ(<code>Iterator</code>)のそれぞれの要素に対して処理をすることが可能です。イテレータを作る最も単純な方法は<code>a..b</code>のような書き方をすることです。これは「<code>a</code>」から「<code>b</code>のひとつ前」までの要素を順に産出(<code>yield</code>)するというものです。</p>
<!--
Let's write FizzBuzz using `for` instead of `while`.
-->
<p>では<code>for</code>と<code>while</code>を用いてFizzBuzzを書いてみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `n` will take the values: 1, 2, ..., 100 in each iteration
    // `n`は1, 2, ...., 100のそれぞれの値を取ります。
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<!--
Alternatively, `a..=b` can be used for a range that is inclusive on both ends.
The above can be written as:
-->
<p>上記の代わりに<code>a..=b</code>を用いると、両端の値を含む範囲を指定できます。上記の例は次のように書けます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `n` will take the values: 1, 2, ..., 100 in each iteration
    // `n`は1, 2, ...., 100のそれぞれの値を取ります。
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<!--
## for and iterators
-->
<h2 id="forとイテレータ"><a class="header" href="#forとイテレータ">forとイテレータ</a></h2>
<!--
The `for in` construct is able to interact with an `Iterator` in several ways.
As discussed in the section on the [Iterator][iter] trait, by default the `for`
loop will apply the `into_iter` function to the collection. However, this is
not the only means of converting collections into iterators.
-->
<p><code>for in</code>構文は<code>Iterator</code>とさまざまな方法でやり取りできます。<a href="flow_control/../trait/iter.html">Iterator</a>トレイトの章で説明したように、デフォルトでは<code>for</code>ループにおいて<code>into_iter</code>関数がコレクションに対して適用されます。しかし、コレクションをイテレータに変換する方法はこれだけではありません。</p>
<!--
`into_iter`, `iter` and `iter_mut` all handle the conversion of a collection
into an iterator in different ways, by providing different views on the data
within.
-->
<p><code>into_iter</code>、<code>iter</code>、<code>iter_mut</code>はいずれもコレクションのイテレータへの変換を行いますが、データの「見せ方」の違いにより、そのやり方はそれぞれ異なります。</p>
<!--
* `iter` - This borrows each element of the collection through each iteration.
  Thus leaving the collection untouched and available for reuse after the loop.
-->
<ul>
<li><code>iter</code> - この関数は、各周回においてコレクションの要素を借用します。よってコレクションには手を加えないので、ループの実行後もコレクションを再利用できます。</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<!--
* `into_iter` - This consumes the collection so that on each iteration the exact
  data is provided. Once the collection has been consumed it is no longer
  available for reuse as it has been 'moved' within the loop.
-->
<ul>
<li><code>into_iter</code> - この関数はコレクションからデータを取り出すので、各周回において要素のデータそのものが提供されます。データを取り出してしまうと、データはループ内に「移動」してしまうので、ループ実行後にコレクションを再利用することはできません。</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<!--
* `iter_mut` - This mutably borrows each element of the collection, allowing for
  the collection to be modified in place.
-->
<ul>
<li><code>iter_mut</code> - この関数はコレクションの各要素をミュータブル（変更可能）で借用するので、コレクションの要素をその場で変更できます。</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }

    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<!--
In the above snippets note the type of `match` branch, that is the key
difference in the types of iteration. The difference in type then of course
implies differing actions that are able to be performed.
-->
<p>上記に示した3つのコードにおいて、<code>match</code>の選択肢の型の違いに注意してください。ここがそれぞれの方法の違いを生む鍵になっています。型が異なれば、当然ながらそれに対して行える処理も変わります。</p>
<!--
### See also:
-->
<h3 id="参照-14"><a class="header" href="#参照-14">参照</a></h3>
<!--
[Iterator][iter]
-->
<p><a href="flow_control/../trait/iter.html">イテレータ</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<!--
Rust provides pattern matching via the `match` keyword, which can be used like
a C `switch`.
-->
<p>Rustは<code>match</code>を用いて、C言語における<code>switch</code>のようなパターンマッチングを行うことができます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 13;
    // TODO ^ Try different values for `number`

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // Match a single value
        // 単一の値とのマッチをチェック
        1 =&gt; println!(&quot;One!&quot;),
        // Match several values
        // いくつかの値とのマッチをチェック
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // Match an inclusive range
        // 特定の範囲の値とのマッチをチェック
        13..=19 =&gt; println!(&quot;A teen&quot;),
        // Handle the rest of cases
        // その他の場合の処理
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // Match is an expression too
    // マッチは式でもある。
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        // マッチは全ての可能な値をカバーしなくてはならない
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ Try commenting out one of these arms
        // TODO ^ 試しに片方をコメントアウトしてみましょう。
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Destructuring
-->
<h1 id="デストラクト"><a class="header" href="#デストラクト">デストラクト</a></h1>
<!--
A `match` block can destructure items in a variety of ways.
-->
<p><code>match</code>は値をさまざまなやり方でデストラクトすることができます。</p>
<!--
* [Destructuring Tuples][tuple]
* [Destructuring Enums][enum]
* [Destructuring Pointers][refs]
* [Destructuring Structures][struct]
-->
<ul>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">タプルのデストラクト</a></li>
<li><a href="flow_control/match/destructuring/destructure_enum.html">列挙型のデストラクト</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">ポインタのデストラクト</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">構造体のデストラクト</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# tuples
-->
<h1 id="タプル-1"><a class="header" href="#タプル-1">タプル</a></h1>
<!--
Tuples can be destructured in a `match` as follows:
-->
<p>以下のように、タプルは<code>match</code>を用いてデストラクトすることができます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let pair = (0, -2);
    // TODO ^ Try different values for `pair`
    // TODO ^ `pair`に別の値を入れてみましょう。

    println!(&quot;Tell me about {:?}&quot;, pair);
    // Match can be used to destructure a tuple
    // `match`を用いてタプルをデストラクトしてみましょう。
    match pair {
        // Destructure the second
        // 2つ目の値をデストラクト
        (0, y) =&gt; println!(&quot;First is `0` and `y` is `{:?}`&quot;, y),
        (x, 0) =&gt; println!(&quot;`x` is `{:?}` and last is `0`&quot;, x),
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),
        // `_` means don't bind the value to a variable
        // ここでは`_`は、値を変数に束縛しないことを意味します。
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-15"><a class="header" href="#参照-15">参照</a></h3>
<!--
[Tuples](../../../primitives/tuples.md)
-->
<p><a href="flow_control/match/destructuring/../../../primitives/tuples.html">タプル</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# enums
-->
<h1 id="列挙型-1"><a class="header" href="#列挙型-1">列挙型</a></h1>
<!--
An `enum` is destructured similarly:
-->
<p>列挙型(<code>enum</code>)も似たやり方でデストラクトすることができます。</p>
<pre><pre class="playground"><code class="language-rust editable">// `allow` required to silence warnings because only
// one variant is used.
// `allow`は値を一つだけ使用したことによる警告を抑えるために存在する。
#[allow(dead_code)]
enum Color {
    // These 3 are specified solely by their name.
    // これら3つの値は名前のみで扱うことができる
    Red,
    Blue,
    Green,
    // These likewise tie `u32` tuples to different names: color models.
    // 以下の値は名前と`u32`のタプルをペアにしている。
    // カラーモデルと呼ばれる。
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // TODO ^ Try different variants for `color`
    // TODO ^ `Color`に別の変数を入れてみましょう

    println!(&quot;What color is it?&quot;);
    // An `enum` can be destructured using a `match`.
    // `enum`は`match`を利用してデストラクトすることができる。
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // Don't need another arm because all variants have been examined
        // 全ての値を列挙したのでその他の場合の処理は必要ない。
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-16"><a class="header" href="#参照-16">参照</a></h3>
<!--
[`#[allow(...)]`][allow], [color models][color_models] and [`enum`][enum]
-->
<p><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">カラーモデル</a>, <a href="flow_control/match/destructuring/../../../custom_types/enum.html">列挙型</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# pointers/ref
-->
<h1 id="ポインタとref"><a class="header" href="#ポインタとref">ポインタとref</a></h1>
<!--
For pointers, a distinction needs to be made between destructuring
and dereferencing as they are different concepts which are used
differently from a language like `C`.
-->
<p>Rustのポインタは、<code>C</code>のポインタとは異なる概念なので、デストラクトとデリファレンスを同じようなやり方で扱うことはできない</p>
<!--
 * Dereferencing uses `*`
 * Destructuring uses `&`, `ref`, and `ref mut`
-->
<ul>
<li>デリファレンスには<code>*</code>を用いる。</li>
<li>デストラクトには<code>&amp;</code>, <code>ref</code>, <code>ref mut</code>を用いる。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Assign a reference of type `i32`. The `&amp;` signifies there
    // is a reference being assigned.
    // `i32`型へのリファレンスをアサインする。
    // `&amp;`によってリファレンスであることを明示している。
    let reference = &amp;4;

    match reference {
        // If `reference` is pattern matched against `&amp;val`, it results
        // in a comparison like:
        // 上で定義した`reference`という変数が`&amp;val`とのパターンマッチ
        // に用いられた場合、以下の2つの値が比較されていることになる。
        // `&amp;i32`
        // `&amp;val`
        // ^ We see that if the matching `&amp;`s are dropped, then the `i32`
        // should be assigned to `val`.
        // ^ よって`&amp;`を落とせば、`i32`が`val`にアサインされることがわかる。
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
    }

    // To avoid the `&amp;`, you dereference before matching.
    // `&amp;`を使用したくない場合は、マッチングの前にデリファレンスする。
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
    }

    // What if you don't start with a reference? `reference` was a `&amp;`
    // because the right side was already a reference. This is not
    // a reference because the right side is not one.
    // いきなりリファレンスを変数に代入するのではない場合はどうでしょう。
    // 先ほどは右辺値が`&amp;`で始まっていたのでリファレンスでしたが、
    // これは違います。
    let _not_a_reference = 3;

    // Rust provides `ref` for exactly this purpose. It modifies the
    // assignment so that a reference is created for the element; this
    // reference is assigned.
    // このような場合、Rustでは変数束縛時に`ref`を宣言します。
    // 要素のリファレンスが作られて、それが束縛対象になります。
    let ref _is_a_reference = 3;

    // Accordingly, by defining 2 values without references, references
    // can be retrieved via `ref` and `ref mut`.
    // 同様にミュータブルな値の場合`ref mut`を使用することでリファレンスを
    // 取得できます。イミュータブルの場合と合わせてみていきましょう。
    let value = 5;
    let mut mut_value = 6;

    // Use `ref` keyword to create a reference.
    // `ref`を使用してリファレンスを作成。
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
    }

    // Use `ref mut` similarly.
    // 同様に`ref mut`を使用。
    match mut_value {
        ref mut m =&gt; {
            // Got a reference. Gotta dereference it before we can
            // add anything to it.
            // リファレンスを取得、値を変更するためにはデリファレンスする必要がある。
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# structs
-->
<h1 id="構造体-1"><a class="header" href="#構造体-1">構造体</a></h1>
<!--
Similarly, a `struct` can be destructured as shown:
-->
<p>以下のようにして、構造体(<code>struct</code>)も同様にデストラクトすることができる。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    // Try changing the values in the struct to see what happens
    let foo = Foo { x: (1, 2), y: 3 };

    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;First of x is 1, b = {},  y = {} &quot;, b, y),

        // you can destructure structs and rename the variables,
        // the order is not important
        // 構造体をデストラクトして変数をリネーム
        // 順番は重要ではない。
        Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),

        // and you can also ignore some variables:
        // 一部の変数を無視することもできる。
        Foo { y, .. } =&gt; println!(&quot;y = {}, we don't care about x&quot;, y),
        // this will give an error: pattern does not mention field `x`
        // `x`に言及していないため、以下はエラーになる。
        //Foo { y } =&gt; println!(&quot;y = {}&quot;, y);
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-17"><a class="header" href="#参照-17">参照</a></h3>
<!--
[Structs](../../../custom_types/structs.md), [The ref pattern](../../../scope/borrow/ref.md)
-->
<p><a href="flow_control/match/destructuring/../../../custom_types/structs.html">構造体</a>, <a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">refによるパターンマッチ</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Guards
-->
<h1 id="ガード"><a class="header" href="#ガード">ガード</a></h1>
<!--
A `match` *guard* can be added to filter the arm.
-->
<p><code>match</code>内の条件文をフィルタリングするために、 <em>ガード(<code>guard</code>)</em> を使用することができます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // TODO ^ Try different values for `pair`
    // TODO ^ `pair`の値を変更してみましょう。

    println!(&quot;Tell me about {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),
        // The ^ `if condition` part is a guard
        //     ^ `if`とそれに続く条件式がガードです。
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _ =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-18"><a class="header" href="#参照-18">参照</a></h3>
<!--
[Tuples](../../primitives/tuples.md)
-->
<p><a href="flow_control/match/../../primitives/tuples.html">タプル</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Binding
-->
<h1 id="バインディング"><a class="header" href="#バインディング">バインディング</a></h1>
<!--
Indirectly accessing a variable makes it impossible to branch and use that
variable without re-binding. `match` provides the `@` sigil for binding values to
names:
-->
<p>いくつかの変数をまとめてマッチ対象とした場合、そのうちの一つを分岐先で使用することはそのままでは不可能です。<code>match</code>内では<code>@</code>マークを使用して変数をバインディングすることができます。</p>
<pre><pre class="playground"><code class="language-rust editable">// A function `age` which returns a `u32`.
// `age`関数は`u32`の値を返す。
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I'm not born yet I guess&quot;),
        // Could `match` 1 ..= 12 directly but then what age
        // would the child be? Instead, bind to `n` for the
        // sequence of 1 ..= 12. Now the age can be reported.
        // `1 ... 12`の値を一挙に`match`させることができる。
        // しかしその場合、子供は正確には何歳?
        // マッチした値を`n`にバインディングすることで値を使用できる。
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // Nothing bound. Return the result.
        // マッチしなかった場合の処理
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<p>You can also use binding to &quot;destructure&quot; <code>enum</code> variants, such as <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // Got `Some` variant, match if its value, bound to `n`,
        // is equal to 42.
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),
        // Match any other number.
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),
        // Match anything else (`None` variant).
        _            =&gt; (),
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-19"><a class="header" href="#参照-19">参照</a></h3>
<!--
[`functions`][functions], [`enums`][enums] and [`Option`][option]
-->
<p><a href="flow_control/match/../../fn.html">関数</a>, <a href="flow_control/match/../../custom_types/enum.html"><code>enums</code></a>, <a href="flow_control/match/../../std/option.html"><code>Option</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<!--
For some use cases, when matching enums, `match` is awkward. For example:
-->
<p>列挙型をマッチさせるとき、場合によっては<code>match</code>を使用すると不自然な書き方になってしまう場合があります。例えば...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make `optional` of type `Option&lt;i32&gt;`
// `optional`という変数の型を`Option&lt;i32&gt;`に指定
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        // ^ Needed 2 indentations just so we could destructure
        // `i` from the option.
        // ^ `i`をoption型からデストラクトするためだけに
        // インデントが一つ増えてしまっている。
    },
    _ =&gt; {},
    // ^ Required because `match` is exhaustive. Doesn't it seem
    // like wasted space?
    // ^ `match`は全ての型に対して網羅的でなくてはならないので必要。
    // 冗長に見えませんか？
};

<span class="boring">}
</span></code></pre></pre>
<!--
`if let` is cleaner for this use case and in addition allows various
failure options to be specified:
-->
<p>この場合は<code>if let</code>を用いたほうが美しく、失敗時の処理も柔軟に行うことができます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // All have type `Option&lt;i32&gt;`
    // 全て`Option&lt;i32&gt;`型
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // The `if let` construct reads: &quot;if `let` destructures `number` into
    // `Some(i)`, evaluate the block (`{}`).
    // `if let`文は以下と同じ意味.
    //
    // もしletがnumberをデストラクトした結果が`Some(i)`になるならば
    // ブロック内(`{}`)を実行する。
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);
    }

    // If you need to specify a failure, use an else:
    // デストラクトした結果が`Some()`にならない場合の処理を明示したい場合、
    // `else`を使用する。
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // Destructure failed. Change to the failure case.
        // デストラクト失敗の場合。このブロック内を実行
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    }

    // Provide an altered failing condition.
    // デストラクト失敗時の処理を更に分岐させることもできる
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // Destructure failed. Evaluate an `else if` condition to see if the
    // alternate failure branch should be taken:
    // デストラクト失敗。`else if`を評価し、処理をさらに分岐させる。
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        // The condition evaluated false. This branch is the default:
        // 今回は`else if`の評価がfalseなので、このブロック内がデフォルト
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);
    }
}
</code></pre></pre>
<p>In the same way, <code>if let</code> can be used to match any enum value:</p>
<pre><pre class="playground"><code class="language-rust editable">// Our example enum
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // Create example variables
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // Variable a matches Foo::Bar
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }
    
    // Variable b does not match Foo::Bar
    // So this will print nothing
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }
    
    // Variable c matches Foo::Qux which has a value
    // Similar to Some() in the previous example
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }

    // Binding also works with `if let`
    if let Foo::Qux(value @ 100) = c {
        println!(&quot;c is one hundred&quot;);
    }
}
</code></pre></pre>
<p>Another benefit is that <code>if let</code> allows us to match non-parameterized enum variants. This is true even in cases where the enum doesn't implement or derive <code>PartialEq</code>. In such cases <code>if Foo::Bar == a</code> would fail to compile, because instances of the enum cannot be equated, however <code>if let</code> will continue to work.</p>
<p>Would you like a challenge? Fix the following example to use <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// This enum purposely neither implements nor derives PartialEq.
// That is why comparing Foo::Bar == a fails below.
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // Variable a matches Foo::Bar
    if Foo::Bar == a {
    // ^-- this causes a compile-time error. Use `if let` instead.
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-20"><a class="header" href="#参照-20">参照</a></h3>
<!--
[`enum`][enum], [`Option`][option], and the [RFC][if_let_rfc]
-->
<p><a href="flow_control/../custom_types/enum.html">列挙型</a>, <a href="flow_control/../std/option.html">オプション</a>, <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-let"><a class="header" href="#while-let">while let</a></h1>
<!--
Similar to `if let`, `while let` can make awkward `match` sequences
more tolerable. Consider the following sequence that increments `i`:
-->
<p><code>if let</code>と同様に、<code>while let</code>も不格好な<code>match</code>処理を多少マシにしてくれます。例えば、以下の<code>i</code>をインクリメントする処理を見てください。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make `optional` of type `Option&lt;i32&gt;`
// `Option&lt;i32&gt;`の`optional`を作成
let mut optional = Some(0);

// Repeatedly try this test.
// 変数の照合を繰り返し行う。
loop {
    match optional {
        // If `optional` destructures, evaluate the block.
        // もし`optional`のデストラクトに成功した場合、値に応じて処理を分岐
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ Requires 3 indentations!
            // ^ 3つものインデントが必要。
        },
        // Quit the loop when the destructure fails:
        // デストラクトに失敗した場合、ループを脱出
        _ =&gt; { break; }
        // ^ Why should this be required? There must be a better way!
        // どうしてこんな行を書く必要が?もっと良い方法があるはずです!
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Using `while let` makes this sequence much nicer:
-->
<p><code>while let</code>の使用によってベターになります。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Make `optional` of type `Option&lt;i32&gt;`
    // `Option&lt;i32&gt;`の`optional`を作成
    let mut optional = Some(0);

    // This reads: &quot;while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    // これは次のように読める。「`let`が`optional`を`Some(i)`にデストラクトしている間は
    // ブロック内(`{}`)を評価せよ。さもなくば`break`せよ。」
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ Less rightward drift and doesn't require
        // explicitly handling the failing case.
        // ^ インデントが少なく、デストラクト失敗時の処理を追加で書く必要がない。
    }
    // ^ `if let` had additional optional `else`/`else if`
    // clauses. `while let` does not have these.
    // ^ `if let`の場合は`else`/`else if`句が一つ余分にあったが、
    // `while let`では必要が無い。
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-21"><a class="header" href="#参照-21">参照</a></h3>
<!--
[`enum`][enum], [`Option`][option], and the [RFC][while_let_rfc]
-->
<p><a href="flow_control/../custom_types/enum.html">列挙型(<code>enum</code>)</a>, <a href="flow_control/../std/option.html"><code>Option</code></a>, <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Functions
-->
<h1 id="関数"><a class="header" href="#関数">関数</a></h1>
<!--
Functions are declared using the `fn` keyword. Its arguments are type
annotated, just like variables, and, if the function returns a value, the
return type must be specified after an arrow `->`.
-->
<p>関数は<code>fn</code>キーワードを用いて定義することができます。引数は変数と同様に型を指定する必要があり、もし関数が値を返すならば<code>-&gt;</code>の後にその型も指定する必要があります。</p>
<!--
The final expression in the function will be used as return value.
Alternatively, the `return` statement can be used to return a value earlier
from within the function, even from inside loops or `if`s.
-->
<p>関数内の最後の式が返り値となります。関数の途中で値を返したい場合は<code>return</code>文を使用します。<code>loop</code>の最中や<code>if</code>文の中からも値を返すことができます。</p>
<!--
Let's rewrite FizzBuzz using functions!
-->
<p>では、もう一度FizzBuzz問題を解く関数を書いてみましょう！</p>
<pre><pre class="playground"><code class="language-rust editable">// Unlike C/C++, there's no restriction on the order of function definitions
// C/C++とは違い、関数の定義を行う順番に制限はない。
fn main() {
    // We can use this function here, and define it somewhere later
    // ここで関数を使用し、後ほど定義してもかまわない。
    fizzbuzz_to(100);
}

// Function that returns a boolean value
// ブーリアン型を返す関数
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // Corner case, early return
    // 例外的な引数を受けた場合、早めに返す。
    if rhs == 0 {
        return false;
    }

    // This is an expression, the `return` keyword is not necessary here
    // これは式であり、`return`キーワードは必要ではない。
    lhs % rhs == 0
}

// Functions that &quot;don't&quot; return a value, actually return the unit type `()`
// 値を「返さない」関数、実際にはユニット型(`()`)を返している。
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// When a function returns `()`, the return type can be omitted from the
// signature
// 関数が`()`を返すとき、返り値の型を書く必要はない。
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Methods
-->
<h1 id="メソッド"><a class="header" href="#メソッド">メソッド</a></h1>
<!--
Methods are functions attached to objects. These methods have access to the
data of the object and its other methods via the `self` keyword. Methods are
defined under an `impl` block.
-->
<p>メソッドとはオブジェクトに付属した関数のことです。オブジェクトの持つデータや他のメソッドへは<code>self</code>という語を介してアクセスすることができます。<code>impl</code>キーワードによって定義します。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// Implementation block, all `Point` methods go in here
// メソッドの実装のためのブロック。`Point`の持つメソッドを全て定義する。
impl Point {
    // This is a static method
    // Static methods don't need to be called by an instance
    // These methods are generally used as constructors
    // スタティックメソッド。つまり、インスタンスからでなくても
    // 呼び出せるメソッド。以下のようにコンストラクタとして使用されることが多い。
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Another static method, taking two arguments:
    // もう一つスタティックメソッド。引数を2つ取る。
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // This is an instance method
    // `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    // こちらはインスタンスメソッド。`&amp;self`は`self: &amp;Self`の糖衣構文。
    // `Self`は呼び出し元オブジェクトの型。この場合は`Rectangle`。
    fn area(&amp;self) -&gt; f64 {
        // `self` gives access to the struct fields via the dot operator
        // `self`はドット演算子によって構造体のfieldを参照できる。
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` is a `f64` method that returns the absolute value of the
        // caller
        // `abs`は`f64`のメソッドで、呼び出し元の値の絶対値を返す。
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&amp;mut self` desugars to `self: &amp;mut Self`
    // このメソッドは呼び出し元オブジェクトがミュータブルであることを
    // 必要とする。`&amp;mut self`は`self: &amp;mut Self`の糖衣構文である。
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
// `Pair`はヒープ上の整数を2つ保持する。
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // This method &quot;consumes&quot; the resources of the caller object
    // `self` desugars to `self: Self`
    // このメソッドは呼び出し元オブジェクトの持つ要素を「消費」する。
    // `self`は`self: Self`の糖衣構文である。
    fn destroy(self) {
        // Destructure `self`
        // `self`をデストラクト
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` and `second` go out of scope and get freed
        // `first`、`second`はスコープから抜け出すと同時に、解放される。
    }
}

fn main() {
    let rectangle = Rectangle {
        // Static methods are called using double colons
        // スタティックメソッドはコロンを2つ挟んで呼び出される。
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Instance methods are called using the dot operator
    // Note that the first argument `&amp;self` is implicitly passed, i.e.
    // インスタンスメソッドはドット演算子を用いて呼び出される。
    // 最初の引数`&amp;self`は明示せずに受け渡されていることに注目。つまり
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    // エラー！`rectangle`はイミュータブルだがこのメソッドはミュータブルなオブジェクトを
    // 必要とする。
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。

    // Okay! Mutable objects can call mutable methods
    // OK! ミュータブルなオブジェクトはミュータブルなメソッドを呼び出せる。
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call &quot;consumed&quot; `pair`
    // エラー！先ほどの`destroy`で`pair`はすでに消費されてしまっている。
    //pair.destroy();
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Closures
-->
<h1 id="クロージャ"><a class="header" href="#クロージャ">クロージャ</a></h1>
<!--
Closures in Rust, also called lambda expressions or lambdas, are functions that can capture 
the enclosing environment. For example, a closure that captures the x 
variable:
-->
<p>Rustにおけるクロージャは、ラムダ式またはラムダとも呼ばれますが、その外側の環境を捕捉した関数のことです。例えば、次のコードは変数xを捕捉したクロージャです。</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<!--
The syntax and capabilities of closures make them very convenient for 
on the fly usage. Calling a closure is exactly like calling a function.
However, both input and return types *can* be inferred and input 
variable names *must* be specified.
-->
<p>クロージャの構文や機能は、その場限りの用途で何かを作るのに便利です。クロージャの呼び出しは関数の呼び出しと全く同じです。しかし、入力の型と戻り値の型は推論させることができますが、入力変数の名前は必ず指定しなくてはなりません。</p>
<!--
Other characteristics of closures include:
* using `||` instead of `()` around input variables.
* optional body delimination (`{}`) for a single expression (mandatory otherwise).
* the ability to capture the outer environment variables.
-->
<p>クロージャの他の特徴を以下に示します。</p>
<ul>
<li>入力変数を囲むのに、<code>()</code>の代わりに<code>||</code>を用います。</li>
<li>本体が単一の式の場合は、本体の区切り文字（<code>{}</code>）を省略できます。（それ以外の場合は必須です）</li>
<li>外側の環境にある変数を捕捉することができます。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Increment via closures and functions.
    // 関数とクロージャのそれぞれで数値をインクリメントする
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // Closures are anonymous, here we are binding them to references
    // Annotation is identical to function annotation but is optional
    // as are the `{}` wrapping the body. These nameless functions
    // are assigned to appropriately named variables.
    // 型アノテーションは、通常の関数と同様の方法で行えるが、必須ではない。
    // `{}`も必須ではない。
    // クロージャは一種の無名関数なので、適切な変数にバインディングしてやるとよい
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // Call the function and closures.
    // 関数とクロージャを呼び出す。
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // A closure taking no arguments which returns an `i32`.
    // The return type is inferred.
    // 引数なしで`i32`を返すクロージャ。
    // 戻り値の型は推論された。
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Capturing
-->
<h1 id="要素の捕捉"><a class="header" href="#要素の捕捉">要素の捕捉</a></h1>
<!--
Closures are inherently flexible and will do what the functionality requires
to make the closure work without annotation. This allows capturing to
flexibly adapt to the use case, sometimes moving and sometimes borrowing.
Closures can capture variables:
-->
<p>クロージャはとてもフレキシブルに動作するように出来ています。クロージャにおいて型アノテーションをする必要が無いのは前述の仕組みのためですが、この仕組みのおかげでユースケースに応じて参照を取得したり値そのものを取得したりといった動作が可能になります。
クロージャは外側の環境にある要素を、以下の形で取得することができます。</p>
<!--
* by reference: `&T`
* by mutable reference: `&mut T`
* by value: `T`
-->
<ul>
<li>リファレンス: <code>&amp;T</code></li>
<li>ミュータブルなリファレンス: <code>&amp;mut T</code></li>
<li>値そのもの: <code>T</code></li>
</ul>
<!--
They preferentially capture variables by reference and only go lower when
required.
-->
<p>クロージャは出来る限りリファレンスを取得しようとし、その他2つは必要なときのみ取得します。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    use std::mem;
    
    let color = &quot;green&quot;;

    // A closure to print `color` which immediately borrows (`&amp;`) `color` and
    // stores the borrow and closure in the `print` variable. It will remain
    // borrowed until `print` is used the last time. 
    //
    // `println!` only requires arguments by immutable reference so it doesn't
    // impose anything more restrictive.
    // `color`をプリントするためのクロージャ。
    // これは`color`を借用(`&amp;`)し、その借用とクロージャを`print`
    // という名の変数に保持する。
    // 借用は`print`がスコープから出るまで続く。
    // `println!`は参照を与えれば機能するので、これ以上なにかする必要はない。
    let print = || println!(&quot;`color`: {}&quot;, color);

    // Call the closure using the borrow.
    // 借用を行ったクロージャをコールする。
    print();

    // `color` can be borrowed immutably again, because the closure only holds
    // an immutable reference to `color`. 
    let _reborrow = &amp;color;
    print();

    // A move or reborrow is allowed after the final use of `print`
    let _color_moved = color;


    let mut count = 0;
    // A closure to increment `count` could take either `&amp;mut count` or `count`
    // but `&amp;mut count` is less restrictive so it takes that. Immediately
    // borrows `count`.
    //
    // A `mut` is required on `inc` because a `&amp;mut` is stored inside. Thus,
    // calling the closure mutates the closure which requires a `mut`.
    // `count`をインクリメントするためのクロージャ。`count`と`&amp;mut count`
    // の両方を取ることができるが、後者のほうが制限が少ないため、
    // （訳注: `count`だと`&amp;mut count`と違い、一度しか呼ぶことができない。）
    // そちらを取る。直後に`count`を借用する。
    //
    // `inc`には`mut`をつける必要がある。なぜならミュータブルな型が
    // 中で使用されているからである。ミュータブルなクロージャは呼ぶたびに
    // 内部変数を変更する。
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // Call the closure using a mutable borrow.
    // クロージャを実行
    inc();

    // The closure still mutably borrows `count` because it is called later.
    // An attempt to reborrow will lead to an error.
    // let _reborrow = &amp;count; 
    // ^ TODO: try uncommenting this line.
    inc();

    // The closure no longer needs to borrow `&amp;mut count`. Therefore, it is
    // possible to reborrow without an error
    let _count_reborrowed = &amp;mut count; 

    
    // A non-copy type.
    let movable = Box::new(3);

    // `mem::drop` requires `T` so this must take by value. A copy type
    // would copy into the closure leaving the original untouched.
    // A non-copy must move and so `movable` immediately moves into
    // the closure.
    // `mem::drop`は`T`（ジェネリック型）を取る必要があるため、このクロージャは
    // 参照ではなく値を取る。その場合、もしもコピー可能な値ならば、
    // 元の値はそのままでコピーのみを取る。不可能ならば値そのものを移動させる。
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` consumes the variable so this can only be called once.
    // `consume`は変数を消費（開放）するため、一度しか呼び出すことができない。
    consume();
    // consume();
    // ^ TODO: Try uncommenting this line.
    // ^ TODO: この行のコメントアウトを解除しましょう。
}
</code></pre></pre>
<p>Using <code>move</code> before vertical pipes forces closure
to take ownership of captured variables:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `Vec` has non-copy semantics.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // println!(&quot;There're {} elements in vec&quot;, haystack.len());
    // ^ Uncommenting above line will result in compile-time error
    // because borrow checker doesn't allow re-using variable after it
    // has been moved.
    
    // Removing `move` from closure's signature will cause closure
    // to borrow _haystack_ variable immutably, hence _haystack_ is still
    // available and uncommenting above line will not cause an error.
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-22"><a class="header" href="#参照-22">参照</a></h3>
<p><a href="fn/closures/../../std/box.html"><code>Box</code></a> and <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# As input parameters
-->
<h1 id="捕捉時の型推論"><a class="header" href="#捕捉時の型推論">捕捉時の型推論</a></h1>
<p>While Rust chooses how to capture variables on the fly mostly without type
annotation, this ambiguity is not allowed when writing functions. When
taking a closure as an input parameter, the closure's complete type must be
annotated using one of a few <code>traits</code>. In order of decreasing restriction,
they are:</p>
<ul>
<li><code>Fn</code>: the closure captures by reference (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: the closure captures by mutable reference (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: the closure captures by value (<code>T</code>)</li>
</ul>
<p>On a variable-by-variable basis, the compiler will capture variables in the
least restrictive manner possible.</p>
<p>For instance, consider a parameter annotated as <code>FnOnce</code>. This specifies
that the closure <em>may</em> capture by <code>&amp;T</code>, <code>&amp;mut T</code>, or <code>T</code>, but the compiler
will ultimately choose based on how the captured variables are used in the
closure.</p>
<p>This is because if a move is possible, then any type of borrow should also
be possible. Note that the reverse is not true. If the parameter is
annotated as <code>Fn</code>, then capturing variables by <code>&amp;mut T</code> or <code>T</code> are not
allowed.</p>
<p>In the following example, try swapping the usage of <code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code> to see what happens:</p>
<pre><pre class="playground"><code class="language-rust editable">// A function which takes a closure as an argument and calls it.
// &lt;F&gt; denotes that F is a &quot;Generic type parameter&quot;
fn apply&lt;F&gt;(f: F) where
    // The closure takes no input and returns nothing.
    // クロージャには引数も返り値もない。
    F: FnOnce() {
    // ^ TODO: Try changing this to `Fn` or `FnMut`.
    // ^ TODO: ここを`Fn`あるいは`FnMut`に変えてみましょう。

    f();
}

// A function which takes a closure and returns an `i32`.
// クロージャを引数に取り、`i32`を返す関数
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // The closure takes an `i32` and returns an `i32`.
    // このクロージャは引数、返り値ともに`i32`
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // A non-copy type.
    // `to_owned` creates owned data from borrowed one
    // コピーではなくmoveが起きる型
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // Capture 2 variables: `greeting` by reference and
    // `farewell` by value.
    // 変数を2つ補足。`greeting`は参照を、
    // `farewell`は値をそれぞれ捕捉する。
    let diary = || {
        // `greeting` is by reference: requires `Fn`.
        // `greeting`は参照なので、`Fn`が必要。
        println!(&quot;I said {}.&quot;, greeting);

        // Mutation forces `farewell` to be captured by
        // mutable reference. Now requires `FnMut`.
        // `farewell`の値を変更するので、この時点で`FnMut`
        // が必要になる。
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // Manually calling drop forces `farewell` to
        // be captured by value. Now requires `FnOnce`.
        // `mem::drop`を明示的に呼ぶと`farewell`が値で
        // 捕捉される必要性が発生する。よって`FnOnce`が必要になる。
        mem::drop(farewell);
    };

    // Call the function which applies the closure.
    // クロージャを適用する関数を実行。
    apply(diary);

    // `double` satisfies `apply_to_3`'s trait bound
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-23"><a class="header" href="#参照-23">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="fn/closures/../../generics.html">Generics</a>, <a href="fn/closures/../../generics/where.html">where</a> and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Type anonymity
-->
<h1 id="クロージャを受け取る関数"><a class="header" href="#クロージャを受け取る関数">クロージャを受け取る関数</a></h1>
<!--
Closures succinctly capture variables from enclosing scopes. Does this have
any consequences? It surely does. Observe how using a closure as a function
parameter requires [generics], which is necessary because of how they are
defined:
-->
<p>クロージャが周辺の環境から変数を取得するやり方は非常に明瞭です。何か注意すべき点はあるのでしょうか？
もちろんです。関数内でクロージャを使う場合、[ジェネリック]型を使用する必要があります。詳しく見ていきましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `F` must be generic.
// `F` はジェネリック型でなくてはならない
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}
</span></code></pre></pre>
<!--
When a closure is defined, the compiler implicitly creates a new
anonymous structure to store the captured variables inside, meanwhile
implementing the functionality via one of the `traits`: `Fn`, `FnMut`, or
`FnOnce` for this unknown type. This type is assigned to the variable which
is stored until calling.
-->
<p>クロージャが定義されると、コンパイラは裏側で、無名の構造体を作り、そこにクロージャによって使用される外側の変数を入れます。同時に<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>という名のトレイトのいずれか一つを介してこの構造体に関数としての機能を実装し、実際に呼び出されるまで待ちます。</p>
<!--
Since this new type is of unknown type, any usage in a function will require
generics. However, an unbounded type parameter `<T>` would still be ambiguous
and not be allowed. Thus, bounding by one of the `traits`: `Fn`, `FnMut`, or
`FnOnce` (which it implements) is sufficient to specify its type.
-->
<p>この無名構造体は型が未指定(<code>unknown</code>)なため、関数を実行する際にはジェネリクスが必要とされます。とはいえ、<code>&lt;T&gt;</code>で指定するだけでは、まだ曖昧です。（訳注: <code>&amp;self</code>、<code>&amp;mut self</code>、<code>self</code>のいずれをとるのかがわからないため）そのため、<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>のいずれか一つを実装することで対応しています。</p>
<pre><pre class="playground"><code class="language-rust editable">// `F` must implement `Fn` for a closure which takes no
// inputs and returns nothing - exactly what is required
// for `print`.
// `F`は`Fn`を実装していなくてはならず、`Fn`は引数と返り値を持たない。
// `print`は文字をプリントするだけのクロージャなので、これが正しい。
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Capture `x` into an anonymous type and implement
    // `Fn` for it. Store it in `print`.
    // `x`を無名の構造体に入れ、それに対し`Fn`を実装する。
    // （訳注: ここでは`Fn`は`fn Fn(&amp;self) -&gt; {println!(&quot;{}&quot;, &amp;self)}`）
    // その構造体を`print`にアサインする。
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-24"><a class="header" href="#参照-24">参照</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">A thorough analysis</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Input functions
-->
<h1 id="関数を受け取る関数"><a class="header" href="#関数を受け取る関数">関数を受け取る関数</a></h1>
<!--
Since closures may be used as arguments, you might wonder if the same can be said
about functions. And indeed they can! If you declare a function that takes a
closure as parameter, then any function that satisfies the trait bound of that
closure can be passed as a parameter.
-->
<p>これまで、クロージャを引数として渡せることを見てきました。すると次の疑問が浮かんできます</p>
<p>「クロージャではない普通の関数を引数として渡すことは可能なのだろうか?」</p>
<p>可能です!もしパラメータとしてクロージャを取る関数を定義すれば、そのクロージャのトレイト境界を満たす任意の関数をパラメータとして渡すことができます。</p>
<pre><pre class="playground"><code class="language-rust editable">// Define a function which takes a generic `F` argument
// bounded by `Fn`, and calls it
// 関数を引数として取り、即座に実行する関数を定義
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// Define a wrapper function satisfying the `Fn` bound
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // Define a closure satisfying the `Fn` bound
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<!--
As an additional note, the `Fn`, `FnMut`, and `FnOnce` `traits` dictate how
a closure captures variables from the enclosing scope.
-->
<p>クロージャによる変数の補足がどのように行われているかを詳しく見たいときは<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>を参照してください。</p>
<!--
### See also:
-->
<h3 id="参照-25"><a class="header" href="#参照-25">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# As output parameters
-->
<h1 id="クロージャを返す関数"><a class="header" href="#クロージャを返す関数">クロージャを返す関数</a></h1>
<p>Closures as input parameters are possible, so returning closures as
output parameters should also be possible. However, anonymous
closure types are, by definition, unknown, so we have to use
<code>impl Trait</code> to return them.</p>
<p>The valid traits for returning a closure are:</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>Beyond this, the <code>move</code> keyword must be used, which signals that all captures
occur by value. This is required because any captures by reference would be
dropped as soon as the function exited, leaving invalid references in the
closure.</p>
<pre><pre class="playground"><code class="language-rust editable">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = &quot;FnOnce&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-26"><a class="header" href="#参照-26">参照</a></h3>
<!--
[`Fn`][fn], [`FnMut`][fnmut], [Generics][generics] and [impl Trait][impltrait].
-->
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="fn/closures/../../generics.html">ジェネリクス</a>, <a href="fn/closures/../../trait/impl_trait.html">impl Trait</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Examples in `std`
-->
<h1 id="stdにおける使用例"><a class="header" href="#stdにおける使用例"><code>std</code>における使用例</a></h1>
<!--
This section contains a few examples of using closures from the `std` library.
-->
<p>この節では<code>std</code>ライブラリを用いて、クロージャの利用例を幾つかお見せします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteratorany"><a class="header" href="#iteratorany">Iterator::any</a></h1>
<!--
`Iterator::any` is a function which when passed an iterator, will return
`true` if any element satisfies the predicate. Otherwise `false`. Its
signature:
-->
<p><code>iterator::any</code>は、イテレータ内に一つでも条件を満たす要素があれば、<code>true</code>を返し、さもなくば<code>false</code>を返すイテレータです。以下がそのシグネチャです</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    // イテレートされる値の型
    type Item;

    // `any` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    // `any`は`&amp;mut self`を取るため、イテレータを呼び出した値を借用し
    // 変更しますが、消費し尽くすことはありません。
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `Self::Item` states it takes
        // arguments to the closure by value.
        // `FnMut`はクロージャによって補足される変数が変更される
        // 事はあっても消費されることはないということを示します。
        // `Self::Item`はクロージャが変数を値として取ることを示します。
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`. Destructure to `i32`.
    // ベクトル型に対する`iter`は`&amp;i32`を`yield`するので、`i32`へとデストラクト
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for vecs yields `i32`. No destructuring required.
    // `into_iter()`の場合は`i32`を`yield`するので、デストラクトする必要はない。
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`.
    // 配列に対する`iter()`は`&amp;i32`をyieldする。
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`.
    // 配列に`into_iter()`を使うと例外的に`&amp;i32`を`yield`する。
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-27"><a class="header" href="#参照-27">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="searching-through-iterators"><a class="header" href="#searching-through-iterators">Searching through iterators</a></h1>
<!--
`Iterator::find` is a function which iterates over an iterator and searches for the 
first value which satisfies some condition. If none of the values satisfy the 
condition, it returns `None`. Its signature:
-->
<p><code>Iterator::find</code>はイテレータを辿る関数で、条件を満たす最初の値を探します。もし条件を満たす値がなければ<code>None</code>を返します。型シグネチャは以下のようになります。</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    // イテレートされる値の型
    type Item;

    // `find` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    // `find`は`&amp;mut self`を取るため、イテレータを呼び出した値を借用し
    // 変更しますが、消費し尽くすことはありません。
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `&amp;Self::Item` states it takes
        // arguments to the closure by reference.
        // `FnMut`はクロージャによって補足される変数が変更される
        // 事はあっても消費されることはないということを示します。
        // `&amp;Self::Item`はクロージャが変数を参照として取ることを示します。
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`.
    // ベクトル型に対する`iter`は`&amp;i32`を`yield`する。
    let mut iter = vec1.iter();
    // `into_iter()` for vecs yields `i32`.
    // `inter_iter()`の場合は`i32`を`yield`する。
    let mut into_iter = vec2.into_iter();

    // `iter()` for vecs yields `&amp;i32`, and we want to reference one of its
    // items, so we have to destructure `&amp;&amp;i32` to `i32`
    // `yield`された要素へのリファレンスは`&amp;&amp;i32`となる。`i32`へとデストラクトする。
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` for vecs yields `i32`, and we want to reference one of
    // its items, so we have to destructure `&amp;i32` to `i32`
    // `into_iter`の場合は`&amp;i32`が要素のリファレンス。
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`
    // 配列に対する`iter`も`&amp;i32`を`yield`する。
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`
    // 配列に`into_iter()`を使うと例外的に`&amp;i32`を`yield`する。
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<p><code>Iterator::find</code> gives you a reference to the item. But if you want the <em>index</em> of the
item, use <code>Iterator::position</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec = vec![1, 9, 3, 3, 13, 2];

    let index_of_first_even_number = vec.iter().position(|x| x % 2 == 0);
    assert_eq!(index_of_first_even_number, Some(5));
    
    
    let index_of_first_negative_number = vec.iter().position(|x| x &lt; &amp;0);
    assert_eq!(index_of_first_negative_number, None);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-28"><a class="header" href="#参照-28">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find_map"><code>std::iter::Iterator::find_map</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>std::iter::Iterator::position</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rposition"><code>std::iter::Iterator::rposition</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Higher Order Functions
-->
<h1 id="高階関数"><a class="header" href="#高階関数">高階関数</a></h1>
<!--
Rust provides Higher Order Functions (HOF). These are functions that
take one or more functions and/or produce a more useful function. HOFs
and lazy iterators give Rust its functional flavor.
-->
<p>Rustには高階関数(<code>Higher Order Functions, HOF</code>)を扱う機能が備わっています。</p>
<pre><pre class="playground"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    // 1000以下の奇数を2乗した値の合計を求める。
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // Imperative approach
    // Declare accumulator variable
    // 宣言型プログラミングによるアプローチ
    // 値を蓄積する変数を宣言
    let mut acc = 0;
    // Iterate: 0, 1, 2, ... to infinity
    // 0から無限までイテレートする
    for n in 0.. {
        // Square the number
        // 値を2乗
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // Break loop if exceeded the upper limit
            // 上限に達した場合、ループを終了
            break;
        } else if is_odd(n_squared) {
            // Accumulate value, if it's odd
            // 奇数ならば値を値を足しあわせていく。
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // Functional approach
    // 関数型プログラミングによるアプローチ
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)                             // All natural numbers squared
                                                         // 全自然数を2乗し
             .take_while(|&amp;n_squared| n_squared &lt; upper) // Below upper limit
                                                         // そのうち上限より小さい値で
             .filter(|&amp;n_squared| is_odd(n_squared))     // That are odd
                                                         // かつ奇数のものを
             .fold(0, |acc, n_squared| acc + n_squared); // Sum them
                                                         // 足し合わせる。
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<!--
[Option][option]
and
[Iterator][iter]
implement their fair share of HOFs.
-->
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">オプション型</a>
と
<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">イテレータ</a>には高階関数が使用されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diverging-functions"><a class="header" href="#diverging-functions">Diverging functions</a></h1>
<p>Diverging functions never return. They are marked using <code>!</code>, which is an empty type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>As opposed to all the other types, this one cannot be instantiated, because the
set of all possible values this type can have is empty. Note that, it is
different from the <code>()</code> type, which has exactly one possible value.</p>
<p>For example, this function returns as usual, although there is no information
in the return value.</p>
<pre><pre class="playground"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>As opposed to this function, which will never return the control back to the caller.</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre>
<p>Although this might seem like an abstract concept, it is in fact very useful and
often handy. The main advantage of this type is that it can be cast to any other
one and therefore used at places where an exact type is required, for instance
in <code>match</code> branches. This allows us to write code like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // Notice that the return type of this match expression must be u32
            // because of the type of the &quot;addition&quot; variable.
            let addition: u32 = match i%2 == 1 {
                // The &quot;i&quot; variable is of type u32, which is perfectly fine.
                true =&gt; i,
                // On the other hand, the &quot;continue&quot; expression does not return
                // u32, but it is still fine, because it never returns and therefore
                // does not violate the type requirements of the match expression.
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>It is also the return type of functions that loop forever (e.g. <code>loop {}</code>) like
network servers or functions that terminates the process (e.g. <code>exit()</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Modules
-->
<h1 id="モジュール"><a class="header" href="#モジュール">モジュール</a></h1>
<!--
Rust provides a powerful module system that can be used to hierarchically split
code in logical units (modules), and manage visibility (public/private) between
them.
-->
<p>Rustにはコードを階層的に分割し、お互いの機能を隠蔽・公開するための強力なモジュールシステムが存在します。</p>
<!--
A module is a collection of items: functions, structs, traits, `impl` blocks,
and even other modules.
-->
<p>モジュールは関数、構造体、トレイト、<code>impl</code>ブロック、さらには他のモジュールなどの要素の集合です。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Visibility
-->
<h1 id="プライベートとパブリック"><a class="header" href="#プライベートとパブリック">プライベートとパブリック</a></h1>
<!--
By default, the items in a module have private visibility, but this can be
overridden with the `pub` modifier. Only the public items of a module can be
accessed from outside the module scope.
-->
<p>デフォルトでは、モジュール内の要素はプライベートですが、これは<code>pub</code>で修飾することでパブリックな属性にすることができます。パブリックな属性のみがモジュールの外のスコープからアクセスすることができるようになります。</p>
<pre><pre class="playground"><code class="language-rust editable">// A module named `my_mod`
// `my_mod`という名称のモジュール
mod my_mod {
    // Items in modules default to private visibility.
    // モジュール内の要素はデフォルトでプライベート
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // Use the `pub` modifier to override default visibility.
    // `pub`を用いてパブリックに変更
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // Items can access other items in the same module,
    // even when private.
    // モジュール内からならば、プライベートな属性にアクセスすることに支障はない。
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // Modules can also be nested
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // Functions declared using `pub(in path)` syntax are only visible
        // within the given path. `path` must be a parent or ancestor module
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n&gt; &quot;);
            public_function_in_nested();
        }

        // Functions declared using `pub(self)` syntax are only visible within
        // the current module, which is the same as leaving them private
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested()`&quot;);
        }

        // Functions declared using `pub(super)` syntax are only visible within
        // the parent module
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called `my_mod::nested::public_function_in_super_mod()`&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_function_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate) makes functions visible only within the current crate
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()`&quot;);
    }

    // Nested modules follow the same rules for visibility
    // ネストしたモジュールも、同様の性質を示す。
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }

        // Private parent items will still restrict the visibility of a child item,
        // even if it is declared as visible within a bigger scope.
        #[allow(dead_code)]
        pub(crate) fn restricted_function() {
            println!(&quot;called `my_mod::private_nested::restricted_function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // Modules allow disambiguation between items that have the same name.
    // モジュールによって、同名の関数を区別することができる。
    function();
    my_mod::function();

    // Public items, including those inside nested modules, can be
    // accessed from outside the parent module.
    // パブリックな要素ならば、たとえネストしたものでも、
    // モジュールの外からアクセスすることができる。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) items can be called from anywhere in the same crate
    my_mod::public_function_in_crate();

    // pub(in path) items can only be called from within the module specified
    // Error! function `public_function_in_my_mod` is private
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ Try uncommenting this line

    // Private items of a module cannot be directly accessed, even if
    // nested in a public module:
    // プライベートな要素は、たとえパブリックなモジュール内に存在していても
    // 直接アクセスすることはできない。

    // Error! `private_function` is private
    // エラー!`private_function`はプライベート。
    //my_mod::private_function();
    // TODO ^ Try uncommenting this line
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // Error! `private_function` is private
    // エラー！`private_function`はプライベート。
    //my_mod::nested::private_function();
    // TODO ^ Try uncommenting this line
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // Error! `private_nested` is a private module
    // エラー！`private_nested`はプライベートなモジュール 。
    //my_mod::private_nested::function();
    // TODO ^ Try uncommenting this line
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // Error! `private_nested` is a private module
    //my_mod::private_nested::restricted_function();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Struct visibility
-->
<h1 id="構造体の場合"><a class="header" href="#構造体の場合">構造体の場合</a></h1>
<!--
Structs have an extra level of visibility with their fields. The visibility 
defaults to private, and can be overridden with the `pub` modifier. This 
visibility only matters when a struct is accessed from outside the module 
where it is defined, and has the goal of hiding information (encapsulation).
-->
<p>構造体はそれ自身に加え、フィールドごとにもパブリック・プライベートを設定することができます。デフォルトではプライベートですが、<code>pub</code>宣言をすることで、フィールドをパブリックにすることができます。これは、構造体がモジュールの外から参照される時に限り意味のあるもので、情報の隠蔽（カプセル化）を達成するための機能です。</p>
<pre><pre class="playground"><code class="language-rust editable">mod my {
    // A public struct with a public field of generic type `T`
    // パブリックなフィールド`T`（ジェネリック型）を持つパブリックな構造体
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // A public struct with a private field of generic type `T`
    // プライベートなフィールド`T`（ジェネリック型）を持つパブリックな構造体
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // A public constructor method
        // パブリックなコンストラクタメソッドを持つ構造体
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // Public structs with public fields can be constructed as usual
    // パブリックなフィールドを持つパブリックな構造体は、通常通り
    // インスタンス化できる。
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // and their fields can be normally accessed.
    // フィールドにも普通にアクセスできる。
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // Public structs with private fields cannot be constructed using field names.
    // Error! `ClosedBox` has private fields
    // プライベートなフィールドを持つ構造体は、インスタンス化する際に
    // フィールド名を指定することができない。
    // エラー!`ClosedBox`にはプライベートな属性が存在します。
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // TODO ^ Try uncommenting this line
    // TODO ^ 試しにここをアンコメントしてみましょう。

    // However, structs with private fields can be created using
    // public constructors
    // そのような場合でも、パブリックなコンストラクタを介して作成
    // することは可能。
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // and the private fields of a public struct cannot be accessed.
    // Error! The `contents` field is private
    // たとえパブリックな構造体でも、プライベートなフィールドには
    // アクセス出来ない。
    // エラー!`contents`フィールドはプライベートです。
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // TODO ^ Try uncommenting this line
    // TODO ^ ここをアンコメントしてみましょう。
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-29"><a class="header" href="#参照-29">参照</a></h3>
<!--
[generics][generics] and [methods][methods]
-->
<p><a href="mod/../generics.html">ジェネリック型</a>, <a href="mod/../fn/methods.html">メソッド</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# The `use` declaration
-->
<h1 id="use宣言"><a class="header" href="#use宣言"><code>use</code>宣言</a></h1>
<!--
The `use` declaration can be used to bind a full path to a new name, for easier
access. It is often used like this:
-->
<p><code>use</code>宣言をすることで、要素の絶対パスを新しい名前にバインドすることができ、より簡潔な記述が可能になります。例えば以下のように使えます。</p>
<pre><code class="language-rust editable ignore">// extern crate deeply; // normally, this would exist and not be commented out!

use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    my_first_function();
}
</code></pre>
<!--
You can use the `as` keyword to bind imports to a different name:
-->
<p><code>as</code>キーワードを使用することで、インポートを別名にバインドすることができます。</p>
<pre><pre class="playground"><code class="language-rust editable">// Bind the `deeply::nested::function` path to `other_function`.
// `deeply::nested::function`を`other_function`にバインド
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;);
        }
    }
}

fn main() {
    // Easier access to `deeply::nested::function`
    // `deeply::nested::function`へ、より簡潔にアクセス
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // This is equivalent to `use deeply::nested::function as function`.
        // This `function()` will shadow the outer one.
        // これは`use deeply::nested::function as function`と同等
        // この`function()`は外の`function()`をシャドウイングする
        use crate::deeply::nested::function;
        function();

        // `use` bindings have a local scope. In this case, the
        // shadowing of `function()` is only in this block.
        // `use`バインディングは局所的なスコープを持つ。
        // この場合には`function()`のシャドウイングはこのブロック内のみ
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# `super` and `self`
-->
<h1 id="super-と-self"><a class="header" href="#super-と-self"><code>super</code> と <code>self</code></a></h1>
<!--
The `super` and `self` keywords can be used in the path to remove ambiguity
when accessing items and to prevent unnecessary hardcoding of paths.
-->
<p><code>super</code>及び<code>self</code>キーワードは、要素にアクセスする際に、曖昧さをなくし、不必要なハードコーディングを避けるために使用できます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // Let's access all the functions named `function` from this scope!
        // `function`という名の様々な関数をこのスコープ内から参照してみましょう。
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // The `self` keyword refers to the current module scope - in this case `my`.
        // Calling `self::function()` and calling `function()` directly both give
        // the same result, because they refer to the same function.
        // `self`キーワードは現在のモジュールスコープを示す。この場合は`my`。
        // `self::function()`と`funcition()`は同じ関数であるため、同じ結果になる。
        self::function();
        function();
        
        // We can also use `self` to access another module inside `my`:
        // `my`以下の別のモジュールを呼び出す際に`self`を用いて明示的に参照できる。
        self::cool::function();
        
        // The `super` keyword refers to the parent scope (outside the `my` module).
        // `super`は親スコープ（`my`の外側）を参照する。
        super::function();
        
        // This will bind to the `cool::function` in the *crate* scope.
        // In this case the crate scope is the outermost scope.
        // 以下は *クレート* スコープ内の`cool::function`をバインディングする。
        // この場合、クレートスコープは一番外側のスコープである。
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# File hierarchy
-->
<h1 id="ファイルの階層構造"><a class="header" href="#ファイルの階層構造">ファイルの階層構造</a></h1>
<!--
Modules can be mapped to a file/directory hierarchy. Let's break down the
[visibility example][visibility] in files:
-->
<p>モジュールはファイル・ディレクトリ間の階層構造と対応関係にあります。モジュールに<a href="mod/visibility.html">お互いがどのように見えているか</a>、以下の様なファイルを例に詳しく見ていきましょう。</p>
<pre><code class="language-shell">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p>In <code>split.rs</code>:</p>
<pre><code class="language-rust ignore">// This declaration will look for a file named `my.rs` or `my/mod.rs` and will
// insert its contents inside a module named `my` under this scope
// このように宣言すると、`my.rs`または、`my/mod.rs`という名のファイルを探し、
// その内容をこのファイル中で`my`という名から使用することができるようにします。
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p>In <code>my/mod.rs</code>:</p>
<pre><code class="language-rust ignore">// Similarly `mod inaccessible` and `mod nested` will locate the `nested.rs`
// and `inaccessible.rs` files and insert them here under their respective
// modules
// 同様に`mod inaccessible`、`mod nested`によって、`nested.rs`、`inaccessible.rs`の内容をこの中で使用することができるようになる。
// 訳注: `pub`をつけないかぎり、この中でしか使用できない。
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p>In <code>my/nested.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p>In <code>my/inaccessible.rs</code>:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<!--
Let's check that things still work as before:
-->
<p>では、以前と同じように実行できるか確認しましょう。</p>
<pre><code class="language-shell">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Crates
-->
<h1 id="クレート"><a class="header" href="#クレート">クレート</a></h1>
<!--
A crate is a compilation unit in Rust. Whenever `rustc some_file.rs` is called,
`some_file.rs` is treated as the *crate file*. If `some_file.rs` has `mod`
declarations in it, then the contents of the module files would be inserted in
places where `mod` declarations in the crate file are found, *before* running
the compiler over it. In other words, modules do *not* get compiled
individually, only crates get compiled.
-->
<p>クレートはRustにおけるコンパイルの単位です。<code>rustc some_file.rs</code>が呼ばれると、<code>some_file.rs</code>は必ず <em>クレートファイル</em> として扱われます。もし<code>some_file.rs</code>が<code>mod</code>宣言を含んでいるのならば、コンパイルの <em>前に</em> 、そのモジュールファイルの中身が<code>mod</code>の位置に挿入されます。言い換えると、それぞれのモジュールが独立にコンパイルされるということはありませんが、それぞれのクレートは互いに独立にコンパイルされるということです。</p>
<!--
A crate can be compiled into a binary or into a library. By default, `rustc`
will produce a binary from a crate. This behavior can be overridden by passing
the `--crate-type` flag to `lib`.
-->
<p>クレートはバイナリあるいはライブラリ形式でコンパイルされることが可能です。デフォルトでは<code>rustc</code>はクレートからバイナリを作り出しますが、この振る舞いは<code>--crate-type</code>フラグに<code>lib</code>を渡すことでオーバーライドできます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Library
-->
<h1 id="ライブラリ"><a class="header" href="#ライブラリ">ライブラリ</a></h1>
<!--
Let's create a library, and then see how to link it to another crate.
-->
<p>ではライブラリを作成し、それを別のクレートにリンクする方法を見ていきましょう。</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<pre><code class="language-shell">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<!--
Libraries get prefixed with "lib", and by default they get named after their
crate file, but this default name can be overridden using the [`crate_name`
attribute][crate-name].
-->
<p>ライブラリは「lib」が頭につき、デフォルトでは、その後ろに元となったクレートファイル名をつけます。（訳注: ここでは<code>lib</code> + <code>rary</code>）この振る舞いは<a href="crates/../attribute/crate.html"><code>crate_name</code>アトリビュート</a>を用いてオーバーライドできます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-crate"><a class="header" href="#extern-crate"><code>extern crate</code></a></h1>
<!--
To link a crate to this new library, the `extern crate` declaration must be
used. This will not only link the library, but also import all its items under
a module named the same as the library. The visibility rules that apply to
modules also apply to libraries.
-->
<p>クレートをこの新しいライブラリにリンクするには、<code>extern crate</code>宣言を使用する必要があります。これはライブラリをリンクするだけでなく、その要素を全てライブラリと同じ名前のモジュールにインポートします。モジュールにおけるパブリック・プライベートなどのスコープのルールは全て、ライブラリにおいても当てはまります。</p>
<pre><code class="language-rust ignore">// Link to `library`, import items under the `rary` module
// `library`にリンクし、`rary`モジュール内の要素を全てインポートする。
extern crate rary;

fn main() {
    rary::public_function();

    // Error! `private_function` is private
    // エラー！`private_function`はプライベート
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-txt"># Where library.rlib is the path to the compiled library, assumed that it's
# in the same directory here:
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Cargo
-->
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<!--
`cargo` is the official Rust package management tool. It has lots of really
useful features to improve code quality and developer velocity! These include
-->
<p><code>cargo</code>はRustの公式パッケージ管理ツールです。とても便利な機能が多くあり、コードの品質や開発速度の向上に役立ちます。以下はその例です。</p>
<!--
- Dependency management and integration with [crates.io](https://crates.io) (the
  official Rust package registry)
- Awareness of unit tests
- Awareness of benchmarks
-->
<ul>
<li>依存関係の管理と<a href="https://crates.io">crates.io</a>（Rustの公式パッケージレジストリ）とのインテグレーション</li>
<li>ユニットテスト</li>
<li>ベンチマーク</li>
</ul>
<!--
This chapter will go through some quick basics, but you can find the
comprehensive docs in [The Cargo Book](https://doc.rust-lang.org/cargo/).
-->
<p>この章では、簡単な基本機能を説明します。包括的なドキュメントは<a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Dependencies
-->
<p>依存関係</p>
<!--
Most programs have dependencies on some libraries. If you have ever managed
dependencies by hand, you know how much of a pain this can be. Luckily, the Rust
ecosystem comes standard with `cargo`! `cargo` can manage dependencies for a
project.
-->
<p>ほとんどのプログラムはライブラリに依存関係を持ちます。もし依存関係を手動で管理したことがあれば、それがどれだけ苦痛であるか分かるでしょう。幸運なことに、Rustのエコシステムには<code>cargo</code>が標準装備されています！<code>cargo</code>によってプロジェクトの依存関係を管理することができます。</p>
<!--
To create a new Rust project,
-->
<p>Rustのプロジェクトを新しく作るには下記のようにします。</p>
<pre><code class="language-sh"># A binary
# バイナリ
cargo new foo

# OR A library
# またはライブラリ
cargo new --lib foo
</code></pre>
<!--
For the rest of this chapter, let's assume we are making a binary, rather than
a library, but all of the concepts are the same.
-->
<p>この章の残りでは、ライブラリではなくバイナリを作ることを想定しますが、コンセプトはすべて同じです。</p>
<!--
After the above commands, you should see a file hierarchy like this:
-->
<p>上のコマンドを実行すると、次のようなファイル階層ができます。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<!--
The `main.rs` is the root source file for your new project -- nothing new there.
The `Cargo.toml` is the config file for `cargo` for this project (`foo`). If you
look inside it, you should see something like this:
-->
<p><code>main.rs</code>がこの新規プロジェクトのルートのソースファイルです。なにも新しいことはありませんね。<code>Cargo.toml</code>はこのプロジェクト（<code>foo</code>）の<code>cargo</code>の設定ファイルです。中を見てみるとこのようになっています。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<!--
The `name` field under `[package]` determines the name of the project. This is
used by `crates.io` if you publish the crate (more later). It is also the name
of the output binary when you compile.
-->
<p><code>[package]</code>の下の<code>name</code>フィールドがプロジェクトの名前を決定します。これはクレートを公開するときに<code>crates.io</code>によって使われます（詳細は後述）。またコンパイルしたときの出力ファイルの名前でもあります。</p>
<!--
The `version` field is a crate version number using [Semantic
Versioning](http://semver.org/).
-->
<p><code>version</code>フィールドはクレートのバージョン番号で、<a href="http://semver.org/">セマンティックバージョニング</a>を使っています。</p>
<!--
The `authors` field is a list of authors used when publishing the crate.
-->
<p><code>authors</code>フィールドは作者のリストで、クレートを公開するときに使われます。</p>
<!--
The `[dependencies]` section lets you add dependencies for your project.
-->
<p><code>[dependencies]</code>セクションにはプロジェクトの依存関係を追加できます。</p>
<!--
For example, suppose that we want our program to have a great CLI. You can find
lots of great packages on [crates.io](https://crates.io) (the official Rust
package registry). One popular choice is [clap](https://crates.io/crates/clap).
As of this writing, the most recent published version of `clap` is `2.27.1`. To
add a dependency to our program, we can simply add the following to our
`Cargo.toml` under `[dependencies]`: `clap = "2.27.1"`.  And of course, `extern
crate clap` in `main.rs`, just like normal. And that's it! You can start using
`clap` in your program.
-->
<p>例えば、プログラムに素晴らしいCLIが欲しいとします。<a href="https://crates.io">crates.io</a>（Rustの公式パッケージレジストリ）には素晴らしいパッケージがたくさんあります。よくある選択肢の1つは<a href="https://crates.io/crates/clap">clap</a>です。この記事を書いている時点での<code>clap</code>の最新の公開バージョンは<code>2.27.1</code>です。依存関係をプログラムに追加するには、<code>Cargo.toml</code>の<code>[dependencies]</code>の下に<code>clap = &quot;2.27.1&quot;</code>と単に書き加えます。そしてもちろん、通常通り<code>main.rs</code>の中で<code>extern crate clap</code>とします。これだけです！<code>clap</code>をプログラム内で使用できます。</p>
<!--
`cargo` also supports [other types of dependencies][dependencies]. Here is just
a small sampling:
-->
<p><code>cargo</code>は<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">他の形式の依存関係</a>もサポートしています。その一部を示します。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # from crates.io
                # crates.ioから
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # from online repo
                                                             # オンラインのレポジトリから
bar = { path = &quot;../bar&quot; } # from a path in the local filesystem
                          # ローカルのファイルシステムのパスから
</code></pre>
<!--
`cargo` is more than a dependency manager. All of the available
configuration options are listed in the [format specification][manifest] of
`Cargo.toml`.
-->
<p><code>cargo</code>は依存管理ツール以上のこともできます。<code>Cargo.toml</code>の<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">format specification</a>に全ての設定オプションがリストアップされています。</p>
<!--
To build our project we can execute `cargo build` anywhere in the project
directory (including subdirectories!). We can also do `cargo run` to build and
run. Notice that these commands will resolve all dependencies, download crates
if needed, and build everything, including your crate. (Note that it only
rebuilds what it has not already built, similar to `make`).
-->
<p>プロジェクトをビルドするには、プロジェクトディレクトリのどこか（サブディレクトでも！）で<code>cargo build</code>を実行します。また<code>cargo run</code>でビルドと実行をできます。これらのコマンドは、全ての依存関係の解決、必要なクレートのダウンロード、自分のクレートを含む全てのビルドを行うことに注意してください。（<code>make</code>と同様、まだビルドしていないものだけをビルドします。）</p>
<!--
Voila! That's all there is to it!
-->
<p>Voila！これで完成です！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Conventions
-->
<h1 id="慣例"><a class="header" href="#慣例">慣例</a></h1>
<!--
In the previous chapter, we saw the following directory hierarchy:
-->
<p>前の章ではこのようなディレクトリ階層がありました。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<!--
Suppose that we wanted to have two binaries in the same project, though. What
then?
-->
<p>しかし同じプロジェクトで2つのバイナリが欲しいとします。その場合は？</p>
<!--
It turns out that `cargo` supports this. The default binary name is `main`, as
we saw before, but you can add additional binaries by placing them in a `bin/`
directory:
-->
<p><code>cargo</code>はこれもサポートしています。以前見た通りデフォルトのバイナリ名は<code>main</code>ですが、<code>bin/</code>ディレクトリに置くことで他のバイナリを追加できます。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<!--
To tell `cargo` to compile or run this binary as opposed to the default or other
binaries, we just pass `cargo` the `--bin my_other_bin` flag, where `my_other_bin`
is the name of the binary we want to work with.
-->
<p>デフォルトバイナリや他のバイナリではなく、このバイナリをコンパイルや実行するように<code>cargo</code>に伝えるには、<code>cargo</code>に<code>--bin my_other_bin</code>フラグを渡します。ここでは<code>my_other_bin</code>が対象のバイナリの名前です。</p>
<!--
In addition to extra binaries, `cargo` supports [more features] such as
benchmarks, tests, and examples.
-->
<p>バイナリの追加に加えて、<code>cargo</code>はベンチマークやテスト、サンプルなどの<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">その他の機能</a>もサポートしています。</p>
<!--
In the next chapter, we will look more closely at tests.
-->
<p>次の章ではテストについてより詳しく見ていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Testing
-->
<h1 id="テスト"><a class="header" href="#テスト">テスト</a></h1>
<!--
As we know testing is integral to any piece of software! Rust has first-class
support for unit and integration testing ([see this
chapter](https://doc.rust-lang.org/book/ch11-00-testing.html) in
TRPL).
-->
<p>知っての通り、テストはどんなソフトウェアにも不可欠です！Rustはユニットテストと統合テストを第一級にサポートしています（TRPLの<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">この章を参照してください</a>）。</p>
<!--
From the testing chapters linked above, we see how to write unit tests and
integration tests. Organizationally, we can place unit tests in the modules they
test and integration tests in their own `tests/` directory:
-->
<p>上のリンク先のテストの章では、ユニットテストと統合テストの書き方を紹介しています。ユニットテストはテスト対象のモジュール内に、統合テストは<code>tests/</code>ディレクトリ内に置きます。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<!--
Each file in `tests` is a separate integration test.
-->
<p><code>tests</code>内の各ファイルは個別の統合テストです。</p>
<!--
`cargo` naturally provides an easy way to run all of your tests!
-->
<p><code>cargo</code>は、全てのテストを簡単に実行する方法を提供します。</p>
<pre><code class="language-shell">$ cargo test
</code></pre>
<!--
You should see output like this:
-->
<p>出力はこのようになります。</p>
<pre><code class="language-shell">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
You can also run tests whose name matches a pattern:
-->
<p>パターンにマッチする名前のテストを実行することもできます。</p>
<pre><code class="language-shell">$ cargo test test_foo
</code></pre>
<pre><code class="language-shell">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<!--
One word of caution: Cargo may run multiple tests concurrently, so make sure
that they don't race with each other. For example, if they all output to a
file, you should make them write to different files.
-->
<p>注意：Cargoは複数のテストを並列で実行することがありますので、それらが互いに競合しないようにしてください。例えば、それらが全てファイルに出力する場合、それぞれ別のファイルに書き込むようにします。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Build Scripts
-->
<h1 id="ビルドスクリプト"><a class="header" href="#ビルドスクリプト">ビルドスクリプト</a></h1>
<!--
Sometimes a normal build from `cargo` is not enough. Perhaps your crate needs
some pre-requisites before `cargo` will successfully compile, things like code
generation, or some native code that needs to be compiled. To solve this problem
we have build scripts that Cargo can run.
-->
<p><code>cargo</code>による通常のビルドでは十分でないことが時々あります。コード生成や、コンパイルが必要なネイティブコードなど、<code>cargo</code>がクレートをうまくコンパイルするにはなんらかの前提条件が必要かもしれません。この問題を解決するため、Cargoが実行できるビルドスクリプトがあります。</p>
<!--
To add a build script to your package it can either be specified in the
`Cargo.toml` as follows:
-->
<p>ビルドスクリプトをパッケージに追加するには、以下のように<code>Cargo.toml</code>の中で指定できます。</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<!--
Otherwise Cargo will look for a `build.rs` file in the project directory by
default.
-->
<p>それ以外の場合、Cargoはデフォルトでプロジェクトディレクトリから<code>build.rs</code>を探します。</p>
<!--
## How to use a build script
-->
<h2 id="ビルドスクリプトの使い方"><a class="header" href="#ビルドスクリプトの使い方">ビルドスクリプトの使い方</a></h2>
<!--
The build script is simply another Rust file that will be compiled and invoked
prior to compiling anything else in the package. Hence it can be used to fulfill
pre-requisites of your crate.
-->
<p>ビルドスクリプトは単にRustのファイルの1つで、パッケージ内の他のファイルをコンパイルする前にコンパイルされて起動されます。そのため、クレートの前提条件を満たすために使用できます。</p>
<!--
Cargo provides the script with inputs via environment variables [specified
here] that can be used.
-->
<p>Cargoは、<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">ここで指定された</a>環境変数を介してスクリプトに入力を与えます。</p>
<!--
The script provides output via stdout. All lines printed are written to
`target/debug/build/<pkg>/output`. Further, lines prefixed with `cargo:` will be
interpreted by Cargo directly and hence can be used to define parameters for the
package's compilation.
-->
<p>スクリプトは標準出力に出力します。出力される行は全て、<code>target/debug/build/&lt;pkg&gt;/output</code>に書き込まれます。さらに、行頭に<code>cargo:</code>がついた行はCargoに直接解釈されるため、パッケージのコンパイル時のパラメーターを定義するのに使用できます。</p>
<!--
For further specification and examples have a read of the
[Cargo specification][cargo_specification].
-->
<p>より詳細な仕様や例については、<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Cargo specification</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Attributes
-->
<h1 id="アトリビュート"><a class="header" href="#アトリビュート">アトリビュート</a></h1>
<!--
An attribute is metadata applied to some module, crate or item. This metadata
can be used to/for:
-->
<p>アトリビュートはモジュール、クレート、要素に対するメタデータです。以下がその使用目的です。</p>
<!--
* [conditional compilation of code][cfg]
* [set crate name, version and type (binary or library)][crate]
* disable [lints][lint] (warnings)
* enable compiler features (macros, glob imports, etc.)
* link to a foreign library
* mark functions as unit tests
* mark functions that will be part of a benchmark
-->
<ul>
<li><a href="attribute/cfg.html">コンパイル時の条件分岐</a></li>
<li><a href="attribute/crate.html">クレート名、バージョン、種類（バイナリか、ライブラリか）の設定</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lint_%28software%29">リント</a>の無効化</li>
<li>コンパイラ付属の機能（マクロ、グロブ、インポートなど）の使用</li>
<li>外部ライブラリへのリンク</li>
<li>ユニットテスト用の関数を明示</li>
<li>ベンチマーク用の関数を明示</li>
</ul>
<!--
When attributes apply to a whole crate, their syntax is `#![crate_attribute]`,
and when they apply to a module or item, the syntax is `#[item_attribute]`
(notice the missing bang `!`).
-->
<p>アトリビュートがクレート全体に適用される場合、<code>#![crate_attribute]</code>という書き方になります。モジュールないしは要素に適用される場合は<code>#[item_attribute]</code>になります。（<code>!</code>がないことに注目）</p>
<!--
Attributes can take arguments with different syntaxes:
-->
<p>アトリビュートは以下の様な書き方で引数を取ることができます。</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Attributes can have multiple values and can be separated over multiple lines, too:</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dead_code"><a class="header" href="#dead_code"><code>dead_code</code></a></h1>
<!--
The compiler provides a `dead_code`
[*lint*][lint] that will warn
about unused functions. An *attribute* can be used to disable the lint.
-->
<p>コンパイラは<code>dead_code</code>と呼ばれる<a href="https://en.wikipedia.org/wiki/Lint_%28software%29">リント</a>機能を持つため、使用されていない関数が存在するときに警告を出します。 <em>アトリビュート</em> によってこの機能を無効化することができます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` is an attribute that disables the `dead_code` lint
// `#[allow(dead_code)]`は`dead_code`リントを抑制するアトリビュートです。
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// FIXME ^ Add an attribute to suppress the warning
// FIXME ^ 警告を抑制するアトリビュートを追加しましょう。

fn main() {
    used_function();
}
</code></pre></pre>
<!--
Note that in real programs, you should eliminate dead code. In these examples
we'll allow dead code in some places because of the interactive nature of the
examples.
-->
<p>実際のコード中では、使用されていないコードが有る場合はそれを除外するべきです。この文書中では随所でアトリビュートによって警告を抑制していますが、それはあくまでインタラクティブな例を皆さんに提供するためです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Crates
-->
<h1 id="クレート-1"><a class="header" href="#クレート-1">クレート</a></h1>
<!--
The `crate_type` attribute can be used to tell the compiler whether a crate is
a binary or a library (and even which type of library), and the `crate_name`
attribute can be used to set the name of the crate.
-->
<p><code>crate_type</code>アトリビュートは、そのクレートがライブラリ、バイナリのいずれにコンパイルされるべきかをコンパイラに伝えるために使用します。ライブラリの場合は、どのタイプのライブラリであるかも伝えることができます。<code>crate_name</code>はクレートの名前を決定するのに使用します。</p>
<p>However, it is important to note that both the <code>crate_type</code> and <code>crate_name</code>
attributes have <strong>no</strong> effect whatsoever when using Cargo, the Rust package
manager. Since Cargo is used for the majority of Rust projects, this means
real-world uses of <code>crate_type</code> and <code>crate_name</code> are relatively limited.</p>
<pre><pre class="playground"><code class="language-rust editable">// This crate is a library
// このクレートはライブラリである。
#![crate_type = &quot;lib&quot;]
// The library is named &quot;rary&quot;
// このライブラリの名前は「rary」である。
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<!--
When the `crate_type` attribute is used, we no longer need to pass the
`--crate-type` flag to `rustc`.
-->
<p><code>crate_type</code>アトリビュートが使用されているときは、<code>rustc</code>に<code>--crate-type</code>フラグを伝える必要はありません。</p>
<pre><code class="language-shell">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cfg"><a class="header" href="#cfg"><code>cfg</code></a></h1>
<!--
Conditional compilation is possible through two different operators:
-->
<p>環境に応じたコンパイルをするには2種類の方法があります。</p>
<!--
* the `cfg` attribute: `#[cfg(...)]` in attribute position
* the `cfg!` macro: `cfg!(...)` in boolean expressions
-->
<ul>
<li><code>cfg</code>アトリビュート: <code>#[cfg(...)]</code>をアトリビュートとして使用する。</li>
<li><code>cfg!</code>マクロ: <code>cfg!(...)</code>をブーリアンとして評価する。</li>
</ul>
<!--
Both utilize identical argument syntax.
-->
<p>いずれの場合も適切なシンタックスで記述する必要があります。</p>
<pre><pre class="playground"><code class="language-rust editable">// This function only gets compiled if the target OS is linux
// この関数はターゲットOSがLinuxの時のみコンパイルされる。
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;);
}

// And this function only gets compiled if the target OS is *not* linux
// そしてこの関数はターゲットOSがLinux *ではない* ときのみコンパイルされる。
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;);
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-30"><a class="header" href="#参照-30">参照</a></h3>
<!--
[the reference][ref], [`cfg!`][cfg], and [macros][macros].
-->
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">参照(<code>reference</code>)</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, <a href="attribute/../macros.html">マクロ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Custom
-->
<h1 id="条件の追加"><a class="header" href="#条件の追加">条件の追加</a></h1>
<!--
Some conditionals like `target_os` are implicitly provided by `rustc`, but
custom conditionals must be passed to `rustc` using the `--cfg` flag.
-->
<p><code>target_os</code>のように、いくつかの条件分岐は<code>rustc</code>が暗黙のうちに提供しています。条件を独自に追加する場合には<code>--cfg</code>フラグを用いて<code>rustc</code>に伝える必要があります。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>Try to run this to see what happens without the custom <code>cfg</code> flag.</p>
<!--
With the custom `cfg` flag:
-->
<p><code>cfg</code>フラグがある場合:</p>
<pre><code class="language-shell">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Generics
-->
<h1 id="ジェネリクス"><a class="header" href="#ジェネリクス">ジェネリクス</a></h1>
<!--
*Generics* is the topic of generalizing types and functionalities to broader
cases. This is extremely useful for reducing code duplication in many ways,
but can call for rather involving syntax. Namely, being generic requires 
taking great care to specify over which types a generic type 
is actually considered valid. The simplest and most common use of generics 
is for type parameters.
-->
<p>ジェネリクスとは、型と関数の機能をより汎用的に使えるようにするための機能です。これはあらゆる局面でコードの重複を避けるために非常に役立ちますが、多少構文が複雑になります。すなわち、ジェネリック型を使いこなすには、どのようなジェネリック型がきちんと機能するかに細心の注意を払う必要があります。
The simplest and most common use of generics is for type parameters.</p>
<!--
A type parameter is specified as generic by the use of angle brackets and upper
[camel case][camelcase]: `<Aaa, Bbb, ...>`. "Generic type parameters" are
typically represented as `<T>`. In Rust, "generic" also describes anything that
accepts one or more generic type parameters `<T>`. Any type specified as a 
generic type parameter is generic, and everything else is concrete (non-generic).
-->
<p>ジェネリック型の型パラメータにはかぎ括弧(<code>angle brackets</code>)とアッパー<a href="https://en.wikipedia.org/wiki/CamelCase">キャメルケース(<code>camel case</code>)</a>が使われます。: <code>&lt;Aaa, Bbb, ...&gt;</code>ジェネリックな型パラメータはたいていの場合<code>&lt;T&gt;</code>で示されます。Rustの場合、「ジェネリクス」には「１つ以上のジェネリックな型パラメータ<code>&lt;T&gt;</code>を受け付けるもの」という意味もあります。ジェネリックな型パラメータを指定された場合、それは必ずジェネリック型になり、そうでなければ必ず非ジェネリック型、すなわち具象型(<code>concrete</code>)になります。</p>
<!--
For example, defining a *generic function* named `foo` that takes an argument
`T` of any type:
-->
<p>例として、あらゆる型の引数<code>T</code>をとる <em>ジェネリック関数</em> <code>foo</code>を定義すると:</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<!--
Because `T` has been specified as a generic type parameter using `<T>`, it 
is considered generic when used here as `(arg: T)`. This is the case even if `T` 
has previously been defined as a `struct`.
-->
<p>となります。<code>T</code>はジェネリックな型パラメータに指定されているので、この場所で<code>(arg: T)</code>のように使用するとジェネリック型として扱われます。これは<code>T</code>という構造体がそれ以前に定義されていても同様です。</p>
<!--
This example shows some of the syntax in action:
-->
<p>では、手を動かしながらジェネリック型の構文を体験していきましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">// A concrete type `A`.
// `A`という具象型
struct A;

// In defining the type `Single`, the first use of `A` is not preceded by `&lt;A&gt;`.
// Therefore, `Single` is a concrete type, and `A` is defined as above.
// `Single`という型を定義する際に`A`を使用しているが、その最初の使用よりも
// 先に`&lt;A&gt;`がないため、また、`A`自身も具象型であるため、`Single`は具象型となる。
struct Single(A);
//            ^ Here is `Single`s first use of the type `A`.
//            ^ Singleによる`A`の一番最初の使用はここ

// Here, `&lt;T&gt;` precedes the first use of `T`, so `SingleGen` is a generic type.
// Because the type parameter `T` is generic, it could be anything, including
// the concrete type `A` defined at the top.
// ここでは`&lt;T&gt;`が一番初めの`T`の使用よりも先に来ている。よって`SingleGen`はジェネリック型
// となる。なぜならば型パラメータ`T`がジェネリックだからである。`T`はどんな型にもなりえるため、
// 上で定義した`A`を受け取ることもできる。
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` is concrete and explicitly takes `A`.
    // `Single`は具象型で、`A`のみを受け取る。
    let _s = Single(A);
    
    // Create a variable `_char` of type `SingleGen&lt;char&gt;`
    // and give it the value `SingleGen('a')`.
    // Here, `SingleGen` has a type parameter explicitly specified.
    // `_char`という名の変数を生成する。これは`SingleGen&lt;char&gt;`
    // という型で、値は`SingleGen('a')`となる。ここでは、`SingleGen`には明示的な型パラメータ
    // が与えられている。
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` can also have a type parameter implicitly specified:
    // `SingleGen`型の変数には明示的に型パラメータを与えなくてもよい。
    let _t    = SingleGen(A); // Uses `A` defined at the top.
                              // 上で定義した`A`を使用
    let _i32  = SingleGen(6); // Uses `i32`.
                              // `i32`を使用
    let _char = SingleGen('a'); // Uses `char`.
                                // `char`を使用
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-31"><a class="header" href="#参照-31">参照</a></h3>
<!--
[`struct`s][structs]
-->
<p><a href="custom_types/structs.html">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Functions
-->
<h1 id="関数-1"><a class="header" href="#関数-1">関数</a></h1>
<!--
The same set of rules can be applied to functions: a type `T` becomes
generic when preceded by `<T>`.
-->
<p>「型<code>T</code>はその前に<code>&lt;T&gt;</code>があるとジェネリック型になる」というルールは関数に対しても当てはまります。</p>
<!--
Using generic functions sometimes requires explicitly specifying type 
parameters. This may be the case if the function is called where the return type 
is generic, or if the compiler doesn't have enough information to infer 
the necessary type parameters.
-->
<p>ジェネリック関数を使用する際、以下の様な場合には型パラメータを明示する必要があります。</p>
<ul>
<li>返り値がジェネリック型である場合。</li>
<li>コンパイラが型パラメータを推論するのに十分な情報がない場合</li>
</ul>
<!--
A function call with explicitly specified type parameters looks like:
`fun::<A, B, ...>()`.
-->
<p>型パラメータを明示したうえでの関数呼び出しの構文は<code>fun::&lt;A, B, ...&gt;()</code>のようになります。</p>
<pre><pre class="playground"><code class="language-rust editable">struct A;          // Concrete type `A`.
                   // 具象型`A`.
struct S(A);       // Concrete type `S`.
                   // 具象型`S`.
struct SGen&lt;T&gt;(T); // Generic type `SGen`.
                   // ジェネリック型`SGen`.

// The following functions all take ownership of the variable passed into
// them and immediately go out of scope, freeing the variable.
// 以下の関数は全て変数の所有権をとった後すぐにスコープを抜けて
// 変数をメモリ上から開放する。

// Define a function `reg_fn` that takes an argument `_s` of type `S`.
// This has no `&lt;T&gt;` so this is not a generic function.
// `S`という型の引数`_s`をとる`reg_fn`という関数を定義
// `&lt;T&gt;`がないのでジェネリック関数ではない
fn reg_fn(_s: S) {}

// Define a function `gen_spec_t` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// It has been explicitly given the type parameter `A`, but because `A` has not 
// been specified as a generic type parameter for `gen_spec_t`, it is not generic.
// `gen_spec_t`という関数を定義。これは`A`という型を与えられた`Sgen&lt;T&gt;`
// という型の引数`_s`を取る。関数名の直後に`&lt;A&gt;`という型パラメータでAが
// ジェネリックであることを明示していないので、この関数はAをジェネリック型
// としては取らない
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Define a function `gen_spec_i32` that takes an argument `_s` of type `SGen&lt;i32&gt;`.
// It has been explicitly given the type parameter `i32`, which is a specific type.
// Because `i32` is not a generic type, this function is also not generic.
// `gen_spec_i32`という関数を定義。
// これは明示的な型パラメータとして`i32`を与えられた`Sgen&lt;i32&gt;`型の引数`_s`をとる
// この関数もジェネリックではない
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Define a function `generic` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// Because `SGen&lt;T&gt;` is preceded by `&lt;T&gt;`, this function is generic over `T`.
// `generic`という関数を定義。`SGen&lt;T&gt;`という型の引数`_s`を取る。`&lt;T&gt;`が`SGen&lt;T&gt;`に
// 先行しているため、これはTに対してジェネリックな関数
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Using the non-generic functions
    // ジェネリックでない関数を使用する
    reg_fn(S(A));          // Concrete type.
                           // 具象型
    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
                           // 型パラメータ`A`を暗黙のうちに受け取る
    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.
                           // 型パラメータ`i32`を暗黙のうちに受け取る

    // Explicitly specified type parameter `char` to `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Implicitly specified type parameter `char` to `generic()`.
    // 型パラメータ`char`を暗黙的に`generic()`に渡す
    generic(SGen('c'));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-32"><a class="header" href="#参照-32">参照</a></h3>
<!--
[functions][fn] and [`struct`s][structs]
-->
<p><a href="generics/../fn.html">関数</a>, <a href="generics/../custom_types/structs.html">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Implementation
-->
<h1 id="メソッド-1"><a class="header" href="#メソッド-1">メソッド</a></h1>
<!--
Similar to functions, implementations require care to remain generic.
-->
<p>関数と同様、<code>impl</code>でメソッドを実装する際にもジェネリック型特有の記法が必要です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // Concrete type `S`
          // 具象型`S`
struct GenericVal&lt;T&gt;(T); // Generic type `GenericVal`
                         // ジェネリック型`GenericVal`

// impl of GenericVal where we explicitly specify type parameters:
// 型パラメータを指定したうえで、GenericValにメソッドを実装
impl GenericVal&lt;f32&gt; {} // Specify `f32`
                        // `f32`の場合のメソッド
impl GenericVal&lt;S&gt; {} // Specify `S` as defined above
                      // 上で定義した`S`への実装

// `&lt;T&gt;` Must precede the type to remain generic
// ジェネリック型のまま扱うには`&lt;T&gt;`が先に来る必要がある。
impl&lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">struct Val {
    val: f64,
}

struct GenVal&lt;T&gt; {
    gen_val: T,
}

// impl of Val
// Valに対してimpl
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}

// impl of GenVal for a generic type `T`
// ジェネリック型`T`の場合のメソッドをGenValに対して実装
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-33"><a class="header" href="#参照-33">参照</a></h3>
<!--
[functions returning references][fn], [`impl`][methods], and [`struct`][structs]
-->
<p><a href="generics/../scope/lifetime/fn.html">参照を返す関数</a>, <a href="generics/../fn/methods.html"><code>impl</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Traits
-->
<h1 id="ジェネリックトレイト"><a class="header" href="#ジェネリックトレイト">ジェネリックトレイト</a></h1>
<!--
Of course `trait`s can also be generic. Here we define one which reimplements
the `Drop` `trait` as a generic method to `drop` itself and an input.
-->
<p>もちろんトレイトもジェネリクスを活用することができます。ここでは<code>Drop</code>トレイトをジェネリックメソッドとして再実装し、自身と引数として受け取った値の両方を<code>drop</code>するようなメソッドにします。</p>
<pre><pre class="playground"><code class="language-rust editable">// Non-copyable types.
// コピー不可な型
// 訳注: `clone()`メソッドを用いないかぎり、値のコピーではなくムーブが起きる型
struct Empty;
struct Null;

// A trait generic over `T`.
// ジェネリック型 `T`に対するトレイト
trait DoubleDrop&lt;T&gt; {
    // Define a method on the caller type which takes an
    // additional single parameter `T` and does nothing with it.
    // `self`に加えてもう一つジェネリック型を受け取り、
    // 何もしないメソッドのシグネチャを定義
    fn double_drop(self, _: T);
}

// Implement `DoubleDrop&lt;T&gt;` for any generic parameter `T` and
// caller `U`.
// `U`を`self`として、`T`をもう一つの引数として受け取る`DoubleDrop&lt;T&gt;`
// を実装する。`U`,`T`はいずれもジェネリック型
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // This method takes ownership of both passed arguments,
    // deallocating both.
    // このメソッドは2つの引数の所有権を取り、メモリ上から開放する。
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    // `empty`と`null`を開放
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: Try uncommenting these lines.
    // ^ TODO: これらの行をアンコメントしてみましょう。
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-34"><a class="header" href="#参照-34">参照</a></h3>
<!--
[`Drop`][Drop], [`struct`][structs], and [`trait`][traits]
-->
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="generics/../custom_types/structs.html">構造体(<code>struct</code>)</a>, <a href="generics/../trait.html">トレイト(<code>trait</code>)</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Bounds
-->
<h1 id="ジェネリック境界"><a class="header" href="#ジェネリック境界">ジェネリック境界</a></h1>
<!--
When working with generics, the type parameters often must use traits as *bounds* to
stipulate what functionality a type implements. For example, the following
example uses the trait `Display` to print and so it requires `T` to be bound
by `Display`; that is, `T` *must* implement `Display`.
-->
<p>ジェネリックプログラミングをしていると、型パラメータが特定の機能を持っていることを規定するため、トレイトに境界(<code>bound</code>)を設ける必要があることがよくあります。例えば、以下の例では、引数の<code>Display</code>トレイトを用いてプリントを行うため、<code>T</code>が<code>Display</code>を持っていることを規定しています。つまり、「<code>T</code>は<code>Display</code>を実装 <em>していなくてはならない</em> 」という意味です。</p>
<pre><code class="language-rust ignore">// Define a function `printer` that takes a generic type `T` which
// must implement trait `Display`.
// `Display`トレイトを実装している`T`を引数として取る
// `printer`という関数を定義。
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<!--
Bounding restricts the generic to types that conform to the bounds. That is:
-->
<p>境界は、ジェネリクスを全ての型ではなく、一定条件を満たす型に対してのみ適用するためにあります。つまり</p>
<blockquote>
<p>訳注: <code>&lt;T: Display&gt;</code>は<code>&lt;T&gt;</code>の部分集合であることを意識すると、「境界」という言葉の意味がしっくり来ると思います。</p>
</blockquote>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// Error! `Vec&lt;T&gt;` does not implement `Display`. This
// specialization will fail.
// エラー! `Vec&lt;T&gt;`は`Display`を実装していないため、この特殊化
// は失敗します。
let s = S(vec![1]);
</code></pre>
<!--
Another effect of bounding is that generic instances are allowed to access the 
[methods] of traits specified in the bounds. For example:
-->
<p>境界のもう一つの効果は、ジェネリック型のインスタンスが、境界条件となるトレイトの<a href="generics/../fn/methods.html">メソッド</a>にアクセスすることができるようになる点です。以下がその例です。</p>
<pre><pre class="playground"><code class="language-rust editable">// A trait which implements the print marker: `{:?}`.
// プリント時のマーカー`{:?}`を実装するトレイト
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// The generic `T` must implement `Debug`. Regardless
// of the type, this will work properly.
// ジェネリック型`T`は`Debug`トレイトを実装していなくてはならない。
// その限りにおいて、`T`がどのような具象型であろうとも次の関数は動作する。
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` must implement `HasArea`. Any type which meets
// the bound can access `HasArea`'s function `area`.
// 「`T`は`HasArea`を実装していなくてはならない」という境界条件を
// 満たしていれば、`HasArea`の関数`area`にアクセスできる。
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: Try uncommenting these.
    // | Error: Does not implement either `Debug` or `HasArea`. 
    // ^ TODO: これらの行をアンコメントしてみましょう。
    // | Error: `Debug` も `HasArea`もどちらも実装されていません!
}
</code></pre></pre>
<!--
As an additional note, [`where`][where] clauses can also be used to apply bounds in
some cases to be more expressive.
-->
<p>付け加えておくと、<a href="generics/../generics/where.html"><code>where</code></a>句を用いて境界を適用することもできます。場合によってはこちらの記法を使用したほうが読みやすくなる場合もあります。</p>
<!--
### See also:
-->
<h3 id="参照-35"><a class="header" href="#参照-35">参照</a></h3>
<!--
[`std::fmt`][fmt], [`struct`s][structs], and [`trait`s][traits]
-->
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a>, <a href="generics/../custom_types/structs.html">構造体(<code>struct</code>)</a>, <a href="generics/../trait.html">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Testcase: empty bounds
-->
<h1 id="テストケース-空トレイト"><a class="header" href="#テストケース-空トレイト">テストケース: 空トレイト</a></h1>
<!--
A consequence of how bounds work is that even if a `trait` doesn't
include any functionality, you can still use it as a bound. `Eq` and
`Ord` are examples of such `trait`s from the `std` library.
-->
<p>トレイト境界の仕組みから、「トレイトがなにも機能を持っていなくとも境界条件として使用できることには変わりはない」という帰結がもたらされます。<code>Eq</code>と<code>Ord</code>は<code>std</code>ライブラリにおけるそのような例です。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// These functions are only valid for types which implement these
// traits. The fact that the traits are empty is irrelevant.
// 以下の関数はトレイト境界を設けているが、そのトレイトが空である
// か否かとは関係がない。
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    // 訳注: 以下は全て鳥の名前
    // 猩々紅冠鳥
    let cardinal = Cardinal;
    // アオカケス
    let blue_jay = BlueJay;
    // 七面鳥
    let _turkey   = Turkey;

    // `red()` won't work on a blue jay nor vice versa
    // because of the bounds.
    // トレイト境界のため、`red`は`blue_jay`に対しては使用できない。
    // `blue`と`Cardinal`も同様、
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ TODO: Try uncommenting this line.
    // ^ TODO: この行をアンコメントしてみましょう。
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-36"><a class="header" href="#参照-36">参照</a></h3>
<!--
[`std::cmp::Eq`][eq], [`std::cmp::Ord`s][ord], and [`trait`s][traits]
-->
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code>s</a>, <a href="generics/bounds/../../trait.html">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Multiple bounds
-->
<h1 id="複数のジェネリック境界"><a class="header" href="#複数のジェネリック境界">複数のジェネリック境界</a></h1>
<!--
Multiple bounds can be applied with a `+`. Like normal, different types are
separated with `,`.
-->
<p><code>+</code>を用いて複数のトレイト境界を設けることができます。複数の引数を受け取るときは、通常時と同様、<code>,</code>で区切ります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}`&quot;, t);
    println!(&quot;u: `{:?}`&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // TODO ^ Try uncommenting this.
    // TODO ^ ここをアンコメントしてみましょう。

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-37"><a class="header" href="#参照-37">参照</a></h3>
<!--
[`std::fmt`][fmt] and [`trait`s][traits]
-->
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a>, <a href="generics/../trait.html">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Where clauses
-->
<h1 id="where句"><a class="header" href="#where句">Where句</a></h1>
<!--
A bound can also be expressed using a `where` clause immediately
before the opening `{`, rather than at the type's first mention. 
Additionally, `where` clauses can apply bounds to arbitrary types, 
rather than just to type parameters.
-->
<p>トレイト境界は、<code>{</code>の直前に<code>where</code>句を導入することでも設けることができます。<code>where</code>はさらに、型パラメータだけでなく任意の型に対してのみ適用できます。</p>
<!--
Some cases that a `where` clause is useful:
-->
<p><code>where</code>句のほうが有効なケースには例えば</p>
<!--
* When specifying generic types and bounds separately is clearer:
-->
<ul>
<li>ジェネリック型とジェネリック境界に別々に制限を加えたほうが明瞭になる場合
つまり、</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
// `where`を用いてジェネリック境界を設ける。
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<!--
* When using a `where` clause is more expressive than using normal syntax. 
The `impl` in this example cannot be directly expressed without a `where` clause:
-->
<ul>
<li><code>where</code>句の方が通常の構文より表現力が高い場合</li>
</ul>
<p>があります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Because we would otherwise have to express this as `T: Debug` or 
// use another method of indirect approach, this requires a `where` clause:
// `where`句を用いない場合、以下と等価な機能を実装するには、
// `&lt;T: Debug&gt;`という形で表現するか、別の直接的でない方法
// を使用するかしなくてはならない。
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // We want `Option&lt;T&gt;: Debug` as our bound because that is what's
    // being printed. Doing otherwise would be using the wrong bound.
    // プリントされるのが`Some(self)`であるため、この関数の
    // ジェネリック境界として`Option&lt;T&gt;: Debug`を使用したい。
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-38"><a class="header" href="#参照-38">参照</a></h3>
<!--
[RFC][where], [`struct`][struct], and [`trait`][trait]
-->
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="generics/../custom_types/structs.html">構造体</a>, <a href="generics/../trait.html">トレイト</a>, <a href="http://qiita.com/tatsuya6502/items/cd41599291e2e5f38a4a">エラーハンドリングの日本語による解説記事</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-type-idiom"><a class="header" href="#new-type-idiom">New Type Idiom</a></h1>
<p>The <code>newtype</code> idiom gives compile time guarantees that the right type of value is supplied
to a program.</p>
<p>For example, an age verification function that checks age in years, <em>must</em> be given
a value of type <code>Years</code>.</p>
<pre><pre class="playground"><code class="language-rust  editable">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// truncates partial years
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>Uncomment the last print statement to observe that the type supplied must be <code>Years</code>.</p>
<p>To obtain the <code>newtype</code>'s value as the base type, you may use tuple syntax like so:</p>
<pre><pre class="playground"><code class="language-rust  editable">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive: i64 = years.0;
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-39"><a class="header" href="#参照-39">参照</a></h3>
<p><a href="generics/../custom_types/structs.html"><code>structs</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Associated items
-->
<h1 id="関連型"><a class="header" href="#関連型">関連型</a></h1>
<!--
"Associated Items" refers to a set of rules pertaining to [`item`][items]s
of various types. It is an extension to `trait` generics, and allows 
`trait`s to internally define new items.
-->
<p>関連要素(Associated Items)とは複数の型の<a href="https://doc.rust-lang.org/reference/items.html">要素(items)</a>に関係のある規則の総称です。トレイトの拡張機能であり、トレイトの中で新しい要素を定義することを可能にします。</p>
<!--
One such item is called an *associated type*, providing simpler usage 
patterns when the `trait` is generic over its container type.
-->
<p>そのように定義する要素の一つに <strong>関連型</strong> があります。これにより、ジェネリックなコンテナ型に対するトレイトを使用する際に、よりシンプルな書き方ができるようになります。</p>
<!--
### See also:
-->
<h3 id="参照-40"><a class="header" href="#参照-40">参照</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# The Problem
-->
<h1 id="関連型が必要になる状況"><a class="header" href="#関連型が必要になる状況">関連型が必要になる状況</a></h1>
<!--
A `trait` that is generic over its container type has type specification
requirements - users of the `trait` *must* specify all of its generic types.
-->
<p>コンテナ型に、その要素に対してジェネリックなトレイトを実装した場合、そのトレイトを使用する者は全てのジェネリック型を明記 <em>しなくてはなりません</em> 。</p>
<!--
In the example below, the `Contains` `trait` allows the use of the generic 
types `A` and `B`. The trait is then implemented for the `Container` type, 
specifying `i32` for `A` and `B` so that it can be used with `fn difference()`.
-->
<p>以下の例では<code>Contains</code>トレイトはジェネリック型<code>A</code>と<code>B</code>の使用を許しています。その後、<code>Container</code>型に対して<code>Contains</code>を実装していますが、その際後に<code>fn difference()</code>が使用できるように、<code>A</code>、<code>B</code>はそれぞれ<code>i32</code>と明記されています。</p>
<!--
Because `Contains` is generic, we are forced to explicitly state *all* of the 
generic types for `fn difference()`. In practice, we want a way to express that 
`A` and `B` are determined by the *input* `C`. As you will see in the next 
section, associated types provide exactly that capability.
-->
<p><code>Contains</code>はジェネリックトレイトなので、<code>fn difference()</code>では <strong>全ての</strong> ジェネリック型を宣言しなくてはなりません。実際のところ、<code>A</code>と<code>B</code>は <strong>引数</strong> である<code>C</code>によって決定されていて欲しいにも関わらず、です。これは次のページで紹介する関連型と呼ばれる機能によって可能です。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
// ２つの要素がコンテナ型の中にあることをチェックするトレイト
// また、最初と最後の値を取得することもできる
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // Explicitly requires `A` and `B`.
                                              // `A`と`B`の両方を明示的に要求する
    fn first(&amp;self) -&gt; i32; // Doesn't explicitly require `A` or `B`.
                            // `A`、`B`いずれも要求しない
    fn last(&amp;self) -&gt; i32;  // Doesn't explicitly require `A` or `B`.
                            // `A`、`B`いずれも要求しない
}

impl Contains&lt;i32, i32&gt; for Container {
    // True if the numbers stored are equal.
    // コンテナ内の２つの要素が等しければTrueを返す
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // Grab the first number.
    // ひとつ目の値を取得
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    // 最後（2つめ）の値を取得
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C` contains `A` and `B`. In light of that, having to express `A` and
// `B` again is a nuisance.
// `A`と`B`は`C`に保持されていることを考慮すると、`A`と`B`を
// ２度も書くのは面倒
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-41"><a class="header" href="#参照-41">参照</a></h3>
<!--
[`struct`s][structs], and [`trait`s][traits]
-->
<p><a href="generics/assoc_items/../../custom_types/structs.html">構造体</a>, <a href="generics/assoc_items/../../trait.html">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Associated types
-->
<h1 id="関連型-1"><a class="header" href="#関連型-1">関連型</a></h1>
<!--
The use of "Associated types" improves the overall readability of code 
by moving inner types locally into a trait as *output* types. Syntax
for the `trait` definition is as follows:
-->
<p>関連型を使用すると、コンテナ型の中の要素をトレイトの中に <em>出力型</em> として書くことで、全体の可読性を上げることができます。トレイトを定義する際の構文は以下のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `A` and `B` are defined in the trait via the `type` keyword.
// (Note: `type` in this context is different from `type` when used for
// aliases).
// `A`と`B`は`type`キーワードを用いてトレイト内で宣言されている。
// (注意: この文脈で使用する`type`は型エイリアスを宣言する際の`type`とは
// 異なることに注意しましょう。)
trait Contains {
    type A;
    type B;

    // Updated syntax to refer to these new types generically.
    // これらの新しい型をジェネリックに使用するために、構文が
    // アップデートされています。
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<!--
Note that functions that use the `trait` `Contains` are no longer required
to express `A` or `B` at all:
-->
<p><code>Contains</code>トレイトを使用する関数において、<code>A</code>と<code>B</code>を明示する必要がなくなっていることに注目しましょう。</p>
<pre><code class="language-rust ignore">// Without using associated types
// 関連型を使用しない場合
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// Using associated types
// 使用する場合
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<!--
Let's rewrite the example from the previous section using associated types:
-->
<p>前セクションの例を関連型を使用して書きなおしてみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
// 2つの要素がコンテナ型の中に保持されていることを確認するトレイト。
// また、最初あるいは最後の要素を取り出すこともできる。
trait Contains {
    // Define generic types here which methods will be able to utilize.
    // メソッドが使用できるジェネリック型を定義
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // Specify what types `A` and `B` are. If the `input` type
    // is `Container(i32, i32)`, the `output` types are determined
    // as `i32` and `i32`.
    // `A`と`B`がどの型であるかを明示。インプットの型（訳注: つまり`Self`の型）
    // が`Container(i32, i32)`である場合、出力型は`i32`と`i32`となる。
    type A = i32;
    type B = i32;

    // `&amp;Self::A` and `&amp;Self::B` are also valid here.
    // `&amp;i32`の代わりに`&amp;Self::A`または`&amp;self::B`と書いても良い
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    // 1つ目の数を取得
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    // 最後の数を取得
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Phantom type parameters
-->
<h1 id="幽霊型パラメータ"><a class="header" href="#幽霊型パラメータ">幽霊型パラメータ</a></h1>
<!--
A phantom type parameter is one that doesn't show up at runtime,
but is checked statically (and only) at compile time.
-->
<p>幽霊型(Phantom Type)とは実行時には存在しないけれども、コンパイル時に静的に型チェックされるような型のことです。</p>
<!--
Data types can use extra generic type parameters to act as markers
or to perform type checking at compile time. These extra parameters 
hold no storage values, and have no runtime behavior.
-->
<p>構造体などのデータ型は、ジェネリック型パラメータを一つ余分に持ち、それをマーカーとして使ったりコンパイル時の型検査に使ったりすることができます。このマーカーは実際の値を何も持たず、したがって実行時の挙動そのものにはいかなる影響ももたらしません。</p>
<!--
In the following example, we combine [std::marker::PhantomData]
with the phantom type parameter concept to create tuples containing
different data types.
-->
<p>以下の例では、そのようなマーカーとして幽霊型(<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>)を用い、それぞれ異なった型の値を持つタプルを作成します。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::marker::PhantomData;

// A phantom tuple struct which is generic over `A` with hidden parameter `B`.
// ジェネリックなタプル構造体。2つ目のパラメータは幽霊型
#[derive(PartialEq)] // Allow equality test for this type.
                     // 比較演算子(`==`)での比較を可能にする。
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// A phantom type struct which is generic over `A` with hidden parameter `B`.
// 同様に構造体を定義
#[derive(PartialEq)] // Allow equality test for this type.
                     // 比較演算子での比較を可能にする。
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// Note: Storage is allocated for generic type `A`, but not for `B`.
//       Therefore, `B` cannot be used in computations.
// 注意点:  ジェネリック型Aに対してはメモリが割り当てられているが、
//          Bには割り当てられていないため、計算に使うことはできない。

fn main() {
    // Here, `f32` and `f64` are the hidden parameters.
    // PhantomTuple type specified as `&lt;char, f32&gt;`.
    // &lt;char, f32&gt;と型宣言されたPhantomTupleを作成
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTuple type specified as `&lt;char, f64&gt;`.
    // &lt;chr, f64&gt;のPhantomTuple。 PhantomDataがいかなる浮動小数点でもないことに注目
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // Type specified as `&lt;char, f32&gt;`.
    // &lt;char, f32&gt;の型が与えられた構造体を作成
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // Type specified as `&lt;char, f64&gt;`.
    // 同様に&lt;char, f64&gt;の構造体
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    // コンパイルエラー！型が違うので`==`で比較することができない！
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    // コンパイルエラー! 型が違うので比較することができない!
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-42"><a class="header" href="#参照-42">参照</a></h3>
<!--
[Derive], [struct], and [TupleStructs]
-->
<p><a href="generics/../trait/derive.html">継承(<code>Derive</code>)</a>, <a href="generics/../custom_types/structs.html">構造体</a>, <a href="generics/../custom_types/structs.html">タプル</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Testcase: unit clarification
-->
<h1 id="テストケース-単位を扱う"><a class="header" href="#テストケース-単位を扱う">テストケース: 単位を扱う</a></h1>
<!--
A useful method of unit conversions can be examined by implementing `Add`
with a phantom type parameter. The `Add` `trait` is examined below:
-->
<p>共通の単位同士を扱う際のチェックのために、<code>Add</code>を幽霊型を用いた実装にすると便利な場合があります。その場合<code>Add</code>トレイトは以下のようになります。</p>
<blockquote>
<p>訳注: RHSはRight Hand Side、つまりAdd(<code>+</code>)演算時の右辺のことです</p>
</blockquote>
<pre><code class="language-rust ignore">// This construction would impose: `Self + RHS = Output`
// where RHS defaults to Self if not specified in the implementation.
// このように定義しておくと、`Self + RHS = Output`であることが保証され、
// かつ、impl時にRHSの型が明示されていない場合、デフォルトでSelfと同じに
// なる。
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` must be `T&lt;U&gt;` so that `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`.
// `Output`は`T&lt;U&gt;`でなくてはならないので`T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`となる。
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<!--
The whole implementation:
-->
<p>以下は全体を示した例です。:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// Create void enumerations to define unit types.
/// 単位を定義するため、空の列挙型を作成。
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` is a type with phantom type parameter `Unit`,
/// and is not generic over the length type (that is `f64`).
/// `Length`は`Unit`という幽霊型パラメータを持つ型
///
/// `f64` already implements the `Clone` and `Copy` traits.
/// `f64`ははじめから`Clone`、`Copy`トレイトを持っている。
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// The `Add` trait defines the behavior of the `+` operator.
/// `Add`トレイトは加算演算子(`+`)の挙動を定義する。
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() returns a new `Length` struct containing the sum.
    // add()は`Length`の新しいインスタンスを返す。
    // Lengthの中の値は合計値になっている。
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` calls the `Add` implementation for `f64`.
        // ここでの`+`は`f64`の`Add`実装を呼び出す。
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // Specifies `one_foot` to have phantom type parameter `Inch`.
    // `one_foot`が幽霊型`Inch`を持つように明示する。
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` has phantom type parameter `Mm`.
    // `one_meter`が幽霊型`Mm`を持つように明示する。
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` calls the `add()` method we implemented for `Length&lt;Unit&gt;`.
    // 以下の`+`は上で定義した`Length&lt;Unit&gt;`用の`add()`メソッドを呼び出す。
    //
    // Since `Length` implements `Copy`, `add()` does not consume
    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.
    // `Length`は`Copy`トレイトを持っているため、`add()`は`one_foot`及び`one_meter`
    // を消費する代わりにそのコピーを作り、`self`、`rhs`として扱う。
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // Addition works.
    // 加算が問題なく実行されていることを確認
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // Nonsensical operations fail as they should:
    // Compile-time Error: type mismatch.
    // 異なる単位間の加算は意味を成さないので、
    // 以下はきちんとコンパイルエラーになる。
    // コンパイルエラー: タイプミスマッチ
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-43"><a class="header" href="#参照-43">参照</a></h3>
<!--
[Borrowing (`&`)], [Bounds (`X: Y`)], [enum], [impl & self],
[Overloading], [ref], [Traits (`X for Y`)], and [TupleStructs].
-->
<p><a href="generics/phantom/../../scope/borrow.html">借用(<code>&amp;</code>)</a>, <a href="generics/phantom/../../generics/bounds.html">トレイトバウンド</a>, <a href="generics/phantom/../../custom_types/enum.html">列挙型</a>, <a href="generics/phantom/../../fn/methods.html">impl &amp; self</a>,
<a href="generics/phantom/../../trait/ops.html">演算子のオーバーロード</a>, <a href="generics/phantom/../../scope/borrow/ref.html">参照</a>, <a href="generics/phantom/../../trait.html">トレイト (<code>X for Y</code>)</a>, <a href="generics/phantom/../../custom_types/structs.html">タプル</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Scoping rules
-->
<h1 id="スコーピングの規則"><a class="header" href="#スコーピングの規則">スコーピングの規則</a></h1>
<!--
Scopes play an important part in ownership, borrowing, and lifetimes.
That is, they indicate to the compiler when borrows are valid, when 
resources can be freed, and when variables are created or destroyed.
-->
<p>所有権、借用、ライフタイムといったRustに特有の概念において、変数のスコープは重要な役割を果たします。すなわち、スコープの存在によってコンパイラは借用は可能か否か、メモリ上の資源は解放可能か、変数はいつ作成され、いつ破棄されるか。といったことを知るのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raii"><a class="header" href="#raii">RAII</a></h1>
<!--
Variables in Rust do more than just hold data in the stack: they also *own*
resources, e.g. `Box<T>` owns memory in the heap. Rust enforces [RAII][raii]
(Resource Acquisition Is Initialization), so whenever an object goes out of
scope, its destructor is called and its owned resources are freed.
-->
<p>Rustの変数は単にデータをスタック上に保持するだけのものではありません。例えばヒープメモリを確保する<code>Box&lt;T&gt;</code>のように、変数はメモリ上の資源を <em>保有</em> する場合もあるのです。Rustは<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>(Resource Acquisition Is Initialization)を強制するので、オブジェクトがスコープを抜けると、必ずデストラクタが呼び出されてそのオブジェクトが保持していた資源が解放されます。</p>
<!--
This behavior shields against *resource leak* bugs, so you'll never have to
manually free memory or worry about memory leaks again! Here's a quick showcase:
-->
<p>この振る舞いは <em>リソースリーク</em> (<code>resource leak</code>)バグを防ぐのに役立ちます。手動でメモリを解放したり、メモリリークバグにわずらわされたりすることはなくなるのです！簡単な例で説明しましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">// raii.rs
fn create_box() {
    // Allocate an integer on the heap
    // 整数をヒープ上に確保
    let _box1 = Box::new(3i32);

    // `_box1` is destroyed here, and memory gets freed
    // `_box1`はここで破棄され、メモリは解放される。
}

fn main() {
    // Allocate an integer on the heap
    // 整数をヒープ上に確保
    let _box2 = Box::new(5i32);

    // A nested scope:
    // ネストしたスコープ
    {
        // Allocate an integer on the heap
        // 整数をヒープ上に確保
        let _box3 = Box::new(4i32);

        // `_box3` is destroyed here, and memory gets freed
        // `_box3`はここで破棄され、メモリは解放される。
    }

    // Creating lots of boxes just for fun
    // There's no need to manually free memory!
    // お遊びで大量のボックスを作る。
    // もちろん手動で開放する必要はないよ！
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` is destroyed here, and memory gets freed
    // `_box2`はここで破棄され、メモリは解放される。
}
</code></pre></pre>
<!--
Of course, we can double check for memory errors using [`valgrind`][valgrind]:
-->
<p><a href="http://valgrind.org/info/"><code>valgrind</code></a>を用いて、メモリエラーが起きていないか2重チェックすることももちろん可能です。</p>
<pre><code class="language-shell">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<!--
No leaks here!
-->
<p>リークはないみたいですね！</p>
<!-- 
## Destructor
 -->
<h2 id="デストラクタ"><a class="header" href="#デストラクタ">デストラクタ</a></h2>
<!--
The notion of a destructor in Rust is provided through the [`Drop`] trait. The
destructor is called when the resource goes out of scope. This trait is not
required to be implemented for every type, only implement it for your type if
you require its own destructor logic.
-->
<p>Rustにおけるデストラクタの概念は<code>Drop</code>トレイトによって提供されています。デストラクタは資源がスコープを抜けるときに呼び出されます。<code>Drop</code>トレイトは型定義のたびに必ず実装する必要があるわけではなく、デストラクタに独自のロジックが必要な場合にのみ実装します。</p>
<!-- 
Run the below example to see how the [`Drop`] trait works. When the variable in
the `main` function goes out of scope the custom destructor will be invoked.
 -->
<p>下のコードを実行して、<code>Drop</code>トレイトの動作を確認してみましょう。<code>main</code>関数内の変数がスコープを抜けるときにカスタムデストラクタが呼び出されるはずです。</p>
<pre><pre class="playground"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-44"><a class="header" href="#参照-44">参照</a></h3>
<!--
[Box][box]
-->
<p><a href="scope/../std/box.html">ボックス</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Ownership and moves
-->
<h1 id="所有権とムーブ"><a class="header" href="#所有権とムーブ">所有権とムーブ</a></h1>
<!--
Because variables are in charge of freeing their own resources, 
**resources can only have one owner**. This also prevents resources 
from being freed more than once. Note that not all variables own 
resources (e.g. [references]).
-->
<p>変数には自身の保持する資源を開放する責任があるため、 <strong>資源は一度に一つの所有者</strong> しか持つことができません。これはまた、資源を2度以上開放することができないということでもあります。ここで、全ての変数が資源を所有するわけではないということに注意しましょう。（e.g. <a href="scope/../flow_control/match/destructuring/destructure_pointers.html">参照</a>）</p>
<!--
When doing assignments (`let x = y`) or passing function arguments by value
(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak, 
this is known as a *move*.
-->
<p>変数をアサインする(<code>let x = y</code>)際や、関数に引数を値渡しする(<code>foo(x)</code>)際は、資源の <em>所有権(<code>ownership</code>)</em> が移動します。Rustっぽく言うと、「 <em>ムーブ</em> 」です。</p>
<!--
After moving resources, the previous owner can no longer be used. This avoids
creating dangling pointers.
-->
<p>資源を移動すると、それまでの所有者（訳注: 変数などのこと）を使用することはできなくなります。これによりダングリングポインタの発生を防げます。</p>
<pre><pre class="playground"><code class="language-rust editable">// This function takes ownership of the heap allocated memory
// この関数はヒープメモリ上の資源の所有権を取る。
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c` is destroyed and the memory freed
    // `c`は破棄されメモリは開放される。
}

fn main() {
    // _Stack_ allocated integer
    // _スタック_上に置かれた整数
    let x = 5u32;

    // *Copy* `x` into `y` - no resources are moved
    // `x`を`y`に *コピー* する。元の値が移動するわけではない。
    let y = x;

    // Both values can be independently used
    // 両方の値はそれぞれ独立に使うことができる。
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a` is a pointer to a _heap_ allocated integer
    // `a`は_ヒープ_上の整数へのポインタ
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // *Move* `a` into `b`
    // `a`を`b`に *ムーブ* する。
    let b = a;
    // The pointer address of `a` is copied (not the data) into `b`.
    // Both are now pointers to the same heap allocated data, but
    // `b` now owns it.
    // すなわち、`a`の指すメモリ上の番地が`b`にコピーされるため
    // いずれもヒープ上の同じ値を指すポインタとなる。しかし所有権は`b`にある。
    
    // Error! `a` can no longer access the data, because it no longer owns the
    // heap memory
    // エラー! `a`は所有権を持たないため、ヒープ上のデータにアクセスできない。
    //println!(&quot;a contains: {}&quot;, a);
    // TODO ^ Try uncommenting this line
    // TODO ^ 試しにここをアンコメントしてみましょう。

    // This function takes ownership of the heap allocated memory from `b`
    // この関数はヒープメモリ上の所有権を`b`から取る。
    destroy_box(b);

    // Since the heap memory has been freed at this point, this action would
    // result in dereferencing freed memory, but it's forbidden by the compiler
    // Error! Same reason as the previous Error
    // この時点でヒープメモリ上の資源は開放されているので、次の操作は
    // 解放済みメモリをデリファレンスすることになる。しかしそれはコンパイラが許さない。
    // エラー! 上述の理由より
    //println!(&quot;b contains: {}&quot;, b);
    // TODO ^ Try uncommenting this line
    // TODO ^ 試しにここをアンコメントしてみましょう。
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Mutability
-->
<h1 id="ミュータビリティ-1"><a class="header" href="#ミュータビリティ-1">ミュータビリティ</a></h1>
<!--
Mutability of data can be changed when ownership is transferred.
-->
<p>データのミュータビリティは所有権を移譲した際に変更できます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // Mutability error
    // ミュータビリティエラー
    //*immutable_box = 4;

    // *Move* the box, changing the ownership (and mutability)
    // boxを *ムーブ* する、同時に所有権とミュータビリティを変更する。
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // Modify the contents of the box
    // boxの内容を変更
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Borrowing
-->
<h1 id="借用"><a class="header" href="#借用">借用</a></h1>
<!--
Most of the time, we'd like to access data without taking ownership over
it. To accomplish this, Rust uses a *borrowing* mechanism. Instead of
passing objects by value (`T`), objects can be passed by reference (`&T`).
-->
<p>実際には、データの所有権を完全に受け渡すことなく一時的にアクセスしたいという場合がほとんどです。そのために、Rustでは <em>借用(<code>borrowing</code>)</em> という仕組みを用います。値そのもの(<code>T</code>)を受け渡すのではなく、そのリファレンス(<code>&amp;T</code>)を渡すのです。</p>
<!--
The compiler statically guarantees (via its borrow checker) that references 
*always* point to valid objects. That is, while references to an object
exist, the object cannot be destroyed.
-->
<p>コンパイラは借用チェッカを用いてリファレンスが <em>常に</em> 有効なオブジェクトへの参照であることを、コンパイル時に保証します。つまり、あるオブジェクトへのリファレンスが存在しているならば、そのオブジェクトを破壊することはできないということです。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// This function takes ownership of a box and destroys it
// この関数はボックスの所有権を奪い、破棄する。
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// This function borrows an i32
// この関数はi32を借用する
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // Create a boxed i32, and a stacked i32
    // ボックス化された整数を作成
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Borrow the contents of the box. Ownership is not taken,
    // so the contents can be borrowed again.
    // Boxの中身を借用。所有権を奪うわけではないため、
    // 直後にもう一度借用できる。
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Take a reference to the data contained inside the box
        // ボックス内の要素に対する参照を取得
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // Error!
        // Can't destroy `boxed_i32` while the inner value is borrowed later in scope.
        // エラー!
        // ボックス内の要素が借用されているため、`boxed_i32`を破棄する
        // ことはできない。
        eat_box_i32(boxed_i32);
        // FIXME ^ Comment out this line
        // FIXME ^ この行をコメントアウトしましょう。

        // Attempt to borrow `_ref_to_i32` after inner value is destroyed
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` goes out of scope and is no longer borrowed.
        // ここで`_ref_to_i32`はスコープを抜け、借用もなくなります。
    }

    // `boxed_i32` can now give up ownership to `eat_box` and be destroyed
    // ここでようやく、`eat_box`は所有権を移譲し、破棄することができます。
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Mutability
-->
<h1 id="ミュータビリティ-2"><a class="header" href="#ミュータビリティ-2">ミュータビリティ</a></h1>
<!--
Mutable data can be mutably borrowed using `&mut T`. This is called 
a *mutable reference* and gives read/write access to the borrower.
In contrast, `&T` borrows the data via an immutable reference, and 
the borrower can read the data but not modify it:
-->
<p>ミュータブルなデータは<code>&amp;mut T</code>でミュータブルに（変更可能な形で）借用することができます。これは <em>ミュータブルな参照</em> と呼ばれ、読み込み・書き込みの権限を借用者に与えます。対照的に<code>&amp;T</code>はデータをイミュータブルな参照を介して借用し、借用した側はデータを読み込みはできますが書き込みはできません。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` is a reference to a string allocated in read only memory
    // `&amp;'static str`はread-onlyメモリ上の文字列への参照
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// This function takes a reference to a book
// この関数はBook型へのリファレンスを取る。
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// This function takes a reference to a mutable book and changes `year` to 2014
// この関数はミュータブルなBook型へのミュータブルなリファレンスを取り、
// `year`を2014へ変更する。
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // Create an immutable Book named `immutabook`
    // `immutabook`という名のイミュータブルなBookを作成
    let immutabook = Book {
        // string literals have type `&amp;'static str`
        // 「&quot;」で囲まれた部分は`&amp;'static str`型になる。
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // Create a mutable copy of `immutabook` and call it `mutabook`
    // `immutabook`のミュータブルなコピーを作成し、`mutabook`と名付ける
    let mut mutabook = immutabook;
    
    // Immutably borrow an immutable object
    // イミュータブルなオブジェクトをイミュータブルに借用する
    borrow_book(&amp;immutabook);

    // Immutably borrow a mutable object
    // ミュータブルなオブジェクトをイミュータブルに借用する
    borrow_book(&amp;mutabook);
    
    // Borrow a mutable object as mutable
    // ミュータブルなオブジェクトをミュータブルに借用する
    new_edition(&amp;mut mutabook);
    
    // Error! Cannot borrow an immutable object as mutable
    // エラー！イミュータブルなオブジェクトをミュータブルに借用することはできない
    new_edition(&amp;mut immutabook);
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-45"><a class="header" href="#参照-45">参照</a></h3>
<p><a href="scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Aliasing
-->
<h1 id="エイリアス-1"><a class="header" href="#エイリアス-1">エイリアス</a></h1>
<!--
Data can be immutably borrowed any number of times, but while immutably
borrowed, the original data can't be mutably borrowed. On the other hand, only
*one* mutable borrow is allowed at a time. The original data can be borrowed
again only *after* the mutable reference has been used for the last time.
-->
<p>データは一度にいくつでもイミュータブルに借用することができますが、その間オリジナルのデータをミュータブルに借用することはできません。一方でミュータブルな借用は一度に <em>一つ</em> しか借用することができません。オリジナルのデータをもう一度借用できるのはミュータブルな参照が最後に使われた場所より <em>あとで</em> なければいけません。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // Data can be accessed via the references and the original owner
    // データは元々の持ち主と参照の両方からアクセスすることができます。
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // Error! Can't borrow `point` as mutable because it's currently
    // borrowed as immutable.
    // エラー！pointはすでにイミュータブルに借用されているため、
    // ミュータブルに借用することができない。
    // let mutable_borrow = &amp;mut point;
    // TODO ^ Try uncommenting this line

    // The borrowed values are used again here
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // The immutable references are no longer used for the rest of the code so
    // it is possible to reborrow with a mutable reference.
    let mutable_borrow = &amp;mut point;

    // Change data via mutable reference
    // ミュータブルなリファレンスを介してデータを変更する
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // Error! Can't borrow `point` as immutable because it's currently
    // borrowed as mutable.
    // エラー！`point`はすでにミュータブルに借用されているため、
    // イミュータブルに借用することはできない。
    // let y = &amp;point.y;
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。

    // Error! Can't print because `println!` takes an immutable reference.
    // エラー！`println!`はイミュータブルなリファレンスを取るため、printできません。
    // println!(&quot;Point Z coordinate is {}&quot;, point.z);
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。

    // Ok! Mutable references can be passed as immutable to `println!`
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // The mutable reference is no longer used for the rest of the code so it
    // is possible to reborrow
    let new_borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# The ref pattern
-->
<h1 id="refパターン"><a class="header" href="#refパターン">refパターン</a></h1>
<!--
When doing pattern matching or destructuring via the `let` binding, the `ref`
keyword can be used to take references to the fields of a struct/tuple. The 
example below shows a few instances where this can be useful:
-->
<p><code>let</code>を介してデストラクトやパターンマッチングを行う場合、<code>ref</code>キーワードを用いて構造体・タプルのフィールドへのリファレンスを取得することができます。以下の例ではこれが有用になる例を幾つかお見せします。</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&amp;` borrow on the right side.
    // 左辺に`ref`をつけることによる借用と、右辺に`&amp;`をつけることによる借用は等価
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    // `ref`は構造体をデストラクトする際にも有用
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        // `ref_to_x`は`point`の`x`フィールドへの参照
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        // `point`の`x`フィールドへのコピーを返す。
        *ref_to_x
    };

    // A mutable copy of `point`
    // `point`へのミュータブルなコピー
    let mut mutable_point = point;

    {
        // `ref` can be paired with `mut` to take mutable references.
        // `ref`は`mut`とともに使い、ミュータブルな参照を取ることもできる。
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // Mutate the `y` field of `mutable_point` via a mutable reference.
        // `mutable_point`の`y`というミュータブルなフィールドの値を変更する。
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // A mutable tuple that includes a pointer
    // ポインタを含むミュータブルなタプル
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // Destructure `mutable_tuple` to change the value of `last`.
        // `mutable_tuple`をデストラクトして、`last`の値を変更
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Lifetimes
-->
<h1 id="ライフタイム"><a class="header" href="#ライフタイム">ライフタイム</a></h1>
<!--
A *lifetime* is a construct the compiler (or more specifically, its *borrow
checker*) uses to ensure all borrows are valid. Specifically, a variable's
lifetime begins when it is created and ends when it is destroyed. While
lifetimes and scopes are often referred to together, they are not the same.
-->
<p><em>ライフタイム</em> はコンパイラ（借用チェッカーと呼ばれる場合もあります）が、全ての借用に問題がないことを確認するために使用する仕組みです。正確にいうと、変数のライフタイムは作成時に開始し、破棄された時に終了します。ライフタイムとスコープは同時に語られることが多いですが、同じものではありません。</p>
<!--
Take, for example, the case where we borrow a variable via `&`. The
borrow has a lifetime that is determined by where it is declared. As a result,
the borrow is valid as long as it ends before the lender is destroyed. However,
the scope of the borrow is determined by where the reference is used.
-->
<p>例として<code>&amp;</code>を用いて変数を借用する場合をあげましょう。借用のライフタイムは宣言時に決定し、そこから貸し手が破棄されるまで続きます。しかしながら、借用のスコープは参照が使われる際に決定します。</p>
<!--
In the following example and in the rest of this section, we will see how
lifetimes relate to scopes, as well as how the two differ.
-->
<p>以下の例からこのセクションの残りでは、ライフタイムとスコープの関係、そしてそれらがいかに異なるものであるかを見ていきます。</p>
<pre><pre class="playground"><code class="language-rust editable">// Lifetimes are annotated below with lines denoting the creation
// and destruction of each variable.
// `i` has the longest lifetime because its scope entirely encloses 
// both `borrow1` and `borrow2`. The duration of `borrow1` compared 
// to `borrow2` is irrelevant since they are disjoint.
// 以下では、変数の作成から破棄までのライフタイムを線で示しています。
// `i`は最長のライフタイムを持ち、そのスコープは`borrow1`および`borrow2`
// のスコープを完全に包含します。`borrow1`と`borrow2`の存続期間は一切重なりません。
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>Note that no names or types are assigned to label lifetimes.
This restricts how lifetimes will be able to be used as we will see.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Explicit annotation
-->
<h1 id="明示的アノテーション"><a class="header" href="#明示的アノテーション">明示的アノテーション</a></h1>
<!--
The borrow checker uses explicit lifetime annotations to determine
how long references should be valid. In cases where lifetimes are not
elided[^1], Rust requires explicit annotations to determine what the 
lifetime of a reference should be. The syntax for explicitly annotating 
a lifetime uses an apostrophe character as follows: 
-->
<p>借用チェッカーは参照がどれだけの間有効かを決定するために、明示的なアノテーションを使用します。ライフタイムが省略<sup class="footnote-reference"><a href="#1">1</a></sup>されなかった場合、Rustは参照のライフタイムがどのようなものであるか、明示的なアノテーションを必要とします。</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` has a lifetime parameter `'a`
// `foo`は`'a`というライフタイムパラメータを持ちます。
</code></pre>
<!--
Similar to [closures][anonymity], using lifetimes requires generics. 
Additionally, this lifetime syntax indicates that the lifetime of `foo` 
may not exceed that of `'a`. Explicit annotation of a type has the form 
`&'a T` where `'a` has already been introduced.
-->
<p><a href="scope/lifetime/../../fn/closures/anonymity.html">クロージャ</a>と同様、ライフタイムの使用はジェネリクスを必要とします。もう少し詳しく言うと、この書き方は「<code>foo</code>のライフタイムは<code>'a</code>のそれを超えることはない。」ということを示しており、型を明示した場合<code>'a</code>は<code>&amp;'a T</code>となるということです。</p>
<!--
In cases with multiple lifetimes, the syntax is similar:
-->
<p>ライフタイムが複数ある場合も、同じような構文になります。</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` has lifetime parameters `'a` and `'b`
// `foo`は`'a`と`'b`というライフタイムパラメータを持ちます。
</code></pre>
<!--
In this case, the lifetime of `foo` cannot exceed that of either `'a` *or* `'b`.
-->
<p>この場合は、<code>foo</code>のライフタイムは<code>'a</code>、<code>'b</code>の <em>いずれよりも</em> 長くなってはなりません。</p>
<!--
See the following example for explicit lifetime annotation in use:
-->
<p>以下はライフタイムを明示的に書く場合の例です。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
// `print_refs`は`i32`への参照を2つとり、それぞれ`'a`と`'b`という
// ライフタイムを持つ。これらのライフタイムは最短でも`print_refs`
// 関数と同じになる。
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
// 引数を取らないがライフタイムパラメータ`'a`を持つ関数。
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    // エラー: `_x`の寿命が短すぎる。
    //let y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
    // `&amp;_x`のライフタイムは`y`のそれよりも短いため、関数内で`'a`を使用して
    // 変数のライフタイムを指定しようとすると失敗する。つまり、短いライフタイム
    // を持つ参照をより長いものに強制的に代入することはできない。
}

fn main() {
    // Create variables to be borrowed below.
    // 下で借用するための変数を作成
    let (four, nine) = (4, 9);
    
    // Borrows (`&amp;`) of both variables are passed into the function.
    // 2つの変数の借用(`&amp;`)が関数に渡される。
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    // 借用された変数の寿命は、借り手のそれよりも長くなくてはならない。
    // つまり、`four`、`nine`のライフタイムは`print_refs`のそれよりも
    // 長くなくてはならない。
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
    // `failed_borrow`は関数のライフタイムよりも`'a`を長くさせるような
    // 参照を持たないが、それでも`'a`のほうが長くなる。なぜならそのような
    // 場合`'a`はデフォルトで`'static`になるからである。
}
</code></pre></pre>
<!--
[^1]: [elision] implicitly annotates lifetimes and so is different.
-->
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/elision.html">省略</a> はライフタイムが暗黙のうちに（プログラマから見えない形で）アノテートされることを指します。</p>
</div>
<!--
### See also:
-->
<h3 id="参照-46"><a class="header" href="#参照-46">参照</a></h3>
<!--
[generics][generics] and [closures][closures]
-->
<p><a href="scope/lifetime/../../generics.html">ジェネリクス</a>, <a href="scope/lifetime/../../fn/closures.html">クロージャ</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Functions
-->
<h1 id="関数-2"><a class="header" href="#関数-2">関数</a></h1>
<!--
Ignoring [elision], function signatures with lifetimes have a few constraints: 
-->
<p><a href="scope/lifetime/elision.html">省略</a>をしない場合、ライフタイムのシグネチャ(e.g. <code>&lt;'a&gt;</code>)を持つ関数にはいくつかの制限があります。</p>
<!--
* any reference *must* have an annotated lifetime.
* any reference being returned *must* have the same lifetime as an input or
be `static`.
-->
<ul>
<li>全ての変数においてライフタイムを明示しなくてはならない。</li>
<li>返り値となる参照はすべて引数と同じライフタイムか、<code>static</code>ライフタイムを持たなくてはならない</li>
</ul>
<!--
Additionally, note that returning references without input is banned if it
would result in returning references to invalid data. The following example shows
off some valid forms of functions with lifetimes:
-->
<p>加えて、引数のない関数から参照を返す場合、それが結果的に無効なデータへの参照になるならば、禁止されている</p>
<pre><pre class="playground"><code class="language-rust editable">// One input reference with lifetime `'a` which must live
// at least as long as the function.
// 引数として`'a`のライフタイムで参照を一つ取る。最低でもこの関数
// と同じだけの長さでなくてはならない。
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// Mutable references are possible with lifetimes as well.
// ミュータブルな参照でも同様
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// Multiple elements with different lifetimes. In this case, it
// would be fine for both to have the same lifetime `'a`, but
// in more complex cases, different lifetimes may be required.
// 異なるライフタイムを持つ複数の引数がある場合。
// ここでは1種類のライフタイムでも問題はないが、より複雑なケースでは
// 異なるライフタイムが必要になる場合がある。
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// Returning references that have been passed in is acceptable.
// However, the correct lifetime must be returned.
// 受け取った参照をそのまま返すことに問題はないが、適切なライフタイム
// でなくてはならない。
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// The above is invalid: `'a` must live longer than the function.
// Here, `&amp;String::from(&quot;foo&quot;)` would create a `String`, followed by a
// reference. Then the data is dropped upon exiting the scope, leaving
// a reference to invalid data to be returned.
// `'a`は関数より長くなくてはならないため上の関数は正しくない。
// ここでは、`&amp;String::from(&quot;foo&quot;)`は`String`のデータとそれへの参照を作り出す。
// その後データはスコープを抜けるとともに破棄される。そのため、
// 不適切なデータに対する参照を返すことになってしまう。

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-47"><a class="header" href="#参照-47">参照</a></h3>
<p><a href="scope/lifetime/fn.html">functions</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Methods
-->
<h1 id="メソッド-2"><a class="header" href="#メソッド-2">メソッド</a></h1>
<!--
Methods are annotated similarly to functions:
-->
<p>メソッドのライフタイムは関数に似ている。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // Annotate lifetimes as in a standalone function.
    // 通常の関数と同様にライフタイムを明示
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-48"><a class="header" href="#参照-48">参照</a></h3>
<!--
[methods]
-->
<p><a href="scope/lifetime/../../fn/methods.html">メソッド</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Structs
-->
<h1 id="構造体-2"><a class="header" href="#構造体-2">構造体</a></h1>
<!--
Annotation of lifetimes in structures are also similar to functions:
-->
<p>構造体におけるライフタイムも関数のそれと似ている。</p>
<pre><pre class="playground"><code class="language-rust editable">// A type `Borrowed` which houses a reference to an
// `i32`. The reference to `i32` must outlive `Borrowed`.
// `i32`への参照をメンバに持つ`Borrowed`型。
// 参照は`Borrowed`自体よりも長生きでなくてはならない。
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// Similarly, both references here must outlive this structure.
// 同様に、ここでも参照は構造体よりも長生きでなくてはならない。
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// An enum which is either an `i32` or a reference to one.
// `i32`、あるいは`i32`への参照のいずれかとなる列挙型
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-49"><a class="header" href="#参照-49">参照</a></h3>
<p><a href="scope/lifetime/../../custom_types/structs.html"><code>struct</code>s</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Annotation of lifetimes in trait methods basically are similar to functions.
Note that <code>impl</code> may have annotation of lifetimes too.</p>
<pre><pre class="playground"><code class="language-rust editable">// A struct with annotation of lifetimes.
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// Annotate lifetimes to impl.
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-50"><a class="header" href="#参照-50">参照</a></h3>
<p><a href="scope/lifetime/../../trait.html"><code>trait</code>s</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Bounds
-->
<h1 id="ライフタイム境界"><a class="header" href="#ライフタイム境界">ライフタイム境界</a></h1>
<!--
Just like generic types can be bounded, lifetimes (themselves generic)
use bounds as well. The `:` character has a slightly different meaning here, 
but `+` is the same. Note how the following read:
-->
<p>ジェネリック型に境界(bound)を与え、特定のトレイトを実装していることを保証できるのと同様、ライフタイム（それ自身ジェネリック型）にも境界を与えることができます。<code>:</code>は、ここでは多少異なる意味を持ちますが<code>+</code>は同じです。以下の構文の意味をチェックしてください。</p>
<!--
1. `T: 'a`: *All* references in `T` must outlive lifetime `'a`.
2. `T: Trait + 'a`: Type `T` must implement trait `Trait` and *all* references
in `T` must outlive `'a`.
-->
<ol>
<li><code>T: 'a</code>: <code>T</code>内の <em>全ての</em> 参照は<code>'a</code>よりも長生きでなくてはならない</li>
<li><code>T: Trait + 'a</code>: 上に加えて<code>T</code>は<code>Trait</code>という名のトレイトを実装してなくてはならない。</li>
</ol>
<!--
The example below shows the above syntax in action used after keyword `where`:
-->
<p>上記の構文を実際に動く例で見ていきましょう。<code>where</code>キーワードの後に注目してください。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Debug; // Trait to bound with.
                     // ライフタイムを紐付けるトレイト

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` contains a reference to a generic type `T` that has
// an unknown lifetime `'a`. `T` is bounded such that any
// *references* in `T` must outlive `'a`. Additionally, the lifetime
// of `Ref` may not exceed `'a`.
// `Ref`は`'a`というライフタイムを持つジェネリック型`T`に対する参照を持ち、
// `T`の値に対する *参照* は必ず`'a`よりも長生きでなくてはならない。
// さらに、`Ref`のライフタイムは`'a`を超えてはならない。

// A generic function which prints using the `Debug` trait.
// `Debug`トレイトを利用してプリントを行うジェネリック関数
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// Here a reference to `T` is taken where `T` implements
// `Debug` and all *references* in `T` outlive `'a`. In
// addition, `'a` must outlive the function.
// `Debug`を実装している`T`への参照を取る。`T`への *参照* は
// 必ず`'a`よりも長生きでなくてはならない。さらに、`'a`は
// 関数自体よりも長生きでなくてはならない。
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-51"><a class="header" href="#参照-51">参照</a></h3>
<!--
[generics][generics], [bounds in generics][bounds], and 
[multiple bounds in generics][multibounds]
-->
<p><a href="scope/lifetime/../../generics.html">ジェネリクス</a>, <a href="scope/lifetime/../../generics/bounds.html">ジェネリック境界</a>,
<a href="scope/lifetime/../../generics/multi_bounds.html">境界が複数の場合</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Coercion
-->
<h1 id="圧縮"><a class="header" href="#圧縮">圧縮</a></h1>
<!--
A longer lifetime can be coerced into a shorter one 
so that it works inside a scope it normally wouldn't work in.
This comes in the form of inferred coercion by the Rust compiler,
and also in the form of declaring a lifetime difference:
-->
<p>長いライフタイムは、短いものに圧縮(coerce)することで、そのままでは動作しないスコープの中でも使用できるようになります。これは、Rustコンパイラが推論の結果として圧縮する場合と、複数のライフタイムを比較して圧縮する場合があります。</p>
<pre><pre class="playground"><code class="language-rust editable">// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
// ここではRustはライフタイムを出来る限り短く見積もり、
// 2つの参照をそのライフタイムに押し込める。
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` reads as lifetime `'a` is at least as long as `'b`.
// Here, we take in an `&amp;'a i32` and return a `&amp;'b i32` as a result of coercion.
// `&lt;'a: 'b, 'b&gt;`は「ライフタイム`'a`は最低でも`'b`と同じ長さ」と読める。
// ここでは、`&amp;'a i32`をとり、`&amp;'b i32`に圧縮して返す。
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // Longer lifetime
                   // 長いライフタイム
    
    {
        let second = 3; // Shorter lifetime
                        // 短いライフタイム
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Static
-->
<h1 id="スタティックライフタイム"><a class="header" href="#スタティックライフタイム">スタティックライフタイム</a></h1>
<!--
A `'static` lifetime is the longest possible lifetime, and lasts for 
the lifetime of the running program. A `'static` lifetime may also be 
coerced to a shorter lifetime. There are two ways to make a variable 
with `'static` lifetime, and both are stored in the read-only memory
of the binary:
-->
<p><code>'static</code>ライフタイムは全てのライフタイムの中で最長で、プログラムが動作している間、常に有効になります。<code>'static</code>であっても、より短いライフタイムに圧縮されることはあります。<code>'static</code>なライフタイムをもつ変数を作成する方法は2つあり、いずれも実行バイナリの一部としてROM上に保存されます。</p>
<!--
* Make a constant with the `static` declaration.
* Make a `string` literal which has type: `&'static str`.
-->
<ul>
<li><code>static</code>宣言とともに定数を作成する。</li>
<li>文字列リテラル で<code>&amp;'static str</code>型を持つ変数を作成する。</li>
</ul>
<!--
See the following example for a display of each method:
-->
<p>では、それぞれの方法の例を見ていきましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">// Make a constant with `'static` lifetime.
// `'static`ライフタイムを持つ定数を作成
static NUM: i32 = 18;

// Returns a reference to `NUM` where its `'static` 
// lifetime is coerced to that of the input argument.
// `NUM`への参照を返す。ライフタイムは`'static`から引数の
// ライフタイムへと圧縮されている。
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // Make a `string` literal and print it:
        // 文字列リテラルを用いて変数を作成し、プリントする
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.
        // `static_string`がスコープから抜けると、参照は使用することが
        // できなくなるが、データはバイナリ中に残る。
    }
    
    {
        // Make an integer to use for `coerce_static`:
        // `coerce_static`関数を呼び出すために、整数を作成
        let lifetime_num = 9;

        // Coerce `NUM` to lifetime of `lifetime_num`:
        // `NUM`を`lifetime_num`のライフタイムへと圧縮
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }
    
    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-52"><a class="header" href="#参照-52">参照</a></h3>
<!--
[`'static` constants][static_const]
-->
<p><a href="scope/lifetime/../../custom_types/constants.html"><code>'static</code> 定数</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Elision
-->
<h1 id="省略"><a class="header" href="#省略">省略</a></h1>
<!--
Some lifetime patterns are overwhelmingly common and so the borrow checker
will allow you to omit them to save typing and to improve readability.
This is known as elision. Elision exists in Rust solely because these patterns
are common.
-->
<p>ライフタイムのパターンのうちのいくつかは、他と比べてあまりにも一般的に使用されるため、タイプ量を減らし可読性を上げるために省くことができます。これは省略として知られており、それらのパターンが一般的であるというだけの理由で存在しています。</p>
<!--
The following code shows a few examples of elision. For a more comprehensive
description of elision, see [lifetime elision][elision] in the book.
-->
<p>以下のコードでは省略の例を幾つかお見せします。より完全な説明を見たい場合は、「プログラミング言語Rust」の<a href="scope/lifetime/elision-ja">ライフタイムの省略</a>の項を見てください。</p>
<pre><pre class="playground"><code class="language-rust editable">// `elided_input` and `annotated_input` essentially have identical signatures
// because the lifetime of `elided_input` is inferred by the compiler:
// `elided_input`のライフタイムはコンパイラによって自動的に付与されるため
// 以下の2つは同一のライフタイムシグネチャを持つ。
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// Similarly, `elided_pass` and `annotated_pass` have identical signatures
// because the lifetime is added implicitly to `elided_pass`:
// 同様に、以下の2つの関数も全く同じライフタイムシグネチャを持つ。
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-53"><a class="header" href="#参照-53">参照</a></h3>
<!--
[elision][elision]
-->
<p><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">ライフタイムの省略</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Traits
-->
<h1 id="トレイト"><a class="header" href="#トレイト">トレイト</a></h1>
<!--
A `trait` is a collection of methods defined for an unknown type:
`Self`. They can access other methods declared in the same trait.
-->
<p>トレイト(<code>trait</code>)とは任意の型となりうる<code>Self</code>に対して定義されたメソッドの集合のことです。同じトレイト内で宣言されたメソッド同士はお互いにアクセスすることができます。</p>
<!--
Traits can be implemented for any data type. In the example below,
we define `Animal`, a group of methods. The `Animal` `trait` is 
then implemented for the `Sheep` data type, allowing the use of 
methods from `Animal` with a `Sheep`.
-->
<p>トレイトはあらゆるデータ型に実装することができます。以下の例ではまず<code>Animal</code>というメソッドの集合を定義し、その後<code>Animal</code>トレイトを<code>Sheep</code>というデータ型に対して実装します。これにより<code>Animal</code>のメソッドを<code>Sheep</code>が使用することが可能になります。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // Static method signature; `Self` refers to the implementor type.
    // スタティックメソッドのシグネチャ。
    // `Self` はこのトレイトを実装している型になる。
    fn new(name: &amp;'static str) -&gt; Self;

    // Instance method signatures; these will return a string.
    // インスタンスメソッドのシグネチャ。
    // これらの関数は文字列を返す。
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // Traits can provide default method definitions.
    // メソッドのデフォルトの挙動を定義することもできる。
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Implementor methods can use the implementor's trait methods.
            // メソッドをある型に実装する際に、その型のトレイトメソッドを
            // 使用することができる。
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Implement the `Animal` trait for `Sheep`.
// `Animal`というトレイトを`Sheep`に実装する。
impl Animal for Sheep {
    // `Self` is the implementor type: `Sheep`.
    // `Self`は実装対象の型: ここでは`Sheep`
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // Default trait methods can be overridden.
    // デフォルトのトレイトメソッドはオーバーライドすることができる。
    fn talk(&amp;self) {
        // For example, we can add some quiet contemplation.
        // 例えば、静かに熟考させてみる。
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Type annotation is necessary in this case.
    // この場合、型アノテーションが必須。
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // TODO ^ Try removing the type annotations.
    // TODO ^ ここの型アノテーションを消してみましょう。

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Derive
-->
<h1 id="継承derive"><a class="header" href="#継承derive">継承(Derive)</a></h1>
<!--
The compiler is capable of providing basic implementations for some traits via
the `#[derive]` [attribute][attribute]. These traits can still be
manually implemented if a more complex behavior is required.
-->
<p>コンパイラには、<code>[#derive]</code><a href="trait/../attribute.html">アトリビュート</a>を用いることで型に対して特定のトレイトの標準的な実装を提供する機能があります。より複雑なことを行わせたい場合には、同名のトレイトを手動で実装することも可能です。</p>
<!--
The following is a list of derivable traits:
* Comparison traits:
  [`Eq`][eq], [`PartialEq`][partial-eq], [`Ord`][ord], [`PartialOrd`][partial-ord].
* [`Clone`][clone], to create `T` from `&T` via a copy.
* [`Copy`][copy], to give a type 'copy semantics' instead of 'move semantics'.
* [`Hash`][hash], to compute a hash from `&T`.
* [`Default`][default], to create an empty instance of a data type.
* [`Debug`][debug], to format a value using the `{:?}` formatter.
-->
<p>以下はderive可能なトレイトの一覧です。</p>
<ul>
<li>型の比較に関連するトレイト:
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, これはコピーによって<code>&amp;T</code>から<code>T</code>を作成するトレイト</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>, to give a type 'copy semantics' instead of 'move semantics'.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, これは<code>&amp;T</code>からハッシュ値を計算するためのトレイト</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, これは空っぽのインスタンスを作成するためのトレイト</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, これは<code>{:?}</code>フォーマッタを利用して値をフォーマットするためのトレイト</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">// `Centimeters`, a tuple struct that can be compared
// `Centimeters`は比較可能なタプルになる
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, a tuple struct that can be printed
// `Inches`はプリント可能なタプルになる
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`, a tuple struct with no additional attributes
// `Seconds`には特にアトリビュートを付け加えない。
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // Error: `Seconds` can't be printed; it doesn't implement the `Debug` trait
    // エラー: `Seconds`はプリントできない。これは`Debug`トレイトを実装していないため
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。

    // Error: `Seconds` can't be compared; it doesn't implement the `PartialEq` trait
    // エラー: `Seconds`は比較できない。これは`PartialEq`トレイトを実装していないため
    //let _this_is_true = (_one_second == _one_second);
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-54"><a class="header" href="#参照-54">参照</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-traits-with-dyn"><a class="header" href="#returning-traits-with-dyn">Returning Traits with <code>dyn</code></a></h1>
<p>The Rust compiler needs to know how much space every function's return type requires. This means all your functions have to return a concrete type. Unlike other languages, if you have a trait like <code>Animal</code>, you can't write a function that returns <code>Animal</code>, because its different implementations will need different amounts of memory. </p>
<p>However, there's an easy workaround. Instead of returning a trait object directly, our functions return a <code>Box</code> which <em>contains</em> some <code>Animal</code>. A <code>box</code> is just a reference to some memory in the heap. Because a reference has a statically-known size, and the compiler can guarantee it points to a heap-allocated <code>Animal</code>, we can return a trait from our function!</p>
<p>Rust tries to be as explicit as possible whenever it allocates memory on the heap. So if your function returns a pointer-to-trait-on-heap in this way, you need to write the return type with the <code>dyn</code> keyword, e.g. <code>Box&lt;dyn Animal&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Sheep {}
struct Cow {}

trait Animal {
    // Instance method signature
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;baaaaah!&quot;
    }
}

// Implement the `Animal` trait for `Cow`.
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;moooooo!&quot;
    }
}

// Returns some struct that implements Animal, but we don't know which one at compile time.
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Operator Overloading
-->
<h1 id="演算子のオーバーロード"><a class="header" href="#演算子のオーバーロード">演算子のオーバーロード</a></h1>
<!--
In Rust, many of the operators can be overloaded via traits. That is, some operators can
be used to accomplish different tasks based on their input arguments. This is possible
because operators are syntactic sugar for method calls. For example, the `+` operator in
`a + b` calls the `add` method (as in `a.add(b)`). This `add` method is part of the `Add`
trait. Hence, the `+` operator can be used by any implementor of the `Add` trait.
-->
<p>Rustでは、多くの演算子はトレイトによってオーバーロードすることができます。つまり、一部の演算子は引数となる値の型に応じて異なる役割を果たすことができるということです。これが可能なのは、演算子が実際にはメソッド呼び出しの糖衣構文にすぎないからです。例えば<code>a + b</code>における<code>+</code>演算子は<code>add</code>メソッドを(<code>a.add(b)</code>の形で)呼び出します。この<code>add</code>メソッドは<code>Add</code>トレイトの一部です。それ故、<code>+</code>は<code>Add</code>トレイトを実装している全ての型に対して有効なのです。</p>
<!--
A list of the traits, such as `Add`, that overload operators can be found in [`core::ops`][ops].
-->
<p><code>Add</code>などの、演算子をオーバーロードするトレイトの一覧は<a href="https://doc.rust-lang.org/core/ops/"><code>core::ops</code></a>にあります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// The `std::ops::Add` trait is used to specify the functionality of `+`.
// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.
// The following block implements the operation: Foo + Bar = FooBar
// `std::ops::Add`トレイトは`+`の振る舞いを規定するために使用される
// ここでは`Foo`に対して`Add&lt;Bar&gt;`を実装する。これは加算時の右辺が`Bar`型
// の時に呼び出されるトレイト。つまり以下は`Foo + Bar = FooBar`という振る舞いを
// もたらす。
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// By reversing the types, we end up implementing non-commutative addition.
// Here, we make `Add&lt;Foo&gt;` - the trait for addition with a RHS of type `Foo`.
// This block implements the operation: Bar + Foo = BarFoo
// 型を反転することで、非可換の加算を実装できる。ここでは`Bar`に対して
// `Add&lt;Foo&gt;`を実装する。これは加算時の右辺が`Foo`型の時に呼び出されるメソッド。
// つまり以下は`Bar + Foo = BarFoo`という結果をもたらす。
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3 id="see-also"><a class="header" href="#see-also">See Also</a></h3>
<!--
[Add][add], [Syntax Index][syntax]
-->
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">構文の索引</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Drop
-->
<h1 id="メモリ解放"><a class="header" href="#メモリ解放">メモリ解放</a></h1>
<!--
The [`Drop`][Drop] trait only has one method: `drop`, which is called automatically 
when an object goes out of scope. The main use of the `Drop` trait is to free the
resources that the implementor instance owns.
-->
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトにはメソッドが一つだけしかありません。<code>drop</code>です。これは、オブジェクトがスコープから抜けた時に自動で呼ばれます。<code>Drop</code>トレイトの主な使用目的は、インスタンスが所有する資源を開放することです。</p>
<!--
`Box`, `Vec`, `String`, `File`, and `Process` are some examples of types that
implement the `Drop` trait to free resources. The `Drop` trait can also be
manually implemented for any custom data type.
-->
<p><code>Drop</code>トレイトを実装している型の例としては<code>Box</code>、<code>Vec</code>、<code>String</code>、<code>File</code>、<code>Process</code>等があげられます。<code>Drop</code>トレイトは任意の型に対して手動で実装することができます。</p>
<!--
The following example adds a print to console to the `drop` function to announce
when it is called.
-->
<p>以下の例では<code>drop</code>メソッドにコンソールへの出力を追加することで、<code>drop</code>が呼ばれたタイミングが分かるようにしています。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// This trivial implementation of `drop` adds a print to console.
// このちょっとした実装で、`drop`にコンソール出力機能がつきます。
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // block A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // block B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // Variable can be manually dropped using the `drop` function
    // `drop`関数を用いて変数を手動で開放することもできます。
    drop(_a);
    // TODO ^ Try commenting this line
    // TODO ^ この行をコメントアウトしてみましょう。

    println!(&quot;end of the main function&quot;);

    // `_a` *won't* be `drop`ed again here, because it already has been
    // (manually) `drop`ed
    // `_a`はここで`drop`されることは *ない* 。なぜならば、上ですでに
    // （手動で）`drop`されているため。
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Iterators
-->
<h1 id="イテレータ"><a class="header" href="#イテレータ">イテレータ</a></h1>
<!--
The [`Iterator`][iter] trait is used to implement iterators over collections such as arrays.
-->
<p><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>トレイトは、例えば配列のような、要素の集合に対してイテレータを実装するためのトレイトです。</p>
<!--
The trait requires only a method to be defined for the `next` element, 
which may be manually defined in an `impl` block or automatically 
defined (as in arrays and ranges).
-->
<p>このトレイトは<code>next</code>の要素に相当するものを決定するためのメソッドのみを要求します。このメソッドは<code>impl</code>ブロック内で手動で実装するか、あるいは（配列やrangeのように）自動で定義されます。</p>
<!--
As a point of convenience for common situations, the `for` construct 
turns some collections into iterators using the [`.into_iter()`][intoiter] method.
-->
<p>サッとイテレータを使いたい時は、<code>for</code>文で集合からイテレータを作成することが良くあります。これは<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iter()</code></a>メソッドを呼び出しています。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Implement `Iterator` for `Fibonacci`.
// The `Iterator` trait only requires a method to be defined for the `next` element.
// `Iterator`を`Fibonacci`に対して実装する。
// `Iterator`トレイトは次(`next`)の要素を取得するメソッドの定義だけを要求する。
impl Iterator for Fibonacci {
    type Item = u32;
    
    // Here, we define the sequence using `.curr` and `.next`.
    // The return type is `Option&lt;T&gt;`:
    //     * When the `Iterator` is finished, `None` is returned.
    //     * Otherwise, the next value is wrapped in `Some` and returned.
    // ここではイテレーションの流れを`.curr`と`.next`を使用して定義している。
    // 返り値の型は`Option&lt;T&gt;`で、これは:
    //     * `Iterator`が終了した時は`None`を返し、
    //     * そうでなければ`Some`でラップされた値を返す。
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // Since there's no endpoint to a Fibonacci sequence, the `Iterator` 
        // will never return `None`, and `Some` is always returned.
        // フィボナッチ数列には終端がないので、`Iterator`は決して
        // `None`を返さず、常に`Some`が返される。
        Some(self.curr)
    }
}

// Returns a Fibonacci sequence generator
// フィボナッチ数列のジェネレータを返す。
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3` is an `Iterator` that generates: 0, 1, and 2.
    // `0..3`は0, 1, 2をジェネレートする`Iterator`
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`).
    // `for`は`None`を返すまで、イテレータを舐めていき、出てきた`Some`を
    // アンラップして変数（ここでは`i`）に束縛する。
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `take(n)` method reduces an `Iterator` to its first `n` terms.
    // `take(n)`メソッドは`Iterator`をはじめから`n`番目の要素までの部分に減らす。
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.
    // `skip(n)`メソッドは`Iterator`のはじめから`n`番目までの要素をとばす。
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // The `iter` method produces an `Iterator` over an array/slice.
    // `iter`メソッドは配列やスライスからイテレータを作成する。
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p>If your function returns a type that implements <code>MyTrait</code>, you can write its
return type as <code>-&gt; impl MyTrait</code>. This can help simplify your type signatures quite a lot!</p>
<pre><pre class="playground"><code class="language-rust editable">use std::iter;
use std::vec::IntoIter;

// This function combines two `Vec&lt;i32&gt;` and returns an iterator over it.
// Look how complicated its return type is!
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// This is the exact same function, but its return type uses `impl Trait`.
// Look how much simpler it is!
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<p>More importantly, some Rust types can't be written out. For example, every
closure has its own unnamed concrete type. Before <code>impl Trait</code> syntax, you had
to allocate on the heap in order to return a closure. But now you can do it all
statically, like this:</p>
<pre><pre class="playground"><code class="language-rust editable">// Returns a function that adds `y` to its input
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre></pre>
<p>You can also use <code>impl Trait</code> to return an iterator that uses <code>map</code> or <code>filter</code>
closures! This makes using <code>map</code> and <code>filter</code> easier. Because closure types don't
have names, you can't write out an explicit return type if your function returns
iterators with closures. But with <code>impl Trait</code> you can do this easily:</p>
<pre><pre class="playground"><code class="language-rust editable">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Clone
-->
<h1 id="クローン"><a class="header" href="#クローン">クローン</a></h1>
<!--
When dealing with resources, the default behavior is to transfer them during
assignments or function calls. However, sometimes we need to make a 
copy of the resource as well.
-->
<p>メモリ上の資源を扱う際、変数束縛や関数呼び出しを介して移動させるのがデフォルトの挙動です。しかしながら、場合によっては資源のコピーを作るのが適切なこともあります。</p>
<!--
The [`Clone`][clone] trait helps us do exactly this. Most commonly, we can 
use the `.clone()` method defined by the `Clone` trait.
-->
<p><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>トレイトはまさにこのためにあります。普通は<code>Clone</code>トレイトで定義されている<code>.clone()</code>を用います。</p>
<pre><pre class="playground"><code class="language-rust editable">// A unit struct without resources
// いかなる資源も持たない構造体
#[derive(Debug, Clone, Copy)]
struct Nil;

// A tuple struct with resources that implements the `Clone` trait
// `Clone`トレイトを実装する型の変数を資源として持つタプル
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // Instantiate `Nil`
    // `Nil`のインスタンスを作成
    let nil = Nil;
    // Copy `Nil`, there are no resources to move
    // `Nil`をコピー、移動させる資源は存在しない
    let copied_nil = nil;

    // Both `Nil`s can be used independently
    // いずれの`Nil`も独立に使用できる。
    println!(&quot;original: {:?}&quot;, nil);
    println!(&quot;copy: {:?}&quot;, copied_nil);

    // Instantiate `Pair`
    // `Pair`のインスタンスを作成
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // Copy `pair` into `moved_pair`, moves resources
    // `pair`を`moved_pair`にコピー、資源は移動(`move`)する。
    let moved_pair = pair;
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // Error! `pair` has lost its resources
    // エラー! `pair`は資源を失っている。
    //println!(&quot;original: {:?}&quot;, pair);
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。
    
    // Clone `moved_pair` into `cloned_pair` (resources are included)
    // `moved_pair`を`cloned_pair`にクローンする。（資源もクローンされる。）
    let cloned_pair = moved_pair.clone();
    // Drop the original pair using std::mem::drop
    // std::mem::dropを用いて元のpairをドロップする
    drop(moved_pair);

    // Error! `moved_pair` has been dropped
    // エラー! `moved_pair`はドロップされている。
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // TODO ^ Try uncommenting this line
    // TODO ^ この行をアンコメントしてみましょう。

    // The result from .clone() can still be used!
    // .clone()した値はまだ使用可能！
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h1>
<p>Rust doesn't have &quot;inheritance&quot;, but you can define a trait as being a superset
of another trait. For example:</p>
<pre><pre class="playground"><code class="language-rust editable">trait Person {
    fn name(&amp;self) -&gt; String;
}

// Student is a supertrait of Person.
// Implementing Student requires you to also impl Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) is a supertrait of both Programmer 
// and Student. Implementing CompSciStudent requires you to impl both subtraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.git_username()
    )
}

fn main() {}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-55"><a class="header" href="#参照-55">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">The Rust Programming Language chapter on supertraits</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disambiguating-overlapping-traits"><a class="header" href="#disambiguating-overlapping-traits">Disambiguating overlapping traits</a></h1>
<p>A type can implement many different traits. What if two traits both require the same name? For example, many traits might have a method named <code>get()</code>. They might even have different return types! </p>
<p>Good news: because each trait implementation gets its own <code>impl</code> block, it's 
clear which trait's <code>get</code> method you're implementing. </p>
<p>What about when it comes time to <em>call</em> those methods? To disambiguate between
them, we have to use Fully Qualified Syntax.</p>
<pre><pre class="playground"><code class="language-rust editable">trait UsernameWidget {
    // Get the selected username out of this widget
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // Get the selected age out of this widget
    fn get(&amp;self) -&gt; u8;
}

// A form with both a UsernameWidget and an AgeWidget
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // If you uncomment this line, you'll get an error saying 
    // &quot;multiple `get` found&quot;. Because, after all, there are multiple methods
    // named `get`.
    // println!(&quot;{}&quot;, form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-56"><a class="header" href="#参照-56">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">The Rust Programming Language chapter on Fully Qualified syntax</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro_rules"><a class="header" href="#macro_rules">macro_rules!</a></h1>
<!--
Rust provides a powerful macro system that allows metaprogramming. As you've
seen in previous chapters, macros look like functions, except that their name
ends with a bang `!`, but instead of generating a function call, macros are
expanded into source code that gets compiled with the rest of the program.
-->
<p>Rustはメタプログラミングを可能にする、パワフルなマクロシステムを備えています。これまで見てきたように、マクロは<code>!</code>で終わることを除けば関数のように見えます。関数と違うのは関数呼び出し(<code>function call</code>)を生成する代わりに、ソースコード中に展開され、周囲のプログラムとともにコンパイルされる点です。</p>
<!--
However, unlike macros in C and other languages, Rust macros are expanded into
abstract syntax trees, rather than string preprocessing, so you don't get
unexpected precedence bugs.
-->
<p>しかし、Cやその他の言語のマクロが文字列のプリプロセッシングをするのと異なり、Rustのマクロは抽象構文木へと展開されるので、予期せぬprecendece（演算子の優先順位）のバグに出くわすことがありません。</p>
<!--
Macros are created using the `macro_rules!` macro.
-->
<p>マクロを作成するには<code>macro_rules!</code>というマクロを使用します。</p>
<pre><pre class="playground"><code class="language-rust editable">// This is a simple macro named `say_hello`.
// `say_hello`という名のシンプルなマクロ
macro_rules! say_hello {
    // `()` indicates that the macro takes no argument.
    // `()`はマクロが引数をとらないことを示す。
    () =&gt; {
        // The macro will expand into the contents of this block.
        // マクロは（訳注: プリコンパイルの段階で）このブロック内の内容に展開されます。
        println!(&quot;Hello!&quot;);
    };
}

fn main() {
    // This call will expand into `println!(&quot;Hello&quot;);`
    // この呼び出しは`println!(&quot;Hello&quot;);`に置き換えられます。
    say_hello!()
}
</code></pre></pre>
<!--
So why are macros useful?
-->
<p>ではどうしてマクロは便利なのでしょうか？</p>
<!--
1. Don't repeat yourself. There are many cases where you may need similar
   functionality in multiple places but with different types. Often, writing a
   macro is a useful way to avoid repeating code. (More on this later)
-->
<ol>
<li>同じことを繰り返し書いてはいけない (Don't repeat yourself) から。
複数の場所で、別の型だけれど似たような機能が必要な時がよくあります。
しばしば、マクロはコードを繰り返し書くのを避ける有用な手段なのです（あとで詳述）。</li>
</ol>
<!--
2. Domain-specific languages. Macros allow you to define special syntax for a
   specific purpose. (More on this later)
-->
<ol start="2">
<li>ドメイン特化言語であるから。マクロを使うと、特定の目的のための特定の構文を定義することができます（あとで詳述）。</li>
</ol>
<!--
3. Variadic interfaces. Sometimes you want to define an interface that takes a
   variable number of arguments. An example is `println!` which could take any
   number of arguments, depending on the format string!. (More on this later)
-->
<ol start="3">
<li>可変個引数によるインターフェース。
取る引数の数が可変であるようなインターフェースを定義したくなることもあるでしょう。
例えば、<code>println!</code>は、フォーマット文字列に依存した任意の数の引数を取ることができます（あとで詳述）！</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
# Syntax
-->
<h1 id="構文"><a class="header" href="#構文">構文</a></h1>
<!--
In following subsections, we will show how to define macros in Rust.
There are three basic ideas:
-->
<p>以下のサブセクションでは、Rustにおいてマクロを定義する方法を示します。
3つの基本的な考え方があります：</p>
<!--
- [Patterns and Designators][designators]
- [Overloading][overloading]
- [Repetition][repetition]
-->
<ul>
<li><a href="macros/designators.html">パターンと識別子</a></li>
<li><a href="macros/overload.html">オーバーロード</a></li>
<li><a href="macros/repeat.html">繰り返し</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# Designators
-->
<h1 id="識別子"><a class="header" href="#識別子">識別子</a></h1>
<!--
The arguments of a macro are prefixed by a dollar sign `$` and type annotated
with a *designator*:
-->
<p>macroの引数は<code>$</code>が頭につきます。型は <em>識別子</em> (<code>designator</code>)でアノテーションされます。</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! create_function {
    // This macro takes an argument of designator `ident` and
    // creates a function named `$func_name`.
    // The `ident` designator is used for variable/function names.
    // このマクロは`ident`識別子に対応する値を引数として取り
    // `$func_name`という名の関数を作成する。
    // `ident`識別子は関数・変数の名前用の識別子である。
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // The `stringify!` macro converts an `ident` into a string.
            // `stringify!`というマクロは`ident`を文字列に変える。
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name));
        }
    };
}

// Create functions named `foo` and `bar` with the above macro.
// 上のマクロを利用して`foo`、`bar`という名の関数を作成する。
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // This macro takes an expression of type `expr` and prints
    // it as a string along with its result.
    // The `expr` designator is used for expressions.
    // このマクロは`expr`識別子に対応する値を引数として取り、
    // その結果を文字列としてプリントする。
    // `expr`識別子は式に対応する。
    ($expression:expr) =&gt; {
        // `stringify!` will convert the expression *as it is* into a string.
        // `stringify!`は式を *そのままの形で* 文字列に変換する
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // Recall that blocks are expressions too!
    // ブロックも式の一種であることを思い出しましょう!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<!--
These are some of the available designators:
-->
<p>使用できる識別子には以下のようなものがあります。</p>
<!--
* `block`
* `expr` is used for expressions
* `ident` is used for variable/function names
* `item`
* `literal` is used for literal constants
* `pat` (*pattern*)
* `path`
* `stmt` (*statement*)
* `tt` (*token tree*)
* `ty` (*type*)
* `vis` (*visibility qualifier*)
-->
<ul>
<li><code>block</code></li>
<li><code>expr</code> 式に使用</li>
<li><code>ident</code> 関数、変数の名前に使用</li>
<li><code>item</code></li>
<li><code>literal</code> はリテラル定数（訳注：文字だけではない。<a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">Literal expressions</a>を参照）に使用</li>
<li><code>pat</code> (<em>パターン</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>宣言</em>)</li>
<li><code>tt</code> (<em>トークンツリー</em>)</li>
<li><code>ty</code> (<em>型</em>)</li>
<li><code>vis</code> (<em>可視性修飾子</em>)（訳注：<code>pub (crate)</code>とか）</li>
</ul>
<!--
For a complete list, see the [Rust Reference].
-->
<p>完全なリストを見るには、<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rustリファレンス</a>を読んでください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Overload
-->
<h1 id="オーバーロード"><a class="header" href="#オーバーロード">オーバーロード</a></h1>
<!--
Macros can be overloaded to accept different combinations of arguments. 
In that regard, `macro_rules!` can work similarly to a match block:
-->
<p>マクロは異なる引数の組み合わせを取るようにオーバーロードすることができるため、<code>macro_rules!</code>はマッチと似たような使い方をすることができます。</p>
<pre><pre class="playground"><code class="language-rust editable">// `test!` will compare `$left` and `$right`
// in different ways depending on how you invoke it:
// `test!`は`$left`と`$right`を異なる呼び出し方に応じて
// 比較する。
macro_rules! test {
    // Arguments don't need to be separated by a comma.
    // Any template can be used!
    // 引数はカンマで区切らなくてもよい
    // テンプレートの形態は自由！
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ each arm must end with a semicolon.
    // それぞれの`=&gt;`節はセミコロンで終わる必要がある。
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Repeat
-->
<h1 id="繰り返し"><a class="header" href="#繰り返し">繰り返し</a></h1>
<!--
Macros can use `+` in the argument list to indicate that an argument may
repeat at least once, or `*`, to indicate that the argument may repeat zero or
more times.
-->
<p>マクロは引数のリストの中で<code>+</code>を使うことができ、そうすることによって、引数が少なくとも1回以上繰り返されるということを示すことができます。同様に<code>*</code>の場合は、0以上を示します。</p>
<!--
In the following example, surrounding the matcher with `$(...),+` will
match one or more expression, separated by commas.
Also note that the semicolon is optional on the last case.
-->
<p>以下の例では、マッチ対象を <code>$(...),+</code>で囲むことにより、カンマで区切られた1つ以上の式とマッチします。最後のセミコロンは必須ではないことに注目しましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">// `min!` will calculate the minimum of any number of arguments.
// `min!`は引数として与えられた数字の中の最低の値を計算する。
macro_rules! find_min {
    // Base case:
    // 基本となるケース
    ($x:expr) =&gt; ($x);
    // `$x` followed by at least one `$y,`
    // `$x`に少なくとも1つの`$y`が続く場合
    ($x:expr, $($y:expr),+) =&gt; (
        // Call `find_min!` on the tail `$y`
        // `find_min!`を残りの`$y`に対して再帰的に適用
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2, 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dry-dont-repeat-yourself"><a class="header" href="#dry-dont-repeat-yourself">DRY (Don't Repeat Yourself)</a></h1>
<!--
Macros allow writing DRY code by factoring out the common parts of functions
and/or test suites. Here is an example that implements and tests the `+=`, `*=`
and `-=` operators on `Vec<T>`:
-->
<p>マクロは関数やテストなどにおいて、共通の部分を抽出することでDRYなコードを書くのに役立ちます。ここでは<code>+=</code>、<code>*=</code>、<code>-=</code>、<code>Vec&lt;T&gt;</code>を実装、テストするにあたって、マクロがどのように役立つかを見ていきます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // The `tt` (token tree) designator is used for
    // operators and tokens.
    // `tt` （トークン木）識別子は演算子とトークン用の識別子です。
    ($a:expr, $b:expr, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.
// `add_assign`、`mul_assign`、`sub_assign`、関数を実装
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        };
    }

    // Test `add_assign`, `mul_assign`, and `sub_assign`.
    // `add_assign`と`mul_assign`と`sub_assign`をテスト
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-shell">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Domain Specific Languages (DSLs)
-->
<h1 id="domain-specific-languages-ドメイン特化言語dsls"><a class="header" href="#domain-specific-languages-ドメイン特化言語dsls">Domain Specific Languages (ドメイン特化言語、DSLs)</a></h1>
<!--
A DSL is a mini "language" embedded in a Rust macro. It is completely valid
Rust because the macro system expands into normal Rust constructs, but it looks
like a small language. This allows you to define concise or intuitive syntax for
some special functionality (within bounds).
-->
<p>DSLとはRustマクロに埋め込まれた小さな「言語」のことです。
マクロ機能は通常のRustのプログラムへと展開されるので、これは完全に正当なRustなのですが、まるで小さな言語であるかのように見えます。
これにより、（一定の条件のもとで）なんらかの特定の機能のための簡潔・直感的な構文を定義することができるようになります。</p>
<!--
Suppose that I want to define a little calculator API. I would like to supply
an expression and have the output printed to console.
-->
<p>ちょっとした計算機APIを定義したいとしましょう。
式を与えると、出力がコンソールに書き出されるようにしたいです。</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
                                 // 型を整数に制約
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!
                   // `eval`はRustのキーワード *じゃない* よね！
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<!--
Output:
-->
<p>出力はこうなります：</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<!--
This was a very simple example, but much more complex interfaces have been
developed, such as [`lazy_static`](https://crates.io/crates/lazy_static) or
[`clap`](https://crates.io/crates/clap).
-->
<p>これはとても単純な例ですが、<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>や<a href="https://crates.io/crates/clap"><code>clap</code></a>のように、もっと複雑なインターフェースも開発されています。</p>
<!--
Also, note the two pairs of braces in the macro. The outer ones are
part of the syntax of `macro_rules!`, in addition to `()` or `[]`.
-->
<p>また、マクロの中に2組の括弧があることにも注目してください。
外側のは、<code>()</code>や<code>[]</code>に加え、<code>macro_rules!</code>の構文の一部です。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Variadic Interfaces
-->
<h1 id="可変個引数によるインターフェース"><a class="header" href="#可変個引数によるインターフェース">可変個引数によるインターフェース</a></h1>
<!--
A _variadic_ interface takes an arbitrary number of arguments. For example,
`println!` can take an arbitrary number of arguments, as determined by the
format string.
-->
<p><em>可変個引数の</em>インターフェースとは、任意の数の引数を取るものです。
例えば、<code>println!</code>は、フォーマット文字列の定義に従い、任意の数の引数を取ることができます。</p>
<!--
We can extend our `calculate!` macro from the previous section to be variadic:
-->
<p>前のセクションの<code>calculate!</code>マクロを、可変個引数に拡張することができます：</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! calculate {
    // 単一の`eval`のためのパターン
    // The pattern for a single `eval`
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // 複数の`eval`を再帰的に分解する
    // Decompose multiple `eval`s recursively
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
                 // ほら！可変な`calculate!`だよ！
    calculate! { // Look ma! Variadic `calculate!`!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<!--
Output:
-->
<p>出力：</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Error handling
-->
<h1 id="エラーハンドリング"><a class="header" href="#エラーハンドリング">エラーハンドリング</a></h1>
<!--
Error handling is the process of handling the possibility of failure. For
example, failing to read a file and then continuing to use that *bad* input
would clearly be problematic. Noticing and explicitly managing those errors
saves the rest of the program from various pitfalls.
-->
<p>エラーハンドリングとは失敗の起きる可能性を扱うプロセスのことです。例えば、ファイルを読み込むのに失敗した際、その <em>誤った</em> インプットを使い続けるのは明らかに問題です。そのようなエラーを通知して明示的に扱うことで、残りのプログラムに問題が波及することを防ぐことができるようになります。</p>
<!--
There are various ways to deal with errors in Rust, which are described in the
following subchapters. They all have more or less subtle differences and different
use cases. As a rule of thumb:
-->
<p>Rustには、これからこの章で見ていく通り、エラーを処理するための様々な方法が存在します。それらは全て僅かに異なり、ユースケースも異なります。経験則として：</p>
<!--
An explicit `panic` is mainly useful for tests and dealing with unrecoverable errors.
For prototyping it can be useful, for example when dealing with functions that
haven't been implemented yet, but in those cases the more descriptive `unimplemented`
is better. In tests `panic` is a reasonable way to explicitly fail.
-->
<p>明示的な<code>panic</code>はテストや復旧不可能なエラーに対して効果的です。プロトタイプにも便利で、例えば未実装の関数を扱う時などに有効ですが、このような場合にはより叙述的な<code>unimplemented</code>の方が良いでしょう。テストにおいては<code>panic</code>は明示的にテストを失敗させるための良い手法になるでしょう。</p>
<!--
The `Option` type is for when a value is optional or when the lack of a value is
not an error condition. For example the parent of a directory - `/` and `C:` don't
have one. When dealing with `Option`s, `unwrap` is fine for prototyping and cases
where it's absolutely certain that there is guaranteed to be a value. However `expect`
is more useful since it lets you specify an error message in case something goes
wrong anyway.
-->
<p><code>Option</code>型は値があるとは限らない場合や、値が無いことがエラーの条件とならない場合に有効です。例えば親ディレクトリ（<code>/</code>や<code>C:</code>はそれを持ちません）などです。<code>Option</code>を扱う際は、<code>unwrap</code>がプロトタイプや値が確実に存在することが約束されるケースに使えます。しかし、<code>expect</code>の方が何かが上手くいかなかった際にエラーメッセージを指定することができるため、より便利でしょう。</p>
<!--
When there is a chance that things do go wrong and the caller has to deal with the
problem, use `Result`. You can `unwrap` and `expect` them as well (please don't
do that unless it's a test or quick prototype).
-->
<p>何かが上手くいかない可能性があったり、呼び出し元が問題を処理しなければならない時は、<code>Result</code>を使いましょう。<code>unwrap</code>や<code>expect</code>を実行することもできます（テストや短期的なプロトタイプ以外では使わないでください）。</p>
<!--
For a more rigorous discussion of error handling, refer to the error
handling section in the [official book][book].
-->
<p>より詳細なエラーハンドリングに関する議論については、<a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">オフィシャルブック</a>の該当の章を参考にしてください。</p>
<blockquote>
<p>訳注: こちらのQiitaの日本語記事も参考になります。<a href="http://qiita.com/tatsuya6502/items/cd41599291e2e5f38a4a">「RustでOption値やResult値を上手に扱う」</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic"><code>panic</code></a></h1>
<!--
The simplest error handling mechanism we will see is `panic`. It prints an 
error message, starts unwinding the stack, and usually exits the program. 
Here, we explicitly call `panic` on our error condition: 
-->
<p><code>panic</code>は、最もシンプルなエラーハンドリングの仕組みです。エラーメッセージの出力、スタックの巻き戻し、そして多くの場合プログラムの終了を実行します。
例として、エラー条件に対して明示的に<code>panic</code>を呼び出してみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // Princesses hate snakes, so we need to stop if she disapproves!
    // お姫様はヘビを嫌うので、贈り物として渡してはいけません！
    if gift == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;teddy bear&quot;);
    give_princess(&quot;snake&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# `Option` & `unwrap`
-->
<h1 id="option-と-unwrap"><a class="header" href="#option-と-unwrap"><code>Option</code> と <code>unwrap</code></a></h1>
<!--
In the last example, we showed that we can induce program failure at will. 
We told our program to `panic` if the princess received an inappropriate 
gift - a snake. But what if the princess expected a gift and didn't receive 
one? That case would be just as bad, so it needs to be handled!
 -->
<p>以前の例では、お姫様に不適切な贈り物（ヘビ）を渡した際に<code>panic</code>を呼び出すことによって、自由にプログラムの実行を失敗させられることが分かりました。では、お姫様が贈り物を期待しているにもかかわらず、何も受け取らなかったらどうなるでしょう？ヘビを受け取るのに劣らない悲惨なケースになるので、エラーハンドリングする必要があります！</p>
<!--
We *could* test this against the null string (`""`) as we do with a snake. 
Since we're using Rust, let's instead have the compiler point out cases 
where there's no gift.
-->
<p>このケースに対して、ヘビと同じように、空文字列（<code>&quot;&quot;</code>）と比較することもできますが、せっかくRustを使っているので、その代わりにコンパイラに贈り物がないケースを指摘させてみましょう。</p>
<!--
An `enum` called `Option<T>` in the `std` library is used when absence is a 
possibility. It manifests itself as one of two "options":
-->
<p><code>std</code>ライブラリの中の、<code>Option&lt;T&gt;</code>と呼ばれる<code>enum</code>は、任意の型<code>T</code>である変数の値が存在しない可能性がある場合に用いられます。値の状態によって、下記２つのパターンのうちの１つとして扱われます。</p>
<!--
* `Some(T)`: An element of type `T` was found
* `None`: No element was found
-->
<ul>
<li><code>Some(T)</code>: 型<code>T</code>の値がある場合</li>
<li><code>None</code>: 値が存在しない場合。</li>
</ul>
<!--
These cases can either be explicitly handled via `match` or implicitly with 
`unwrap`. Implicit handling will either return the inner element or `panic`.
-->
<p>これらは<code>match</code>を用いて明示的に扱うこともできますし、<code>unwrap</code>で暗黙に処理することもできます。後者は<code>Some</code>の中の値を返すか<code>panic</code>するかのどちらかです。</p>
<!--
Note that it's possible to manually customize `panic` with [expect][expect], 
but `unwrap` otherwise leaves us with a less meaningful output than explicit 
handling. In the following example, explicit handling yields a more 
controlled result while retaining the option to `panic` if desired.
-->
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>メソッドを用いて、<code>panic</code>を手動でカスタマイズできることに触れておきましょう。これは（<code>unwrap</code>をそのまま用いた場合よりも）内容が理解しやすいエラーメッセージを出力するのに役立ちます。次の例では、結果をより明示的に、可能ならいつでも<code>panic</code>できるように扱っていきます。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// The commoner has seen it all, and can handle any gift well.
// All gifts are handled explicitly using `match`.
// 庶民(commoner)は経験豊富なので、大体どんな状況にも対処できます。
// あらゆる贈り物は`match`を用いて手動で処理されます。
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm putting this snake back in the forest.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// Our sheltered princess will `panic` at the sight of snakes.
// All gifts are handled implicitly using `unwrap`.
// 温室育ちのお姫様はヘビを見ると`panic`します。
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` returns a `panic` when it receives a `None`.
    // `unwrap`を使用すると値が`None`だった際に`panic`を返します。
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;cabbage&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Unpacking options with `?`
-->
<h1 id="によるoptionのアンパック"><a class="header" href="#によるoptionのアンパック"><code>?</code>による<code>Option</code>のアンパック</a></h1>
<!--
You can unpack `Option`s by using `match` statements, but it's often easier to
use the `?` operator. If `x` is an `Option`, then evaluating `x?` will return
the underlying value if `x` is `Some`, otherwise it will terminate whatever
function is being executed and return `None`.
-->
<p><code>Option</code>をアンパックするには<code>match</code>文を使うこともできますが、<code>?</code>を使う方が簡単になることが多いでしょう。<code>Option</code>の<code>x</code>があるとすると、<code>x?</code>を評価した値は、<code>x</code>が<code>Some</code>の場合は<code>x</code>に格納された値となり、そうでなければ実行中の関数を終了させ、<code>None</code>を返します。</p>
<pre><pre class="playground"><code class="language-rust editable">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
	// If `current_age` is `None`, this returns `None`.
	// If `current_age` is `Some`, the inner `u8` gets assigned to `next_age`
    // `current_age`が`None`の場合、`None`を返す。
    // `current_age`が`Some`の場合、内部の`u8`型の値が`next_age`に代入される。
    let next_age: u8 = current_age?;
    Some(format!(&quot;Next year I will be {}&quot;, next_age))
}
</code></pre></pre>
<!--
You can chain many `?`s together to make your code much more readable.
-->
<p>多くの<code>?</code>を共に使うことで、リーダブルなコードを書くことができます。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {

    // Gets the area code of the phone number of the person's job, if it exists.
    // その人の市外局番が存在する場合、取得する。
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // This would need many nested `match` statements without the `?` operator.
        // It would take a lot more code - try writing it yourself and see which
        // is easier.
        // `?`がなければ、多くのネストされた`match`文を必要とするため、より長いコードとなる。
        // 実際に書いて、どちらの方が簡単か確かめてみましょう。
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinators-map"><a class="header" href="#combinators-map">Combinators: <code>map</code></a></h1>
<!--
`match` is a valid method for handling `Option`s. However, you may 
eventually find heavy usage tedious, especially with operations only valid 
with an input. In these cases, [combinators][combinators] can be used to 
manage control flow in a modular fashion.
-->
<p><code>match</code>は<code>Option</code>を扱うのに適したメソッドです。しかし、大量にこれを使用しているとじきに億劫になってくるでしょう。引数の値が有効である（訳注: この場合は<code>None</code>でない）必要がある関数を扱う際には特にそうです。
In these cases, <a href="https://doc.rust-lang.org/book/glossary.html#combinators">combinators</a> can be used to manage control flow in a modular fashion.</p>
<!--
`Option` has a built in method called `map()`, a combinator for the simple 
mapping of `Some -> Some` and `None -> None`. Multiple `map()` calls can be 
chained together for even more flexibility.
-->
<p><code>Some -&gt; Some</code>あるいは<code>None -&gt; None</code>の単純な操作を適用する必要がある場合には、<code>Option</code>は<code>map()</code>というビルトインのメソッドを提供していますので、これを使用しましょう。
<code>map()</code>のフレキシビリティは、複数の<code>map()</code>をチェインしなければならない場合にさらに際立ちます。</p>
<!--
In the following example, `process()` replaces all functions previous
to it while staying compact.
-->
<p>以下の例では、<code>process()</code>が直前の関数全てを用いた場合と同じ機能を、よりコンパクトに果たしているのがわかります。</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Peeling food. If there isn't any, then return `None`.
// Otherwise, return the peeled food.
// 食べ物の皮をむく。存在しない場合は単純に`None`を返す。
// そうでなければ皮を向いた食べ物を返す。
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
// 上と同じように、食べ物を切る前に、皮を向いた食べ物の有無を知る必要がある。
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
// 上のチェックと同様だが`match`の代わりに`map()`を使用している。
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// A function to peel, chop, and cook food all in sequence.
// We chain multiple uses of `map()` to simplify the code.
// 複数の`map()`をチェインさせて、上のプロセスをシンプルにすることもできる。
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// Check whether there's food or not before trying to eat it!
// 食べる前に、食べ物の有無をチェックするのは大事ですよね!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    // よりシンプルな見た目の`process()`を使用する。
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-57"><a class="header" href="#参照-57">参照</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinators-and_then"><a class="header" href="#combinators-and_then">Combinators: <code>and_then</code></a></h1>
<!--
`map()` was described as a chainable way to simplify `match` statements. 
However, using `map()` on a function that returns an `Option<T>` results 
in the nested `Option<Option<T>>`. Chaining multiple calls together can 
then become confusing. That's where another combinator called `and_then()`, 
known in some languages as flatmap, comes in.
-->
<p>先ほどは<code>map()</code>を、チェイン構文を用いて<code>match</code>文を単純化する物として説明しました。しかし<code>Option&lt;T&gt;</code>を返す関数に対しての<code>map()</code>の使用はネストした<code>Option&lt;Option&lt;T&gt;&gt;</code>を生じさせます。ですので、複数の関数呼び出しをチェインさせることは混乱を招く場合があります。そんな時こそ<code>and_then()</code>の出番です。他の言語ではflatmapと呼ばれることもあります。</p>
<!--
`and_then()` calls its function input with the wrapped value and returns the result. If the `Option` is `None`, then it returns `None` instead.
-->
<p><code>and_then()</code>は引数として与えられた関数にラップされた値を渡しますが、その値が<code>None</code>だった場合は<code>None</code>を返します。</p>
<!--
In the following example, `cookable_v2()` results in an `Option<Food>`. 
Using `map()` instead of `and_then()` would have given an 
`Option<Option<Food>>`, which is an invalid type for `eat()`.
-->
<p>以下の例では<code>cookable_v2()</code>は<code>Option&lt;Food&gt;</code>を返すため、<code>and_then()</code>ではなく<code>map()</code>を使用すると最終的に<code>Option&lt;Option&lt;Food&gt;&gt;</code>になります。これは<code>eat()</code>には不適切な型です。</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// We don't have the ingredients to make Sushi.
// 我々は寿司の材料を持っていない
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// We have the recipe for everything except Cordon Bleu.
// コルドン・ブルー(Cordon Bleu)のレシピも持っていない。
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// To make a dish, we need both the recipe and the ingredients.
// We can represent the logic with a chain of `match`es:
// 料理を作るためには、材料とレシピの両方が必要。
// ロジックの流れを`match`のチェインで表す。
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_ingredients(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// This can conveniently be rewritten more compactly with `and_then()`:
// `and_then()`を用いることで、同じことをよりコンパクトに表現できる。
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-58"><a class="header" href="#参照-58">参照</a></h3>
<!--
[closures][closures], [`Option`][option], and [`Option::and_then()`][and_then]
-->
<p><a href="error/option_unwrap/../../fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result"><code>Result</code></a></h1>
<!--
[`Result`][result] is a richer version of the [`Option`][option] type that
describes possible *error* instead of possible *absence*.
-->
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>は、リッチなバージョンの<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>型で,
<em>値の不在</em>の可能性の代わりに<em>エラー</em>の可能性を示します。</p>
<!--
That is, `Result<T, E>` could have one of two outcomes:
-->
<p>つまり、<code>Result&lt;T, E&gt;</code>は以下の２つの結果を持ちます。</p>
<!--
* `Ok(T)`: An element `T` was found
* `Err(E)`: An error was found with element `E`
-->
<ul>
<li><code>Ok&lt;T&gt;</code>: 要素<code>T</code>が見つかった場合</li>
<li><code>Err&lt;E&gt;</code>: 要素<code>E</code>とともにエラーが見つかった場合</li>
</ul>
<!--
By convention, the expected outcome is `Ok` while the unexpected outcome is `Err`.
-->
<p>慣例により、<code>Ok</code>が期待される結果であり、<code>Err</code>は期待されない結果です。</p>
<!--
Like `Option`, `Result` has many methods associated with it. `unwrap()`, for
example, either yields the element `T` or `panic`s. For case handling,
there are many combinators between `Result` and `Option` that overlap.
-->
<p><code>Option</code>と同様、<code>Result</code>は多くのメソッドを持ちます。例えば<code>unwrap()</code>は、<code>T</code>もしくは<code>panic</code>をもたらします。エラーハンドリングでは、<code>Result</code>と<code>Option</code>で重複するコンビネータが多くあります。</p>
<!--
In working with Rust, you will likely encounter methods that return the
`Result` type, such as the [`parse()`][parse] method. It might not always
be possible to parse a string into the other type, so `parse()` returns a
`Result` indicating possible failure.
-->
<p>Rustを書いていく中で、<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>メソッドなど、<code>Result</code>型を返すメソッドを目にするでしょう。文字列を他の型にパースすることは必ずしも成功する訳ではないため、<code>Result</code>を返すことで失敗するケースについてもカバーできるのです。</p>
<!--
Let's see what happens when we successfully and unsuccessfully `parse()` a string:
-->
<p>早速、文字列を<code>parse()</code>した場合の成功例と失敗例を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // Let's try using `unwrap()` to get the number out. Will it bite us?
    // `unwrap()`で数字を取り出してみましょう。痛い目を見るでしょうか？
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<!--
In the unsuccessful case, `parse()` leaves us with an error for `unwrap()`
to `panic` on. Additionally, the `panic` exits our program and provides an
unpleasant error message.
-->
<p>失敗例では、<code>parse()</code>がエラーを返すため<code>unwrap()</code>がパニックします。そして、<code>panic</code>はプログラムを終了させて不快なエラーメッセージを出力します。</p>
<!--
To improve the quality of our error message, we should be more specific
about the return type and consider explicitly handling the error.
-->
<p>エラーメッセージを改善するために、リターン型に対してもっと明確になるべきで、またエラーを明示的に処理することを考えるべきです。</p>
<!--
## Using `Result` in `main`
-->
<h2 id="main内で使うresult"><a class="header" href="#main内で使うresult"><code>main</code>内で使う<code>Result</code></a></h2>
<!--
The `Result` type can also be the return type of the `main` function if
specified explicitly. Typically the `main` function will be of the form:
-->
<p><code>Result</code>型は、明示的な指定により<code>main</code>関数のリターン型にもなります。一般に、<code>main</code>関数は以下のような形になるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<!--
However `main` is also able to have a return type of `Result`. If an error
occurs within the `main` function it will return an error code and print a debug
representation of the error (using the [`Debug`] trait). The following example
shows such a scenario and touches on aspects covered in [the following section].
-->
<p>一方<code>main</code>で<code>Result</code>をリターン型とすることも可能です。エラーが<code>main</code>関数内で発生した時、エラーコードを返し、エラーに関するデバッグ表記を（<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>トレートを使って）出力します。以下の例ではそのようなシナリオを示し、<a href="error/result/early_returns.html">この先の節</a>でカバーする内容に触れていきます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}
</code></pre></pre>
<!--
[the following section]: result/early_returns.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# `map` for `Result`
-->
<h1 id="resultのmap"><a class="header" href="#resultのmap"><code>Result</code>の<code>map</code></a></h1>
<!--
Panicking in the previous example's `multiply` does not make for robust code.
Generally, we want to return the error to the caller so it can decide what is
the right way to respond to errors.
-->
<p>前の例で見た<code>multiply</code>でのパニックは、コードを強固にするためには書きません。一般に、呼び出した側がエラーをどのように対処するべきかを自由に決められるように、エラーを呼び出した場所に返すのが好ましいです。</p>
<!--
We first need to know what kind of error type we are dealing with. To determine
the `Err` type, we look to [`parse()`][parse], which is implemented with the
[`FromStr`][from_str] trait for [`i32`][i32]. As a result, the `Err` type is
specified as [`ParseIntError`][parse_int_error].
-->
<p>まずは、どのようなエラー型を扱っているのかを知る必要があります。<code>Err</code>型を定めるために、<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>に対し<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>トレートを使って実装された<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>を見てみましょう。結果、<code>Err</code>型は<a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>というものであることが分かります。</p>
<!--
In the example below, the straightforward `match` statement leads to code
that is overall more cumbersome.
-->
<p>以下の例では、単純な<code>match</code>文が全体として扱いづらいコードにしています。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// With the return type rewritten, we use pattern matching without `unwrap()`.
// リターン型を再度記述することで、パターンマッチングを`unwrap()`なしで行います。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    // ここは以前と変わらず、妥当な解を与えます。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    // こちらは今度は有益なエラーメッセージを与えます。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<!--
Luckily, `Option`'s `map`, `and_then`, and many other combinators are also
implemented for `Result`. [`Result`][result] contains a complete listing.
-->
<p>幸運にも、<code>Option</code>の<code>map</code>、<code>and_then</code>、その他多くのコンビネータも<code>Result</code>のために実装されています。<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>に全てのリストが記載されています。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// As with `Option`, we can use combinators such as `map()`.
// This function is otherwise identical to the one above and reads:
// Modify n if the value is valid, otherwise pass on the error.
// `Option`と同様、`map()`などのコンビネータを使うことができます。
// この関数は`map()`を使っている点以外は上記の関数と同じで、
// 値が有効ならnを変更し、無効であればエラーをそのまま見送ります。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    // ここは以前と変わらず、妥当な解を与えます。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    // こちらは今度は有益なエラーメッセージを与えます。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# aliases for `Result`
-->
<h1 id="resultに対するエイリアス"><a class="header" href="#resultに対するエイリアス"><code>Result</code>に対するエイリアス</a></h1>
<!--
How about when we want to reuse a specific `Result` type many times?
Recall that Rust allows us to create [aliases][typealias]. Conveniently,
we can define one for the specific `Result` in question.
-->
<p>特定の<code>Result</code>型を何度も使いたくなるのはどんな時でしょう？Rustは<a href="error/result/../../types/alias.html">エイリアス</a>の作成をサポートしていたことを思い出してください。便利なことに、特定の<code>Result</code>型に対しても定義することができます。</p>
<!--
At a module level, creating aliases can be particularly helpful. Errors
found in a specific module often have the same `Err` type, so a single alias
can succinctly define *all* associated `Results`. This is so useful that the
`std` library even supplies one: [`io::Result`][io_result]!
-->
<p>モジュールレベルでは、エイリアスの作成は非常に役に立ちます。特定のモジュールで見られるエラーは同じ<code>Err</code>型を持つため、単一のエイリアスで簡潔に<code>Results</code>に関わる<em>全て</em>を定義できます。<code>std</code>ライブラリが提供するもの（<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>）もあるほど有益なのです！</p>
<!--
Here's a quick example to show off the syntax:
-->
<p>簡単な例で構文を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// Define a generic alias for a `Result` with the error type `ParseIntError`.
// `ParseIntError`を`Err`の型として持つ全ての`Result`のジェネリックエイリアス
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Use the above alias to refer to our specific `Result` type.
// 上で定義したエイリアス（この場所特有の`Result`型）を使用
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// Here, the alias again allows us to save some space.
// もう一度使用。エイリアスによって再度明記する必要性がない。
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-59"><a class="header" href="#参照-59">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Early returns
-->
<h1 id="早期リターン"><a class="header" href="#早期リターン">早期リターン</a></h1>
<!--
In the previous example, we explicitly handled the errors using combinators.
Another way to deal with this case analysis is to use a combination of
`match` statements and *early returns*.
-->
<p>前の例では、コンビネータの活用によりエラーを明示的に処理しました。場合分けに対する別の対処法として、<code>match</code>文と早期リターンを組み合わせて使うこともできます。</p>
<!--
That is, we can simply stop executing the function and return the error if
one occurs. For some, this form of code can be easier to both read and
write. Consider this version of the previous example, rewritten using early returns:
-->
<p>つまり、エラーが発生した時点で関数の実行を止め、エラーを返してしまうという単純な方法が使えるということです。この方法の方がより読みやすく書きやすい場合があります。早期リターンを使って実装された、前の例の新たなバージョンを考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<!--
At this point, we've learned to explicitly handle errors using combinators
and early returns. While we generally want to avoid panicking, explicitly
handling all of our errors is cumbersome.
-->
<p>ここまでで、コンビネータと早期リターンによる明示的なエラーハンドリングについて学びました。しかし、パニックは一般に避けたいですが、全てのエラーを明示的に処理するのも厄介でしょう。</p>
<!--
In the next section, we'll introduce `?` for the cases where we simply
need to `unwrap` without possibly inducing `panic`.
-->
<p>次の節では、<code>panic</code>を発生させずに<code>unwrap</code>する必要があるケースのための<code>?</code>について紹介していきます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Introducing `?`
-->
<h1 id="の導入"><a class="header" href="#の導入"><code>?</code>の導入</a></h1>
<!--
Sometimes we just want the simplicity of `unwrap` without the possibility of
a `panic`. Until now, `unwrap` has forced us to nest deeper and deeper when
what we really wanted was to get the variable *out*. This is exactly the purpose of `?`.
-->
<p>時には<code>panic</code>の可能性を無視して、<code>unwrap</code>のシンプルさを活用したいこともあるでしょう。今までの<code>unwrap</code>は、値を<em>取り出す</em>ためだけであろうとも、ネストを深く書くことを要求しました。そして、これがまさに<code>?</code>の目的です。</p>
<!--
Upon finding an `Err`, there are two valid actions to take:
-->
<p><code>Err</code>を見つけるにあたり、２つのとるべき行動があります。</p>
<!--
1. `panic!` which we already decided to try to avoid if possible
2. `return` because an `Err` means it cannot be handled
-->
<ol>
<li>可能な限り避けたいと決めた<code>panic!</code></li>
<li><code>Err</code>は処理できないことを意味するため<code>return</code></li>
</ol>
<!--
`?` is *almost*[^†] exactly equivalent to an `unwrap` which `return`s
instead of `panic`king on `Err`s. Let's see how we can simplify the earlier
example that used combinators:
-->
<p><code>?</code>は<em>ほぼ</em><sup class="footnote-reference"><a href="#†">1</a></sup>まさしく、<code>Err</code>に対して<code>panic</code>するより<code>return</code>するという点で<code>unwrap</code>と同等です。コンビネータを使った以前の例をどれだけ簡潔に書けるか見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<!--
## The `try!` macro
-->
<h2 id="tryマクロ"><a class="header" href="#tryマクロ"><code>try!</code>マクロ</a></h2>
<!--
Before there was `?`, the same functionality was achieved with the `try!` macro.
The `?` operator is now recommended, but you may still find `try!` when looking
at older code. The same `multiply` function from the previous example
would look like this using `try!`:
-->
<p><code>?</code>ができる前、同様の動作を<code>try!</code>マクロによって行うことができました。現在は<code>?</code>オペレータが推奨されていますが、古いコードでは<code>try!</code>に出会うこともあります。<code>try!</code>を使って前の例と同じ<code>multiply</code>関数を実装すると、以下のようになるでしょう。</p>
<pre><pre class="playground"><code class="language-rust editable">// To compile and run this example without errors, while using Cargo, change the value 
// of the `edition` field, in the `[package]` section of the `Cargo.toml` file, to &quot;2015&quot;.
// Cargoを使いながらこの例をエラーなくコンパイル、及び実行する場合、
// `Cargo.toml`ファイル内、`[package]`セクションの`edition`の値を&quot;2015&quot;に変更してください。

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<!--
[^†]: See [re-enter ?][re_enter_?] for more details.
-->
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>詳細は<a href="error/result/../multiple_error_types/reenter_question_mark.html">re-enter ?</a>を参照。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
# Multiple error types
-->
<h1 id="複数のエラー型"><a class="header" href="#複数のエラー型">複数のエラー型</a></h1>
<!--
The previous examples have always been very convenient; `Result`s interact
with other `Result`s and `Option`s interact with other `Option`s.
-->
<p><code>Result</code>が他の<code>Result</code>と連携したり、<code>Option</code>が他の<code>Option</code>と連携するなど、今までの例はとても便利な物でした。</p>
<!--
Sometimes an `Option` needs to interact with a `Result`, or a
`Result<T, Error1>` needs to interact with a `Result<T, Error2>`. In those
cases, we want to manage our different error types in a way that makes them
composable and easy to interact with.
-->
<p>時には<code>Option</code>が<code>Result</code>と連携したり、<code>Result&lt;T, Error1&gt;</code>が<code>Result&lt;T, Error2&gt;</code>と連携する必要もあるでしょう。そのような場面では、異なるエラー型を構成しやすく、かつ連携しやすく管理したいです。</p>
<!--
In the following code, two instances of `unwrap` generate different error
types. `Vec::first` returns an `Option`, while `parse::<i32>` returns a
`Result<i32, ParseIntError>`:
-->
<p>以下のコードは<code>unwrap</code>の２つのインスタンスが異なるエラー型を生成します。<code>Vec::first</code>は<code>Option</code>を返し、一方で<code>parse::&lt;i32&gt;</code>は<code>Result&lt;i32, ParseIntError&gt;</code>を返しています。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
                                      // エラー１の生成
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
                                      // エラー２の生成
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1: the input vector is empty
    // エラー１：入力が空ベクトル

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
    // エラー２：要素が数字としてパースできない
}
</code></pre></pre>
<!--
Over the next sections, we'll see several strategies for handling these kind of problems.
-->
<p>この先の節では、これらの問題を処理する方法について見ていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Pulling `Result`s out of `Option`s
-->
<h1 id="optionからresultを取り出す"><a class="header" href="#optionからresultを取り出す"><code>Option</code>から<code>Result</code>を取り出す</a></h1>
<!--
The most basic way of handling mixed error types is to just embed them in each
other.
-->
<p>混在するエラー型に対する最も基本的な対処法は、単にお互いを埋め込んでしまうことです。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: the input vector is empty
    // エラー１：入力が空ベクトル

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
    // エラー２：要素が数字としてパースできない
}
</code></pre></pre>
<!--
There are times when we'll want to stop processing on errors (like with
[`?`][enter_question_mark]) but keep going when the `Option` is `None`. A
couple of combinators come in handy to swap the `Result` and `Option`.
-->
<p>中には、<code>Option</code>の中身が<code>None</code>の場合はそのまま処理を進め、エラーの検出に限り実行を止めたいという場合もあるでしょう（<a href="error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a>を使った時のように）。いくつかのコンビネータによって簡単に<code>Result</code>と<code>Option</code>をスワップすることができます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Defining an error type
-->
<h1 id="エラー型を定義する"><a class="header" href="#エラー型を定義する">エラー型を定義する</a></h1>
<!--
Sometimes it simplifies the code to mask all of the different errors with a
single type of error.  We'll show this with a custom error.
-->
<p>異なるエラー型をマスクし単一のエラー型として扱えるようにすると、コードがシンプルになる場合があります。ここでは自前のエラー型でそれを示してみます。</p>
<!--
Rust allows us to define our own error types. In general, a "good" error type:
-->
<p>Rustはユーザーによる新たなエラー型の定義をサポートします。一般に「良い」エラー型は、</p>
<!--
* Represents different errors with the same type
* Presents nice error messages to the user
* Is easy to compare with other types
    - Good: `Err(EmptyVec)`
    - Bad: `Err("Please use a vector with at least one element".to_owned())`
* Can hold information about the error
    - Good: `Err(BadChar(c, position))`
    - Bad: `Err("+ cannot be used here".to_owned())`
* Composes well with other errors
-->
<ul>
<li>異なるエラーをまとめて同じ型として扱う</li>
<li>ユーザーに優しいエラーメッセージを提供する</li>
<li>他の型との比較を楽にする
<ul>
<li>良い例：<code>Err(EmptyVec)</code></li>
<li>悪い例：<code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>エラーについての情報を保持できる
<ul>
<li>良い例：<code>Err(BadChar(c, position))</code></li>
<li>悪い例：<code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>他のエラーと問題なく連携できる</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// Define our error types. These may be customized for our error handling cases.
// Now we will be able to write our own errors, defer to an underlying error
// implementation, or do something in between.
// 自前のエラー型の定義。エラーハンドリングのケースの応じてカスタマイズされる。
// ここで新たなエラーを書くことができ、元のエラーの実装に処理を委譲したり、
// その手前で何らかの処理を挟むことができます。
#[derive(Debug, Clone)]
struct DoubleError;

// Generation of an error is completely separate from how it is displayed.
// There's no need to be concerned about cluttering complex logic with the display style.
// エラーの生成は、それがどのように表示されるかとは別物です。
// そのため、エラーの表示スタイルに関する複雑なロジックを煩雑になるなどと気にする必要はありません。
//
// Note that we don't store any extra info about the errors. This means we can't state
// which string failed to parse without modifying our types to carry that information.
// エラーに関する余分な情報を持たせていないことに注意してください。
// どの文字列がパースに失敗したかなどを出力することは、
// その情報を保持させるようにエラーの定義を修正しない限りできません。
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

// This is important for other errors to wrap this one.
impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        // Generic error, underlying cause isn't tracked.
        // 基本となるエラー、原因は記録されていない。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // Change the error to our new type.
        // エラーを新たな型に変更する。
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // Update to the new error type here also.
                // ここでも新たなエラー型に更新する。
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# `Box`ing errors
-->
<h1 id="エラーをboxする"><a class="header" href="#エラーをboxする">エラーを<code>Box</code>する</a></h1>
<!--
A way to write simple code while preserving the original errors is to [`Box`][box]
them.  The drawback is that the underlying error type is only known at runtime and not
[statically determined][dynamic_dispatch].
-->
<p>元のエラーを維持しながらシンプルなコードを書くには、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>してしまうと良いでしょう。欠点として、元のエラー型はランタイムまで判明せず、<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">静的に決定</a>されないことが挙げられます。</p>
<!--
The stdlib helps in boxing our errors by having `Box` implement conversion from
any type that implements the `Error` trait into the trait object `Box<Error>`,
via [`From`][from].
-->
<p>標準ライブラリは<code>Box</code>に、<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>を介してあらゆる<code>Error</code>トレートを実装した型から<code>Box&lt;Error&gt;</code>トレートオブジェクトへの変換を実装させることで、エラーをboxしやすくしてくれます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

// Change the alias to `Box&lt;error::Error&gt;`.
// エイリアスを`Box&lt;error::Error&gt;`に変更する。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error)&gt; {
        // Generic error, underlying cause isn't tracked.
        // 基本となるエラー、原因は記録されていない。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Converts to Box
                                        // Boxに変換
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Converts to Box
                                       // Boxに変換
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-60"><a class="header" href="#参照-60">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Dynamic dispatch</a> and <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Other uses of `?`
-->
<h1 id="の他の活用法"><a class="header" href="#の他の活用法"><code>?</code>の他の活用法</a></h1>
<!--
Notice in the previous example that our immediate reaction to calling
`parse` is to `map` the error from a library error into a boxed
error:
-->
<p>以前の例では<code>parse</code>の呼び出しに対するその場での対応として、エラーをライブラリのエラーからboxされたエラーへと<code>map</code>していました。</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<!--
Since this is a simple and common operation, it would be convenient if it
could be elided. Alas, because `and_then` is not sufficiently flexible, it
cannot. However, we can instead use `?`.
-->
<p>簡単でよくあるオペレーションのため、可能なら省略してしまえると便利だったでしょう。でも残念、<code>and_then</code>が十分にフレキシブルでないため、それはできません。ただその代わり、<code>?</code>なら使えます。</p>
<!--
`?` was previously explained as either `unwrap` or `return Err(err)`.
This is only mostly true. It actually means `unwrap` or
`return Err(From::from(err))`. Since `From::from` is a conversion utility
between different types, this means that if you `?` where the error is
convertible to the return type, it will convert automatically.
-->
<p><code>?</code>の挙動は、<code>unwrap</code>または<code>return Err(err)</code>として説明されていました。これはほぼ正解で、本当は<code>unwrap</code>、もしくは<code>return Err(From::from(err))</code>という意味があります。<code>From::from</code>は異なる型の間での変換ユーティリティであることから、エラーがリターン型に変換可能な場合に<code>?</code>を使うことで、その変換を自動的に行ってくれます。</p>
<!--
Here, we rewrite the previous example using `?`. As a result, the
`map_err` will go away when `From::from` is implemented for our error type:
-->
<p>前の例を<code>?</code>を使ったものに書き換えてみましょう。その結果、<code>From::from</code>がエラー型に実装されている時<code>map_err</code>は消えてなくなります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

// Change the alias to `Box&lt;dyn error::Error&gt;`.
// エイリアスを`Box&lt;error::Error&gt;`に変更する。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Generic error, underlying cause isn't tracked.
        // 基本となるエラー、原因は記録されていない。
        None
    }
}

// The same structure as before but rather than chain all `Results`
// and `Options` along, we `?` to get the inner value out immediately.
// 前と同じ構造だが、`Results`と`Option`を繋げていく代わりに、
// `?`で内部の値をその場で取得します。
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<!--
This is actually fairly clean now. Compared with the original `panic`, it
is very similar to replacing the `unwrap` calls with `?` except that the
return types are `Result`. As a result, they must be destructured at the
top level.
-->
<p>これでかなり綺麗になりました。元の<code>panic</code>と比べ、リターン型が<code>Result</code>であることを除けば、<code>unwrap</code>の呼び出しを<code>?</code>で置き換えたものに非常に似ています。結果、その<code>Result</code>は上のレベルで分解されなければなりません。</p>
<!--
### See also:
-->
<h3 id="参照-61"><a class="header" href="#参照-61">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Wrapping errors
-->
<h1 id="エラーをラップする"><a class="header" href="#エラーをラップする">エラーをラップする</a></h1>
<!--
An alternative to boxing errors is to wrap them in your own error type.
-->
<p>Boxする方法の代替として、エラーを自前のエラー型としてラップする方法もあります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    // パースエラーの実装まで処理を委譲します。
    // 追加の情報を提供するには、型により多くのデータを追加する必要があります。
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // This is a wrapper, so defer to the underlying types' implementation of `fmt`.
            // これはラッパーなので、`fmt`での元となる型の実装に処理を任せます。
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            // 元の実装のエラー型が原因。
            // `&amp;error::Error`トレートオブジェクトに暗にキャストされる。
            // 元となる型が`Error`トレートをすでに実装しているため問題なく動く。
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
// `ParseIntError`から`DoubleError`への変換の実装。
// `ParseIntError`が`DoubleError`に変換される必要がある時、自動的に`?`から呼び出される。
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<!--
This adds a bit more boilerplate for handling errors and might not be needed in
all applications. There are some libraries that can take care of the boilerplate
for you.
-->
<p>これはエラーの処理のボイラープレートを増やしてしまい、全てのアプリケーションで必要になる訳では無いでしょう。これらのボイラープレートの処理を代わりにやってくれるようなライブラリもあります。</p>
<!--
### See also:
-->
<h3 id="参照-62"><a class="header" href="#参照-62">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="error/multiple_error_types/../../custom_types/enum.html"><code>Enums</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Iterating over `Result`s
-->
<h1 id="resultをイテレートする"><a class="header" href="#resultをイテレートする"><code>Result</code>をイテレートする</a></h1>
<!--
An `Iter::map` operation might fail, for example:
-->
<p><code>Iter::map</code>オペレーションは失敗することもあります。例えば、</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<!--
Let's step through strategies for handling this.
-->
<p>ここでは、この対処法についてみてみましょう。</p>
<!--
## Ignore the failed items with `filter_map()`
-->
<h2 id="filter_mapを使って失敗した要素のみを無視する"><a class="header" href="#filter_mapを使って失敗した要素のみを無視する"><code>filter_map()</code>を使って失敗した要素のみを無視する</a></h2>
<!--
`filter_map` calls a function and filters out the results that are `None`.
-->
<p><code>filter_map</code>は関数を呼び出し、結果が<code>None</code>になるものだけ取り除きます。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok)
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<!--
## Fail the entire operation with `collect()`
-->
<h2 id="collectで処理全体を失敗させる"><a class="header" href="#collectで処理全体を失敗させる"><code>collect()</code>で処理全体を失敗させる</a></h2>
<!--
`Result` implements `FromIter` so that a vector of results (`Vec<Result<T, E>>`)
can be turned into a result with a vector (`Result<Vec<T>, E>`). Once an
`Result::Err` is found, the iteration will terminate.
-->
<p><code>Result</code>は、それらのベクトル(<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)からベクトルのそれ(<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>)へと変換できるようにするため、<code>FromIter</code>を実装します。<code>Result::Err</code>が見つかり次第、イテレーションは終了します。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<!--
This same technique can be used with `Option`.
-->
<p>同じテクニックは、<code>Option</code>を用いて行うこともできます。</p>
<!--
## Collect all valid values and failures with `partition()`
-->
<h2 id="partitionを使って全ての正常な値と失敗をまとめる"><a class="header" href="#partitionを使って全ての正常な値と失敗をまとめる"><code>partition()</code>を使って全ての正常な値と失敗をまとめる</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<!--
When you look at the results, you'll note that everything is still wrapped in
`Result`.  A little more boilerplate is needed for this.
-->
<p>結果を見てみると、まだ全て<code>Result</code>にラップされていることに気づくでしょう。もう少しのボイラープレートが必要です。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Std library types
-->
<h1 id="標準ライブラリの型"><a class="header" href="#標準ライブラリの型">標準ライブラリの型</a></h1>
<!--
The `std` library provides many custom types which expands drastically on
the `primitives`. Some of these include:
-->
<p><code>std</code>ライブラリは、基本データ型を劇的に拡張するカスタム型を数多く提供します。例えば以下です。</p>
<!--
* growable `String`s like: `"hello world"`
* growable vectors: `[1, 2, 3]`
* optional types: `Option<i32>`
* error handling types: `Result<i32, i32>`
* heap allocated pointers: `Box<i32>`
-->
<ul>
<li>拡張可能な文字列である<code>String</code>。例えば: <code>&quot;hello world&quot;</code></li>
<li>オプション型: <code>Option&lt;i32&gt;</code></li>
<li>エラーハンドリング用の<code>Result&lt;i32, i32&gt;</code></li>
<li>ヒープ上資源のポインタ<code>Box&lt;i32&gt;</code></li>
</ul>
<!--
### See also:
-->
<h3 id="参照-63"><a class="header" href="#参照-63">参照</a></h3>
<!--
[primitives] and [the std library][std]
-->
<p><a href="primitives.html">基本データ型</a>, <a href="https://doc.rust-lang.org/std/"><code>std</code>ライブラリ</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Box, stack and heap
-->
<h1 id="box-スタックとヒープ"><a class="header" href="#box-スタックとヒープ">Box, スタックとヒープ</a></h1>
<!--
All values in Rust are stack allocated by default. Values can be *boxed*
(allocated on the heap) by creating a `Box<T>`. A box is a smart pointer to a
heap allocated value of type `T`. When a box goes out of scope, its destructor
is called, the inner object is destroyed, and the memory on the heap is freed.
-->
<p>Rustにおいて、すべての値はデフォルトでスタックに割り当てられます。<code>Box&lt;T&gt;</code>を作成することで、値を <em>ボックス化</em> 、すなわちヒープ上に割り当てることができます。ボックスとは正確にはヒープ上におかれた<code>T</code>の値へのスマートポインタです。ボックスがスコープを抜けると、デストラクタが呼ばれて内包するオブジェクトが破棄され、ヒープメモリが解放されます。</p>
<!--
Boxed values can be dereferenced using the `*` operator; this removes one layer
of indirection. 
-->
<p>ボックス化された値は<code>*</code>オペレータを用いてデリファレンスすることができます。これにより一段と直接的な操作が可能になります。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

// A Rectangle can be specified by where its top left and bottom right 
// corners are in space
#[allow(dead_code)]
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Allocate this point on the heap, and return a pointer to it
    // このPointをヒープ上に割り当て、ポインタを返す。
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (all the type annotations are superfluous)
    // Stack allocated variables
    // （以下では型を全て明示していますが、必須ではありません。）
    // この変数ははすべてスタック上に割り当てられる。
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 }
    };

    // Heap allocated rectangle
    // ヒープ上に割り当てられたRectangle
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 },
    });

    // The output of functions can be boxed
    // 関数の返り値をボックス化
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Double indirection
    // 間にもう一つポインタを挟む
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size == pointer size
    // ボックスのサイズはポインタのサイズに等しい
    println!(&quot;Boxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Copy the data contained in `boxed_point` into `unboxed_point`
    // `boxed_point`の保持するデータを`unboxed_point`にコピーする
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Vectors
-->
<h1 id="ベクタ型"><a class="header" href="#ベクタ型">ベクタ型</a></h1>
<!--
Vectors are re-sizable arrays. Like slices, their size is not known at compile
time, but they can grow or shrink at any time. A vector is represented using
3 parameters: 
- pointer to the data
- length
- capacity 
-->
<p>「ベクタ」はサイズを変更可能な配列です。スライスと同様、そのサイズはコンパイル時には不定ですが、いつでも要素を追加したり削除したりすることができます。ベクタは3つの要素で、その特徴が完全に決まります。</p>
<ul>
<li>データへのポインタ</li>
<li>長さ</li>
<li>容量 ... あらかじめメモリ上にベクタのために確保された領域</li>
</ul>
<!--
The capacity indicates how much memory is reserved for the vector. The vector 
can grow as long as the length is smaller than the capacity. When this threshold 
needs to be surpassed, the vector is reallocated with a larger capacity.
-->
<p>ベクタはその容量を超えない限りにおいて長くしていくことができます。超えた場合には、より大きな容量を持つように割り当てなおされます。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Iterators can be collected into vectors
    // イテレータは要素を収集してベクタにすることができる。
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    // ベクタの初期化には`vec!`マクロが使用できる。
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // Insert new element at the end of the vector
    // 新しい要素をベクタの最後に挿入することができる。
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // Error! Immutable vectors can't grow
    // エラー！イミュータブルなベクタは成長できない
    collected_iterator.push(0);
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう。

    // The `len` method yields the number of elements currently stored in a vector
    // `len`メソッドは現在のベクタのサイズを返す。
    println!(&quot;Vector length: {}&quot;, xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    // 鍵括弧(`[]`)を用いてインデックスによる要素へのアクセスができる
    // （インデックスは0から開始する）
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` removes the last element from the vector and returns it
    // `pop`はベクタの最後の要素を削除すると同時に返す。
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // Out of bounds indexing yields a panic
    // 不正なインデックスアクセスはpanicを引き起こします。
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<!--
More `Vec` methods can be found under the
[std::vec][vec] module
-->
<p><code>Vec</code>型のメソッドの一覧は<a href="https://doc.rust-lang.org/std/vec/">std::vec</a>モジュールを見てください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Strings
-->
<h1 id="文字列"><a class="header" href="#文字列">文字列</a></h1>
<!--
There are two types of strings in Rust: `String` and `&str`.
-->
<p>Rustには文字列を扱う型が2つあります。<code>String</code>と<code>&amp;str</code>です。</p>
<!--
A `String` is stored as a vector of bytes (`Vec<u8>`), but guaranteed to
always be a valid UTF-8 sequence. `String` is heap allocated, growable and not
null terminated.
-->
<p><code>String</code>は有効なUTF-8の配列であることを保証されたバイトのベクタ(<code>Vec&lt;u8&gt;</code>)として保持されます。ヒープ上に保持され、伸長可能で、末端にnull文字を含みません。</p>
<!--
`&str` is a slice (`&[u8]`) that always points to a valid UTF-8 sequence, and
can be used to view into a `String`, just like `&[T]` is a view into `Vec<T>`.
-->
<p><code>&amp;str</code>は有効なUTF-8の配列のスライス(<code>&amp;[u8]</code>)で、いつでも<code>String</code>に変換することができます。<code>&amp;[T]</code>がいつでも<code>Vec&lt;T&gt;</code>に変換できるのと同様です。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    // （以下の例では型を明示していますが、これらは必須ではありません。）
    // read only memory上に割り当てられた文字列への参照
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    // 単語を逆順にイテレートする。新しい文字列の割り当ては起こらない。
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    // 文字をベクトルにコピー。ソートして重複を除去
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    // 中身が空で、伸長可能な`String`を作成
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        // 文字を文字列の末端に挿入
        string.push(c);
        // Insert a string at the end of string
        // 文字列を文字列の末端に挿入
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    // 文字列のトリミング（特定文字種の除去）はオリジナルの文字列のスライスを
    // 返すので、新規のメモリ割り当ては発生しない。
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    // 文字列をヒープに割り当てる。
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    // 新しくメモリを確保し、変更を加えた文字列をそこに割り当てる。
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<!--
More `str`/`String` methods can be found under the
[std::str][str] and
[std::string][string]
modules
-->
<p><code>str</code>/<code>String</code>のメソッドをもっと見たい場合は<a href="https://doc.rust-lang.org/std/str/">std::str</a>、<a href="https://doc.rust-lang.org/std/string/">std::string</a>モジュールを参照してください。</p>
<h2 id="literals-and-escapes"><a class="header" href="#literals-and-escapes">Literals and escapes</a></h2>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code>\</code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\\</code></p>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8).
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<pre><pre class="playground"><code class="language-rust  editable">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option"><code>Option</code></a></h1>
<!--
Sometimes it's desirable to catch the failure of some parts of a program
instead of calling `panic!`; this can be accomplished using the `Option` enum.
-->
<p>プログラムの一部が失敗した際、<code>panic!</code>するよりも、エラーを補足する方が望ましい場合があります。これは<code>Option</code>という列挙型を用いることで可能になります。</p>
<!--
The `Option<T>` enum has two variants:
-->
<p>列挙型<code>Option&lt;T&gt;</code>には2つの値があります。</p>
<!--
* `None`, to indicate failure or lack of value, and
* `Some(value)`, a tuple struct that wraps a `value` with type `T`.
-->
<ul>
<li><code>None</code>、これは実行の失敗か値の欠如を示します。</li>
<li><code>Some(value)</code>、型<code>T</code>の<code>value</code>をラップするタプルです。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// An integer division that doesn't `panic!`
// `panic!`を起こさない整数の割り算
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // Failure is represented as the `None` variant
        // 失敗は`None`としてあらわされる。
        None
    } else {
        // Result is wrapped in a `Some` variant
        // 結果は`Some`にラップされる。
        Some(dividend / divisor)
    }
}

// This function handles a division that may not succeed
// この関数は失敗する割り算を扱うことができる
fn try_division(dividend: i32, divisor: i32) {
    // `Option` values can be pattern matched, just like other enums
    // `Option` の値は、他のあらゆる列挙型と同様パターンマッチに使用できる。
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Binding `None` to a variable needs to be type annotated
    // `None`を変数にアサインする際は、型を明示しなくてはならない。
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Unwrapping a `Some` variant will extract the value wrapped.
    // `Some`をアンラップすると中の値を取得できる。
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // Unwrapping a `None` variant will `panic!`
    // `None`をアンラップしようとすると`panic!`る
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1"><code>Result</code></a></h1>
<!--
We've seen that the `Option` enum can be used as a return value from functions
that may fail, where `None` can be returned to indicate failure. However,
sometimes it is important to express *why* an operation failed. To do this we 
have the `Result` enum.
-->
<p>これまでの例で、失敗する可能性のある関数の返り値として、列挙型<code>Option</code>が使用でき、失敗時の返り値には<code>None</code>を用いることを見てきました。しかし、時には <strong>なぜ</strong> そのオペレーションが失敗したのかを明示することが重要な場合があります。そのためには<code>Result</code>列挙型を使用します。</p>
<!--
The `Result<T, E>` enum has two variants:
-->
<p>列挙型<code>Result&lt;T, E&gt;</code>は2つの値をとりえます。</p>
<!--
* `Ok(value)` which indicates that the operation succeeded, and wraps the
  `value` returned by the operation. (`value` has type `T`)
* `Err(why)`, which indicates that the operation failed, and wraps `why`,
  which (hopefully) explains the cause of the failure. (`why` has type `E`)
-->
<ul>
<li><code>Ok(value)</code> ... これはオペレーションが成功したことを意味し、返り値<code>value</code>をラップします。（<code>value</code>は型<code>T</code>を持ちます。）</li>
<li><code>Err(why)</code> ... これはオペレーションの失敗を意味します。<code>why</code>をラップしており、ここには失敗した理由が（必ずではありませんが）書かれています。（<code>why</code>の型は<code>E</code>です。）</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Mathematical &quot;errors&quot; we want to catch
    // 補足対象としたい、数学的な「エラー」
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // This operation would `fail`, instead let's return the reason of
            // the failure wrapped in `Err`
            // 分母が0なので、このオペレーションは普通に行えば失敗する。
            // 代わりに`Err`でラップされた失敗の理由を返そう。
            Err(MathError::DivisionByZero)
        } else {
            // This operation is valid, return the result wrapped in `Ok`
            // このオペレーションは問題がないので、結果を`Ok`でラップして返そう。
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // This is a three level match pyramid!
    // 3段階の`match`ピラミッド！
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Will this fail?
    // これは失敗するだろうか？
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"><code>?</code></a></h1>
<p>Chaining results using match can get pretty untidy; luckily, the <code>?</code> operator
can be used to make things pretty again. <code>?</code> is used at the end of an expression
returning a <code>Result</code>, and is equivalent to a match expression, where the 
<code>Err(err)</code> branch expands to an early <code>Err(From::from(err))</code>, and the <code>Ok(ok)</code>
branch expands to an <code>ok</code> expression.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Intermediate function
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // if `div` &quot;fails&quot;, then `DivisionByZero` will be `return`ed
        let ratio = div(x, y)?;

        // if `ln` &quot;fails&quot;, then `NonPositiveLogarithm` will be `return`ed
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Be sure to check the <a href="https://doc.rust-lang.org/std/result/index.html">documentation</a>,
as there are many methods to map/compose <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-1"><a class="header" href="#panic-1"><code>panic!</code></a></h1>
<!--
The `panic!` macro can be used to generate a panic and start unwinding
its stack. While unwinding, the runtime will take care of freeing all the
resources *owned* by the thread by calling the destructor of all its objects.
-->
<p><code>panic!</code>マクロはパニックを生成し、スタックの巻き戻しを開始するために使用することができます。巻き戻しの間、ランタイムは、（訳注: panicを起こした）スレッドが <strong>所有権を持つ</strong> 全ての資源のデストラクタを呼び出し、メモリ上から解放します。</p>
<!--
Since we are dealing with programs with only one thread, `panic!` will cause the
program to report the panic message and exit.
-->
<p>今回はシングルスレッドのプログラムを実行しているので、<code>panic!</code>はプログラムにパニックメッセージを表示させ、exitします。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// Re-implementation of integer division (/)
// 整数の除法(/)の再実装
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // Division by zero triggers a panic
        // ゼロによる除算はパニックを引き起こす
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// The `main` task
// `main`のタスク
fn main() {
    // Heap allocated integer
    // ヒープ上の整数
    let _x = Box::new(0i32);

    // This operation will trigger a task failure
    // このオペレーションはタスクの失敗を引き起こす
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` should get destroyed at this point
    // `_x`はここに到達する前に破棄される。
}
</code></pre></pre>
<!--
Let's check that `panic!` doesn't leak memory.
-->
<p><code>panic!</code>がメモリリークを引き起こさないことを確認しましょう。</p>
<pre><code class="language-shell">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# HashMap
-->
<h1 id="ハッシュマップ"><a class="header" href="#ハッシュマップ">ハッシュマップ</a></h1>
<!--
Where vectors store values by an integer index, `HashMap`s store values by key. 
`HashMap` keys can be booleans, integers, strings, 
or any other type that implements the `Eq` and `Hash` traits. 
More on this in the next section.
-->
<p>ベクタ型が値を整数のインデックスで保持するのに対し、<code>HashMap</code>ではキーで保持します。<code>HashMap</code>のキーはブーリアン、整数、文字列等の<code>Eq</code>あるいは<code>Hash</code>トレイトを保持する型なら何でもOKです。後でより詳しく見ていきます。</p>
<!--
Like vectors, `HashMap`s are growable, but HashMaps can also shrink themselves 
when they have excess space. 
You can create a HashMap with a certain starting capacity using 
`HashMap::with_capacity(uint)`, or use `HashMap::new()` to get a HashMap 
with a default initial capacity (recommended).
-->
<p>ベクタ型と同様、伸長可能ですが、<code>HashMap</code>の場合さらに、スペースが余っているときには小さくすることも可能です。<code>HashMap</code>を一定の容量のエリアに作成するときは<code>HashMap::with_capacity(uint)</code>を、デフォルトの容量で作成するときは<code>HashMap::new()</code>を用います。後者が推奨されています。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // Takes a reference and returns Option&lt;&amp;V&gt;
    // 参照をとり、Option&lt;&amp;V&gt;を返す。
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()` returns `None`
    // if the inserted value is new, `Some(value)` otherwise
    // `HashMap::insert()`は
    // insertされた値が新しい場合は`None`を
    // そうでなければ`Some(value)`を返す。
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;&quot;Ashley&quot;); 

    // `HashMap::iter()` returns an iterator that yields 
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    // `HashMap::iter()`は(&amp;'a key, &amp;'a value)
    // のペアを順不同で産出するイテレータを返す
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<!--
For more information on how hashing and hash maps 
(sometimes called hash tables) work, have a look at 
[Hash Table Wikipedia][wiki-hash]
-->
<p>ハッシングやハッシュマップ（ハッシュテーブルと呼ばれることもあります）の仕組みについて、より詳しく知りたい場合は<a href="https://en.wikipedia.org/wiki/Hash_table">Wikipediaのハッシュテーブルのページ</a>を見てください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Alternate/custom key types
-->
<h1 id="key型の変種"><a class="header" href="#key型の変種">key型の変種</a></h1>
<!--
Any type that implements the `Eq` and `Hash` traits can be a key in `HashMap`. 
This includes:
-->
<p><code>Eq</code>と<code>Hash</code>トレイトを実装している型ならば、なんでも<code>HashMap</code>のキーになることができます。例えば以下です。</p>
<!--
* `bool` (though not very useful since there is only two possible keys)
* `int`, `uint`, and all variations thereof
* `String` and `&str` (protip: you can have a `HashMap` keyed by `String`
and call `.get()` with an `&str`)
-->
<ul>
<li><code>bool</code> （キーになりうる値が2つしかないので実用的ではないですが…）</li>
<li><code>int</code>、<code>uint</code>、あるいは他の整数型</li>
<li><code>String</code>と<code>&amp;str</code>（Tips: <code>String</code>をキーにしたハッシュマップを作製した場合、<code>.get()</code>メソッドの引数に<code>&amp;str</code>を与えて値を取得することができます。）</li>
</ul>
<!--
Note that `f32` and `f64` do *not* implement `Hash`,
likely because [floating-point precision errors][floating]
would make using them as hashmap keys horribly error-prone.
-->
<p><code>f32</code>と<code>f64</code>は<code>Hash</code>を実装して <strong>いない</strong> ことに注意しましょう。おそらくこれは<a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">浮動小数点演算時に誤差が発生する</a>ため、キーとして使用すると、恐ろしいほどエラーの元となるためです。</p>
<!--
All collection classes implement `Eq` and `Hash` 
if their contained type also respectively implements `Eq` and `Hash`. 
For example, `Vec<T>` will implement `Hash` if `T` implements `Hash`.
-->
<p>集合型は、その要素となっている全ての型が<code>Eq</code>を、あるいは<code>Hash</code>を実装している場合、必ず同じトレイトを実装しています。例えば、<code>Vec&lt;T&gt;</code>は<code>T</code>が<code>Hash</code>を実装している場合、<code>Hash</code>を実装します。</p>
<!--
You can easily implement `Eq` and `Hash` for a custom type with just one line: 
`#[derive(PartialEq, Eq, Hash)]`
-->
<p>独自の型に<code>Eq</code>あるいは<code>Hash</code>を実装するのは簡単です。以下の一行で済みます。
<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<!--
The compiler will do the rest. If you want more control over the details, 
you can implement `Eq` and/or `Hash` yourself. 
This guide will not cover the specifics of implementing `Hash`. 
-->
<p>後はコンパイラがよしなにしてくれます。これらのトレイトの詳細をコントロールしたい場合、<code>Eq</code>や<code>Hash</code>を自分で実装することもできます。この文書では<code>Hash</code>トレイトを実装する方法の詳細については触れません。</p>
<!--
To play around with using a `struct` in `HashMap`, 
let's try making a very simple user logon system:
-->
<p><code>struct</code>を<code>HashMap</code>で扱う際の例として、とてもシンプルなユーザーログインシステムを作成してみましょう。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

// Eq requires that you derive PartialEq on the type.
// Eqトレイトを使用する時は、PartialEqをderiveする必要があります。
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username,
        password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# HashSet
-->
<h1 id="ハッシュ集合"><a class="header" href="#ハッシュ集合">ハッシュ集合</a></h1>
<!--
Consider a `HashSet` as a `HashMap` where we just care about the keys (
`HashSet<T>` is, in actuality, just a wrapper around `HashMap<T, ()>`).
-->
<p>値がなく、キーだけの<code>HashMap</code>を想像してみてください。これはハッシュ集合(<code>HashSet</code>)と呼ばれるものです。（<code>HashSet&lt;T&gt;</code>は、実際には<code>HashMap&lt;T, ()&gt;</code>のラッパーです。）</p>
<!--
"What's the point of that?" you ask. "I could just store the keys in a `Vec`."
-->
<p>「何の意味があるの？フツーにキーを<code>Vec</code>に入れればいいじゃん」そう思いましたね？</p>
<!--
A `HashSet`'s unique feature is that 
it is guaranteed to not have duplicate elements. 
That's the contract that any set collection fulfills. 
`HashSet` is just one implementation. (see also: [`BTreeSet`][treeset])
-->
<p>それは、<code>HashSet</code>独自の機能として、要素に重複がないということが保証されるためです。これは全ての集合(<code>set</code>)型がもつ機能です。<code>HashSet</code>はその実装の1つであり、他には<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>等があります。</p>
<!--
If you insert a value that is already present in the `HashSet`, 
(i.e. the new value is equal to the existing and they both have the same hash), 
then the new value will replace the old.
-->
<p><code>HashSet</code>に、すでに存在する値を加えようとすると、（すなわち、加えようとしている値のハッシュ値と、要素中のいずれかの値のハッシュ値が等しい場合、）新しい値によって古い値が上書きされます。</p>
<!--
This is great for when you never want more than one of something, 
or when you want to know if you've already got something.
-->
<p>これは、同じ値を2つ以上欲しくない場合や、すでにある値を持っているか知りたい場合にとても有効です。</p>
<!--
But sets can do more than that. 
-->
<p>しかし、集合型の機能はそれだけではありません。</p>
<!--
Sets have 4 primary operations (all of the following calls return an iterator):
-->
<p>集合型には4つの主要なメソッドがあり、（すべてイテレータを返します。）</p>
<!--
* `union`: get all the unique elements in both sets.
-->
<ul>
<li><code>union</code>: 2つの集合型のどちらか一方にある値を全て取得</li>
</ul>
<!--
* `difference`: get all the elements that are in the first set but not the second.
-->
<ul>
<li><code>difference</code>: 1つ目の集合にあり、かつ2つ目には存在しない値を全て取得。</li>
</ul>
<!--
* `intersection`: get all the elements that are only in *both* sets.
-->
<ul>
<li><code>intersection</code>: 両方の集合にある値のみを取得。</li>
</ul>
<!--
* `symmetric_difference`: 
get all the elements that are in one set or the other, but *not* both.
-->
<ul>
<li><code>symmetric_difference</code>: どちらか一方の集合には存在するが、両方には <strong>ない</strong> 値を取得</li>
</ul>
<!--
Try all of these in the following example:
-->
<p>以下の例でこれらをすべて見ていきましょう。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` returns false if
    // there was a value already present.
    // 既に存在する値を追加しようとすると
    // `HashSet::insert()`はfalseを返す。
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // FIXME ^ Comment out this line
    // FIXME ^ この行をコメントアウトしましょう。

    b.insert(5);

    // If a collection's element type implements `Debug`,
    // then the collection implements `Debug`.
    // It usually prints its elements in the format `[elem1, elem2, ...]`
    // 集合の要素が、`Debug`を実装している型の場合、
    // 集合そのものも`Debug`を実装する。
    // 通常は`[elem1, elem2, ...]`のように要素をプリントする。
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Print [1, 2, 3, 4, 5] in arbitrary order
    // [1, 2, 3, 4, 5]を順不同にプリント
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // This should print [1]
    // これは[1]をプリント
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [2, 3, 4] in arbitrary order.
    // [2, 3, 4]を順不同にプリント
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [1, 5]
    // [1, 5]をプリント
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<!--
(Examples are adapted from the [documentation.][hash-set])
-->
<p>例は<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">公式ドキュメント</a>から持ってきています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc"><code>Rc</code></a></h1>
<p>When multiple ownership is needed, <code>Rc</code>(Reference Counting) can be used. <code>Rc</code> keeps track of the number of the references which means the number of owners of the value wrapped inside an <code>Rc</code>. </p>
<p>Reference count of an <code>Rc</code> increases by 1 whenever an <code>Rc</code> is cloned, and decreases by 1 whenever one cloned <code>Rc</code> is dropped out of the scope. When an <code>Rc</code>'s reference count becomes zero, which means there are no owners remained, both the <code>Rc</code> and the value are all dropped. </p>
<p>Cloning an <code>Rc</code> never do a deep copy. Cloning creates just another pointer to the wrapped value, and increments the count.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Rc examples&quot;.to_string();
    {
        println!(&quot;--- rc_a is created ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // Two `Rc`s are equal if their inner values are equal
            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));
            
            // We can use methods of a value directly
            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());
            println!(&quot;Value of rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b is dropped out of scope ---&quot;);
        }
        
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a is dropped out of scope ---&quot;);
    }
    
    // Error! `rc_examples` already moved into `rc_a`
    // And when `rc_a` is dropped, `rc_examples` is dropped together
    // println!(&quot;rc_examples: {}&quot;, rc_examples);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<!--
### See also:
-->
<h3 id="参照-64"><a class="header" href="#参照-64">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/rc/index.html">std::rc</a> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Std misc
-->
<h1 id="標準ライブラリのその他"><a class="header" href="#標準ライブラリのその他">標準ライブラリのその他</a></h1>
<!--
Many other types are provided by the std library to support
things such as:
-->
<p>他にも、様々な型がstdライブラリの中で提供されています。例えば以下の機能を果たすための物があります。</p>
<!--
* Threads
* Channels
* File I/O
-->
<ul>
<li>スレッド</li>
<li>チャネル</li>
<li>ファイルI/O</li>
</ul>
<!--
These expand beyond what the [primitives] provide.
-->
<p>これらにより<a href="primitives.html">基本データ型</a>の提供する機能よりも遥かに豊かなことが実現できます。</p>
<!--
### See also:
-->
<h3 id="参照-65"><a class="header" href="#参照-65">参照</a></h3>
<!--
[primitives] and [the std library][std]
-->
<p><a href="primitives.html">基本データ型</a>, <a href="https://doc.rust-lang.org/std/">stdライブラリ</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Threads
-->
<h1 id="スレッド"><a class="header" href="#スレッド">スレッド</a></h1>
<!--
Rust provides a mechanism for spawning native OS threads via the `spawn`
function, the argument of this function is a moving closure.
-->
<p>Rustは<code>spawn</code>関数を用いてOSのネイティブスレッドを開始することができます。この関数の引数はmoveクロージャ（訳注: 参照ではなく値を取るクロージャ。　詳しくは[クロージャを返す関数][fn_output]を参照）です。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// This is the `main` thread
// この関数は`main`スレッドで実行される。
fn main() {
    // Make a vector to hold the children which are spawned.
    // spawnされるクロージャを保持するためのベクタ
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Spin up another thread
        // 新しいスレッドを起動
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i);
        }));
    }

    for child in children {
        // Wait for the thread to finish. Returns a result.
        // 子スレッドが終了するのを待ち、結果を返す。
        let _ = child.join();
    }
}
</code></pre></pre>
<!--
These threads will be scheduled by the OS.
-->
<p>これらのスレッドのスケジューリングはOSによって行われる。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testcase-map-reduce"><a class="header" href="#testcase-map-reduce">Testcase: map-reduce</a></h1>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // collect each thread's intermediate results into a new Vec
    let mut intermediate_sums = vec![];
    for child in children {
        // collect each child thread's return-value
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // combine all intermediate sums into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<!--
### See also:
-->
<h3 id="参照-66"><a class="header" href="#参照-66">参照</a></h3>
<ul>
<li><a href="std_misc/threads/../threads.html">Threads</a></li>
<li><a href="std_misc/threads/../../std/vec.html">vectors</a> and <a href="std_misc/threads/../../trait/iter.html">iterators</a></li>
<li><a href="std_misc/threads/../../fn/closures.html">closures</a>, <a href="std_misc/threads/../../scope/move.html">move</a> semantics and <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code> closures</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> assignments</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish notation</a> to help type inference</li>
<li><a href="std_misc/threads/../../error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# Channels
-->
<h1 id="チャネル"><a class="header" href="#チャネル">チャネル</a></h1>
<!--
Rust provides asynchronous `channels` for communication between threads. Channels
allow a unidirectional flow of information between two end-points: the
`Sender` and the `Receiver`.
-->
<p>Rustは、スレッド間のコミュニケーションのために、非同期のチャネル(<code>channels</code>)を提供しています。チャネル2つのエンドポイント、すなわち送信者(<code>Sender</code>)と受信者(<code>Receiver</code>)を介して、情報の一方向への流れを作り出すことを可能にしています。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    // チャネルには`Sender&lt;T&gt;`と`Receiver&lt;T&gt;`という2つのエンドポイントがある。
    // ここで、`T`は送信されるメッセージの型である。
    // （型アノテーションは必須ではない。）
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        // 送信者エンドポイントはコピーすることができる。
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        // ここでは、それぞれのスレッドが自身のIDを送信している。
        let child = thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            // スレッドは`thread_tx`の所有権をとり、それぞれのスレッドは
            // メッセージをチャネルにキューイングする。
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            // 送信はノンブロッキングなオペレーションなので、
            // メッセージを送信した後もすぐに実行を継続する。
            println!(&quot;thread {} finished&quot;, id);
        });

        children.push(child);
    }

    // Here, all the messages are collected
    // ここで、全てのメッセージが収集される。
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        // `recv`メソッドはチャネルからメッセージを取り出す。
        // もし取り出せるメッセージが存在しない場合、`recv`は
        // 現在のスレッドをブロックする。
        ids.push(rx.recv());
    }
    
    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect(&quot;oops! the child thread panicked&quot;);
    }

    // Show the order in which the messages were sent
    // メッセージが送信された順番を表示
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path"><a class="header" href="#path">Path</a></h1>
<!--
The `Path` struct represents file paths in the underlying filesystem. There are
two flavors of `Path`: `posix::Path`, for UNIX-like systems, and
`windows::Path`, for Windows. The prelude exports the appropriate
platform-specific `Path` variant.
-->
<p>構造体<code>Path</code>は、ファイルシステム中のパスを表します。<code>Path</code>には2つの変種があります。UNIXライクなファイルシステムのための<code>posix::Path</code>と、Windows用の<code>windows::Path</code>です。それぞれプラットフォームに対応した<code>Path</code>をエクスポートします。</p>
<!--
A `Path` can be created from an `OsStr`, and provides several methods to get
information from the file/directory the path points to.
-->
<p><code>Path</code>は<code>OsStr</code>から作ることができます。そうすればそのパスが指すファイル・ディレクトリの情報を取得するためのメソッドがいくつか使えるようになります。</p>
<!--
Note that a `Path` is *not* internally represented as an UTF-8 string, but
instead is stored as a vector of bytes (`Vec<u8>`). Therefore, converting a
`Path` to a `&str` is *not* free and may fail (an `Option` is returned).
-->
<p><code>Path</code>の実態はUTF-8の文字列 <strong>ではなく</strong> 、バイト型のベクタ(<code>Vec&lt;u8&gt;</code>)であることに注意しましょう。したがって、<code>Path</code>を<code>&amp;str</code>に変換するのは無条件 <strong>ではなく</strong> 、失敗する可能性があります。それゆえ<code>Option</code>型が返されます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Create a `Path` from an `&amp;'static str`
    // `&amp;'static str`から`Path`を作成
    let path = Path::new(&quot;.&quot;);

    // The `display` method returns a `Show`able structure
    // `display`メソッドは`Show`可能な構造体を返す。
    let _display = path.display();

    // `join` merges a path with a byte container using the OS specific
    // separator, and returns the new path
    // `join`はOS固有のセパレータによってバイトのコンテナ型であるパス
    // を結合し、新しいパスを返す。
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Convert the path into a string slice
    // パスを文字列のスライスに変換する。
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}

</code></pre></pre>
<!--
Be sure to check at other `Path` methods (`posix::Path` or `windows::Path`) and
the `Metadata` struct.
-->
<p>他の<code>Path</code>メソッド（<code>posix::Path</code>と<code>windows::Path</code>）をチェックするのを忘れずに！それと<code>Metadata</code>構造体も見ておくことをオススメします。</p>
<!--
### See also:
-->
<h3 id="参照-67"><a class="header" href="#参照-67">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> and <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# File I/O
-->
<h1 id="ファイル-io"><a class="header" href="#ファイル-io">ファイル I/O</a></h1>
<!--
The `File` struct represents a file that has been opened (it wraps a file
descriptor), and gives read and/or write access to the underlying file.

Since many things can go wrong when doing file I/O, all the `File` methods
return the `io::Result<T>` type, which is an alias for `Result<T, io::Error>`.
-->
<p><code>File</code>構造体は開かれたファイルを表し（実際にはファイルディスクリプタのラッパーです）、読み込み・書き込み権限のどちらか一方、あるいは両方を提供します。</p>
<!--
This makes the failure of all I/O operations *explicit*. Thanks to this, the
programmer can see all the failure paths, and is encouraged to handle them in
a proactive manner.
-->
<p>これはI/Oに関するオペレーションの失敗をより明瞭にします。このおかげでプログラマは直面した失敗を全て見ることができ、より生産的な方法でそれらを扱うことが可能になります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open"><a class="header" href="#open"><code>open</code></a></h1>
<!--
The `open` static method can be used to open a file in read-only mode.
-->
<p>スタティックメソッドの<code>open</code>を用いることで読み込み専用モードでファイルを開くことが可能です。</p>
<!--
A `File` owns a resource, the file descriptor and takes care of closing the
file when it is `drop`ed.
-->
<p><code>File</code>はファイルディスクリプタという資源を保持しており、<code>drop</code>時にはファイルを閉じるところまで面倒を見てくれます。</p>
<pre><code class="language-rust editable ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    // 目的ファイルに対する`Path`を作成
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result&lt;File&gt;`
    // pathを読み込み専用モードで開く。これは`io::Result&lt;File&gt;`を返す。
    let mut file = match File::open(&amp;path) {
        // The `description` method of `io::Error` returns a string that
        // describes the error
        // `io::Error`の`description`メソッドはエラーを説明する文字列を返す。
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display,
                                                   why.description()),
        Ok(file) =&gt; file,
    };

    // Read the file contents into a string, returns `io::Result&lt;usize&gt;`
    // ファイルの中身を文字列に読み込む。`io::Result&lt;useize&gt;`を返す。
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display,
                                                   why.description()),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` goes out of scope, and the &quot;hello.txt&quot; file gets closed
    // `file`がスコープから抜け、&quot;hello.txt&quot;が閉じられる。
}

</code></pre>
<!--
Here's the expected successful output:
-->
<p>以下が成功時に期待されるアウトプットです。</p>
<pre><code class="language-shell">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<!--
(You are encouraged to test the previous example under different failure
conditions: `hello.txt` doesn't exist, or `hello.txt` is not readable,
etc.)
-->
<p>（気が向いたなら、上記の例を様々な形で失敗させてみましょう。例えば<code>hello.txt</code>が存在しないとか、読み込み権限がないとか、そういった状況で実行してみてください。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create"><a class="header" href="#create"><code>create</code></a></h1>
<!--
The `create` static method opens a file in write-only mode. If the file
already existed, the old content is destroyed. Otherwise, a new file is
created.
-->
<p>スタティックメソッドの<code>create</code>はファイルを書き込み専用モードで開きます。すでにファイルが存在している場合、破棄して新しい物を作成します。</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;str =
    &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result&lt;File&gt;`
    // ファイルを書き込み専用モードで開く。返り値は`io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;, display, why.description()),
        Ok(file) =&gt; file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result&lt;()&gt;`
    // `LOREM_IPSUM`の文字列を`file`に書き込む。返り値は`io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to {}: {}&quot;, display, why.description()),
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<!--
Here's the expected successful output:
-->
<p>以下は成功時に期待されるアウトプットです。</p>
<pre><code class="language-shell">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
successfully wrote to out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<!--
(As in the previous example, you are encouraged to test this example under
failure conditions.)
-->
<p>前項の例と同じように、様々な失敗パターンをためしてみることをオススメします。</p>
<p>There is <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>OpenOptions</code></a> struct that can be used to configure how a file is opened.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read_lines"><a class="header" href="#read_lines"><code>read_lines</code></a></h1>
<p>The method <code>lines()</code> returns an iterator over the lines
of a file.</p>
<p><code>File::open</code> expects a generic, <code>AsRef&lt;Path&gt;</code>.  That's what
<code>read_lines()</code> expects as input.</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }
        }
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>Running this program simply prints the lines individually.</p>
<pre><code class="language-shell">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>This process is more efficient than creating a <code>String</code> in memory
especially working with larger files.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Child processes
-->
<h1 id="子プロセス"><a class="header" href="#子プロセス">子プロセス</a></h1>
<!--
The `process::Output` struct represents the output of a finished child process,
and the `process::Command` struct is a process builder.
-->
<p><code>process::Output</code>構造体は終了したプロセスのアウトプットを表し、<code>process::Command</code>構造体はプロセスの作成を行います。</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre>
<!--
(You are encouraged to try the previous example with an incorrect flag passed
to `rustc`)
-->
<p>（余裕があれば、上の例で<code>rustc</code>に不正なフラグを渡し、どうなるか見てみましょう）</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Pipes
-->
<h1 id="パイプ"><a class="header" href="#パイプ">パイプ</a></h1>
<!--
The `std::Child` struct represents a running child process, and exposes the
`stdin`, `stdout` and `stderr` handles for interaction with the underlying
process via pipes.
-->
<p><code>std::Child</code>構造体は実行中の子プロセスを表します。<code>stdin</code>、<code>stdout</code>、<code>stderr</code>を介して表面化のプロセスとのやり取りを仲介します。</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    // `wc`コマンドを起動する。
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    // `wc`の`stdin`に文字列を書き込む。
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    // `stdin`は`Option&lt;ChildStdin&gt;`型を持つが、今回は値を持っていることが
    // 確かなので、いきなり`unwrap`してしまってよい。
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;,
                           why.description()),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.
    // `stdin`は上のプロセスコールのあとには有効でないので、`drop`され、
    // パイプはcloseされる。
    // (これは非常に重要です。というのもcloseしないと`wc`は
    // 送った値の処理を開始しないからです。)

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    // `stdout`フィールドも`Option&lt;ChildStdout&gt;`型なのでアンラップする必要がある
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Wait
-->
<h1 id="dropの延期"><a class="header" href="#dropの延期">dropの延期</a></h1>
<p>If you'd like to wait for a <code>process::Child</code> to finish, you must call
<code>Child::wait</code>, which will return a <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
# `wait` keeps running for 5 seconds until the `sleep 5` command finishes
reached end of main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Filesystem Operations
-->
<h1 id="ファイルシステムとのやり取り"><a class="header" href="#ファイルシステムとのやり取り">ファイルシステムとのやり取り</a></h1>
<!--
The `std::fs` module contains several functions that deal with the filesystem.
-->
<p><code>std::fs</code>モジュールはファイルシステムとやり取りするための関数をいくつか持っています。</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// A simple implementation of `% cat path`
// `% cat path`のシンプルな実装
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// A simple implementation of `% echo s &gt; path`
// `% echo s &gt; path`の簡単な実装
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
// `% touch path`の簡単な実装（すでにファイルが存在しても無視する。）
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Create a directory, returns `io::Result&lt;()&gt;`
    // ディレクトリを作成する。返り値は`io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // The previous match can be simplified using the `unwrap_or_else` method
    // 上のmatchは`unwrap_or_else`をメソッドを用いて簡略化できる。
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Recursively create a directory, returns `io::Result&lt;()&gt;`
    // 再帰的にディレクトリを作成する。返り値は`io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Create a symbolic link, returns `io::Result&lt;()&gt;`
    // シンボリックリンクを作成、返り値は`io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`
    // ディレクトリの内容を読み込む。返り値は`io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Remove a file, returns `io::Result&lt;()&gt;`
    // ファイルを削除。返り値は`io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Remove an empty directory, returns `io::Result&lt;()&gt;`
    // 空のディレクトリを削除。返り値は`io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<!--
Here's the expected successful output:
-->
<p>以下が成功時に期待されるアウトプットです。</p>
<pre><code class="language-shell">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<!--
And the final state of the `a` directory is:
-->
<p>最終的な<code>a</code>ディレクトリの状態は以下です。</p>
<pre><code class="language-shell">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<!--
### See also:
-->
<h3 id="参照-68"><a class="header" href="#参照-68">参照</a></h3>
<p><a href="std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Program arguments
-->
<h1 id="引数処理"><a class="header" href="#引数処理">引数処理</a></h1>
<h2 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h2>
<!--
The command line arguments can be accessed using `std::env::args`, which
returns an iterator that yields a `String` for each argument:
-->
<p>コマンドライン引数は<code>std::env::args</code>を介して取得できます。これはそれぞれの引数を文字列としてyieldするイテレータを返します。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // The first argument is the path that was used to call the program.
    // ひとつ目の引数はプログラムを呼び出す際に使用したパス
    println!(&quot;My path is {}.&quot;, args[0]);

    // The rest of the arguments are the passed command line parameters.
    // Call the program like this:
    // 残りはプログラムに渡されたコマンドラインパラメータ。
    // プログラムはこんなふうに呼び出す。
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-shell">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<p>Alternatively, there are numerous crates that can provide extra functionality
when creating command-line applications. The <a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Rust Cookbook</a> exhibits best
practices on how to use one of the more popular command line argument crates,
<code>clap</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Argument parsing
-->
<h1 id="引数のパース"><a class="header" href="#引数のパース">引数のパース</a></h1>
<!--
Matching can be used to parse simple arguments:
-->
<p>matchを用いて簡単な引数をパースできます。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        // 引数がない場合
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        // 引数が1つの場合
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        // コマンドが一つと引数が一つの場合
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            // 数字をパース
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            // コマンドをパース
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        // その他の場合
        _ =&gt; {
            // show a help message
            // ヘルプメッセージを表示
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-shell">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Foreign Function Interface
-->
<h1 id="他言語関数インターフェイス"><a class="header" href="#他言語関数インターフェイス">他言語関数インターフェイス</a></h1>
<!--
Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign
functions must be declared inside an `extern` block annotated with a `#[link]`
attribute containing the name of the foreign library.
-->
<p>RustはCのライブラリを呼び出すために他言語関数インターフェイス(Foreign Function Interface, FFI)を持っています。他言語の関数を使用する際には、そのライブラリ名を<code>#[link]</code>アトリビュートに渡し、更にそれでアノテーションされた<code>extern</code>ブロック内で宣言する必要があります。</p>
<pre><code class="language-rust ignore">use std::fmt;

// this extern block links to the libm library
// このexternブロックはlibmライブラリをリンクする。
#[link(name = &quot;m&quot;)]
extern {
    // this is a foreign function
    // that computes the square root of a single precision complex number
    // 他言語の関数宣言。
    // この関数は単精度浮動小数の複素数型の平方根を計算するためのもの
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// Since calling foreign functions is considered unsafe,
// it's common to write safe wrappers around them.
// 型安全ににするためのラッパ
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // calling safe API wrapped around unsafe operation
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Minimal implementation of single precision complex numbers
// 単精度浮動小数の複素数型の最小限の実装
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Testing
-->
<h1 id="テスト-1"><a class="header" href="#テスト-1">テスト</a></h1>
<!--
Rust is a programming language that cares a lot about correctness and it
includes support for writing software tests within the language itself.
-->
<p>Rustはとても正確性を配慮したプログラミング言語であり、ソフトウェアテストを書くためのサポートを言語自身が含んでいます。</p>
<!--
Testing comes in three styles:
-->
<p>テストには3つの種類があります。</p>
<!--
* [Unit][unit] testing.
* [Doc][doc] testing.
* [Integration][integration] testing.
-->
<ul>
<li><a href="testing/unit_testing.html">単体テスト</a></li>
<li><a href="testing/doc_testing.html">ドキュメンテーションテスト</a></li>
<li><a href="testing/integration_testing.html">結合テスト</a></li>
</ul>
<!--
Also Rust has support for specifying additional dependencies for tests:
-->
<p>またRustではテストのために追加の依存パッケージを指定することもできます。</p>
<ul>
<li><a href="testing/dev_dependencies.html">Dev-dependencies</a></li>
</ul>
<!--
## See Also
-->
<h2 id="参照-69"><a class="header" href="#参照-69">参照</a></h2>
<!--
* [The Book][doc-testing] chapter on testing
* [API Guidelines][doc-nursery] on doc-testing
-->
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Book</a> の自動テストの章</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API ガイドライン</a> のドキュメンテーション</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h1>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform some setup,
run the code we want to test, then assert whether the results are what we
expect.</p>
<p>Most unit tests go into a <code>tests</code> <a href="testing/../mod.html">mod</a> with the <code>#[cfg(test)]</code> <a href="testing/../attribute.html">attribute</a>.
Test functions are marked with the <code>#[test]</code> attribute.</p>
<p>Tests fail when something in the test function <a href="testing/../std/panic.html">panics</a>. There are some
helper <a href="testing/../macros.html">macros</a>:</p>
<ul>
<li><code>assert!(expression)</code> - panics if expression evaluates to <code>false</code>.</li>
<li><code>assert_eq!(left, right)</code> and <code>assert_ne!(left, right)</code> - testing left and
right expressions for equality and inequality respectively.</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// This is a really bad adding function, its purpose is to fail in this
// example.
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // This assert would fire and test will fail.
        // Please note, that private functions can be tested too!
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>.</p>
<pre><code class="language-shell">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="tests-and-"><a class="header" href="#tests-and-">Tests and <code>?</code></a></h2>
<p>None of the previous unit test examples had a return type. But in Rust 2018,
your unit tests can return <code>Result&lt;()&gt;</code>, which lets you use <code>?</code> in them! This
can make them much more concise.</p>
<pre><pre class="playground"><code class="language-rust editable">fn sqrt(number: f64) -&gt; Result&lt;f64, String&gt; {
    if number &gt;= 0.0 {
        Ok(number.powf(0.5))
    } else {
        Err(&quot;negative floats don't have square roots&quot;.to_owned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() -&gt; Result&lt;(), String&gt; {
        let x = 4.0;
        assert_eq!(sqrt(x)?.powf(2.0), x);
        Ok(())
    }
}
</code></pre></pre>
<p>See <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html">&quot;The Edition Guide&quot;</a> for more details.</p>
<h2 id="testing-panics"><a class="header" href="#testing-panics">Testing panics</a></h2>
<p>To check functions that should panic under certain circumstances, use attribute
<code>#[should_panic]</code>. This attribute accepts optional parameter <code>expected = </code> with
the text of the panic message. If your function can panic in multiple ways, it helps
make sure your test is testing the correct panic.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>Running these tests gives us:</p>
<pre><code class="language-shell">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="running-specific-tests"><a class="header" href="#running-specific-tests">Running specific tests</a></h2>
<p>To run specific tests one may specify the test name to <code>cargo test</code> command.</p>
<pre><code class="language-shell">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>To run multiple tests one may specify part of a test name that matches all the
tests that should be run.</p>
<pre><code class="language-shell">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="ignoring-tests"><a class="header" href="#ignoring-tests">Ignoring tests</a></h2>
<p>Tests can be marked with the <code>#[ignore]</code> attribute to exclude some tests. Or to run
them with command <code>cargo test -- --ignored</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">$ cargo test
running 3 tests
test tests::ignored_test ... ignored
test tests::test_add ... ok
test tests::test_add_hundred ... ok

test result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-testing"><a class="header" href="#documentation-testing">Documentation testing</a></h1>
<p>The primary way of documenting a Rust project is through annotating the source
code. Documentation comments are written in <a href="https://daringfireball.net/projects/markdown/">markdown</a> and support code
blocks in them. Rust takes care about correctness, so these code blocks are
compiled and used as tests.</p>
<pre><code class="language-rust ignore">/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate &lt;cratename&gt;`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// Usually doc comments may include sections &quot;Examples&quot;, &quot;Panics&quot; and &quot;Failures&quot;.
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="motivation-behind-documentation-tests"><a class="header" href="#motivation-behind-documentation-tests">Motivation behind documentation tests</a></h2>
<p>The main purpose of documentation tests is to serve as examples that exercise
the functionality, which is one of the most important
<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">guidelines</a>. It allows using examples from docs as
complete code snippets. But using <code>?</code> makes compilation fail since <code>main</code>
returns <code>unit</code>. The ability to hide some source lines from documentation comes
to the rescue: one may write <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>, hide it and
<code>unwrap</code> it in hidden <code>main</code>. Sounds complicated? Here's an example:</p>
<pre><code class="language-rust ignore">/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> on documentation style</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on documentation guidelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-testing"><a class="header" href="#integration-testing">Integration testing</a></h1>
<p><a href="testing/unit_testing.html">Unit tests</a> are testing one module in isolation at a time: they're small
and can test private code. Integration tests are external to your crate and use
only its public interface in the same way any other code would. Their purpose is
to test that many parts of your library work correctly together.</p>
<p>Cargo looks for integration tests in <code>tests</code> directory next to <code>src</code>.</p>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// Assume that crate is called adder, will have to extern it in integration test.
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code would do.
extern crate adder;

#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Running tests with <code>cargo test</code> command:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Each Rust source file in <code>tests</code> directory is compiled as a separate crate. One
way of sharing some code between integration tests is making module with public
functions, importing and using it within tests.</p>
<p>File <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // some setup code, like creating required files/directories, starting
    // servers, etc.
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code will do.
extern crate adder;

// importing common module.
mod common;

#[test]
fn test_add() {
    // using common code.
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Modules with common code follow the ordinary <a href="testing/../mod.html">modules</a> rules, so it's ok to
create common module as <code>tests/common/mod.rs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-dependencies"><a class="header" href="#development-dependencies">Development dependencies</a></h1>
<p>Sometimes there is a need to have dependencies for tests (examples,
benchmarks) only. Such dependencies are added to <code>Cargo.toml</code> in the
<code>[dev-dependencies]</code> section. These dependencies are not propagated to other
packages which depend on this package.</p>
<p>One such example is using a crate that extends standard <code>assert!</code> macros.<br />
File <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># standard crate data is left out
[dev-dependencies]
pretty_assertions = &quot;0.4.0&quot;
</code></pre>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<p><a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> docs on specifying dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Unsafe Operations
-->
<h1 id="安全でない操作"><a class="header" href="#安全でない操作">安全でない操作</a></h1>
<!--
As an introduction to this section, to borrow from [the official docs][unsafe],
"one should try to minimize the amount of unsafe code in a code base." With that
in mind, let's get started! Unsafe annotations in Rust are used to bypass
protections put in place by the compiler; specifically, there are four primary
things that unsafe is used for:
-->
<p>この章の内容を見る前に、<a href="http://doc.rust-lang.org/book/unsafe.html">公式ドキュメント</a>から引用した以下の文章をお読みください。</p>
<blockquote>
<p>コードベース中の、アンセーフな操作をするコードの量は、可能な限り小さく無くてはならない。</p>
</blockquote>
<p>この戒めを頭に叩き込んだ上で、さあはじめましょう！
Rustにおいて、アンセーフなブロックはコンパイラのチェックをスルーするために使われます。具体的には以下の4つの主要なユースケースがあります。</p>
<!--
* dereferencing raw pointers
* calling functions or methods which are `unsafe` (including calling a function
  over FFI, see [a previous chapter](std_misc/ffi.md) of the book) 
* accessing or modifying static mutable variables
* implementing unsafe traits
-->
<ul>
<li>生ポインタのデリファレンス</li>
<li>calling functions or methods which are <code>unsafe</code> (including calling a function
over FFI, see <a href="std_misc/ffi.html">a previous chapter</a> of the book) </li>
<li>accessing or modifying static mutable variables</li>
<li>implementing unsafe traits</li>
</ul>
<!--
### Raw Pointers
Raw pointers `*` and references `&T` function similarly, but references are
always safe because they are guaranteed to point to valid data due to the
borrow checker. Dereferencing a raw pointer can only be done through an unsafe
block.
-->
<h3 id="生ポインタ"><a class="header" href="#生ポインタ">生ポインタ</a></h3>
<p>生ポインタ<code>*</code>と参照<code>&amp;T</code>はよく似た機能を持ちますが、後者は必ず有効なデータを指していることが借用チェッカーによって保証されているので、常に安全です。生ポインタのデリファレンスはアンセーフなブロックでしか実行できません。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3 id="calling-unsafe-functions"><a class="header" href="#calling-unsafe-functions">Calling Unsafe Functions</a></h3>
<p>Some functions can be declared as <code>unsafe</code>, meaning it is the programmer's
responsibility to ensure correctness instead of the compiler's. One example
of this is <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a> which will create a slice given a
pointer to the first element and a length.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p>For <code>slice::from_raw_parts</code>, one of the assumptions which <em>must</em> be upheld is 
that the pointer passed in points to valid memory and that the memory pointed to
is of the correct type. If these invariants aren't upheld then the program's 
behaviour is undefined and there is no knowing what will happen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h1>
<p>The Rust language is fastly evolving, and because of this certain compatibility
issues can arise, despite efforts to ensure forwards-compatibility wherever
possible.</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">Raw identifiers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-identifiers"><a class="header" href="#raw-identifiers">Raw identifiers</a></h1>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.
This is particularly useful when Rust introduces new keywords, and a library
using an older edition of Rust has a variable or function with the same name
as a keyword introduced in a newer edition.</p>
<p>For example, consider a crate <code>foo</code> compiled with the 2015 edition of Rust that
exports a function named <code>try</code>. This keyword is reserved for a new feature in
the 2018 edition, so without raw identifiers, we would have no way to name the
function.</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Meta
-->
<h1 id="周辺情報"><a class="header" href="#周辺情報">周辺情報</a></h1>
<!--
Some topics aren't exactly relevant to how you program but provide you
tooling or infrastructure support which just makes things better for
everyone. These topics include:
-->
<p>この章では、プログラミングそれ自体に関係はないけれども、色々と人々の役に立つ機能やインフラについて説明していきます。例えば:</p>
<!--
* Documentation: Generate library documentation for users via the included
`rustdoc`.
* Testing: Create testsuites for libraries to give confidence that your
library does exactly what it's supposed to.
* Benchmarking: Create benchmarks for functionality to be confident that
they run quickly.
-->
<ul>
<li>ドキュメンテーション: Rust付属コマンド<code>rustdoc</code>を用いて、ライブラリのドキュメントを生成します。</li>
<li>テスト: 自作ライブラリが、想定する動作をしていることを保証するためのテストスイートを作成します。</li>
<li>ベンチマーク: 関数の実行速度が要件を満たすことに確信を持つためのベンチマークを作成します。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# Documentation
-->
<h1 id="ドキュメンテーション"><a class="header" href="#ドキュメンテーション">ドキュメンテーション</a></h1>
<p>Use <code>cargo doc</code> to build documentation in <code>target/doc</code>.</p>
<p>Use <code>cargo test</code> to run all tests (including documentation tests), and <code>cargo test --doc</code> to only run documentation tests.</p>
<p>These commands will appropriately invoke <code>rustdoc</code> (and <code>rustc</code>) as required.</p>
<h3 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h3>
<!--
Doc comments are very useful for big projects that require documentation. When
running Rustdoc, these are the comments that get compiled into
documentation. They are denoted by a `///`, and support [Markdown].
-->
<p>ドキュメンテーションコメントとはRustdocを使用した際にドキュメントにコンパイルされるコメントのことです。<code>///</code>によって普通のコメントと区別され、ここでは<a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>を使用することができます。ドキュメンテーションコメントは大規模なプロジェクトの際に非常に有用です。</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// A human being is represented here
/// あらゆる人物はここに代表されます。
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    /// ジュリエットがどんなに名前というものを嫌っていようと、
    /// 人物には名前が必要です。
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    /// 与えられた名前を持つpersonをを返します。
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    /// * `name` - `person`の名前を表す文字列のスライス
    ///
    /// # Example
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to Rustdoc, it will even test it for you!
    /// // バッククォートによってRustのコードをコメント中に挟むこと
    /// // もできます。Rustdocに--testを渡せば、テストも行えます！
    /// // （訳注: pythonのdoctestと同じです。）
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    /// フレンドリーに挨拶しましょう！
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    /// このメソッドを呼び出した`Person`に対して&quot;Hello, [name]&quot;
    /// と話しかけます。
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>To run the tests, first build the code as a library, then tell rustdoc where
to find the library so it can link it into each doctest program:</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<!--
### See also:
-->
<h3 id="参照-70"><a class="header" href="#参照-70">参照</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The Rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
